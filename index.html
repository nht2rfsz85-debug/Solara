<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Èü≥‰πêÊí≠ÊîæÂô® - Apple Liquid Glass È£éÊ†º</title>
    <style>
        /* Âè™Ê∑ªÂä†ÂøÖË¶ÅÁöÑCSS‰øÆÊîπÔºåÂÖ∂‰ªñCSS‰øùÊåÅ‰∏çÂèò */
        
        /* APIÈÄâÊã©Âô®Ê†∑Âºè */
        .api-select {
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
            min-width: 180px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .api-select:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .api-select option {
            background: #333;
            color: white;
        }
        
        

/* È¢úËâ≤ÁÆóÊ≥ïÂàáÊç¢ÊåâÈíÆÊ†∑Âºè */
.algo-toggle-btn {
    padding: 15px 20px;
    border: none;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    font-size: 1rem;
    backdrop-filter: blur(10px);
    min-width: 180px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.algo-toggle-btn:hover {
    background: rgba(255, 255, 255, 0.2);
}

        /* APIÈÄâÊã©Âô®ÊèêÁ§∫Ê†áÁ≠æ */
        .api-select-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
            margin-left: 5px;
            font-weight: normal;
        }
        
        @media (max-width: 768px) {
            .search-section {
                flex-direction: column;
            }
            
            .api-select, .algo-toggle-btn, .source-select, .quality-select {
                width: 100%;
            }
        }
        
        /* ÊêúÁ¥¢ÁªìÊûú‰∏≠ÁöÑÂπ≥Âè∞Ê†áÁ≠æ */
        .result-item .platform-badge {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 2px;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .result-item .platform-badge.kuwo {
            background: rgba(255, 87, 34, 0.2);
            color: #ff5722;
        }
        
        .result-item .platform-badge.netease {
            background: rgba(216, 30, 6, 0.2);
            color: #d81e06;
        }
        
        .result-item .platform-badge.qq {
            background: rgba(25, 137, 250, 0.2);
            color: #1989fa;
        }
        
        .result-item .platform-badge.joox {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
        
        .result-item .platform-badge.aggregate {
            background: rgba(156, 39, 176, 0.2);
            color: #9c27b0;
        }
        
        /* ÂéüÊúâÁöÑÊâÄÊúâCSS‰øùÊåÅ‰∏çÂèò */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-overflow-scrolling: touch; 
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', 'Inter', sans-serif;
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
            position: relative;
            overflow-x: hidden; 
            background-color: #000;
            -webkit-font-smoothing: antialiased;
        }

        #gradientCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            transform: scale(1.05);
            filter: blur(15px);
            opacity: 0.9;
            transition: opacity 0.5s ease;
        }

        .liquid-glass-effect {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(35px) saturate(180%);
            -webkit-backdrop-filter: blur(35px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4), 
                        inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 20px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        .search-section {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .search-box {
            flex: 1;
            min-width: 300px;
            position: relative;
        }
        
        .search-input {
            width: 100%;
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(255,255,255,0.1);
        }
        
        .source-select, .quality-select {
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
            min-width: 150px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .source-select option, .quality-select option {
            background: #333;
            color: white;
        }

        .source-select:hover, .quality-select:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .search-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .search-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .player-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            .player-container {
                grid-template-columns: 1fr;
            }
        }
        
        .now-playing {
            border-radius: 20px;
            padding: 30px;
            position: relative;
        }
        
        .album-art {
            width: 100%;
            border-radius: 20px;
            margin-bottom: 25px;
            aspect-ratio: 1;
            object-fit: cover;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4);
            display: none;
            transition: transform 0.3s ease;
        }
        
        .album-art-placeholder {
            width: 100%;
            border-radius: 20px;
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 4rem;
            margin-bottom: 25px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
        }
        
        .song-info {
            margin-bottom: 25px;
        }
        
        .song-title {
            font-size: 1.8rem;
            margin-bottom: 8px;
            font-weight: 700;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .song-artist {
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.1rem;
            font-weight: 500;
        }
        
        .progress-container {
            margin-bottom: 25px;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
            margin-bottom: 12px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: white;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .progress-handle {
            position: absolute;
            top: 50%;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .progress-bar:hover .progress-handle {
            opacity: 1;
        }
        
        .time-info {
            display: flex;
            justify-content: space-between;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 25px;
            margin-bottom: 25px;
        }
        
        .control-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }
        
        .play-btn {
            background: rgba(255, 255, 255, 0.2);
            width: 70px;
            height: 70px;
            font-size: 2rem;
        }

        .play-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .speed-control {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.2);
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .speed-control input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            cursor: pointer;
        }
        
        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .lyrics-container {
            border-radius: 20px;
            padding: 30px;
            max-height: 400px;
            overflow-y: auto;
            touch-action: pan-y; 
            position: relative;
        }

        .lyrics-container::-webkit-scrollbar {
            width: 8px;
        }

        .lyrics-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .lyrics-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .lyrics-container::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .fullscreen-lyrics-btn {
            position: absolute;
            bottom: 25px;
            right: 25px;
            background: rgba(255, 255, 255, 0.25);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            z-index: 10;
            font-weight: 600;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .fullscreen-lyrics-btn:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .lyrics-content {
            line-height: 1.8;
            text-align: center;
        }
        
        .lyric-line {
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.5);
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            cursor: pointer;
            padding: 10px 15px;
            border-radius: 12px;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-weight: 500;
        }
        
        .lyric-line.active {
            color: #fff;
            font-size: 1.2rem;
            background: rgba(255, 255, 255, 0.15);
            font-weight: 700;
            transform: scale(1.02);
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .original-text, .translation-text {
            display: inline-block;
            transition: color 0.3s ease;
        }
        .translation-text {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
            font-weight: 400;
        }
        
        .lyric-line.active .translation-text {
            color: rgba(255, 255, 255, 0.85);
        }

        .word-highlight {
            color: #ffcc00;
            transition: color 0.1s linear;
        }

        .fullscreen-lyrics-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
            display: none;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.65); 
            transition: opacity 0.5s ease;
            opacity: 0;
            touch-action: none; 
        }

        .fullscreen-lyrics-overlay.active {
            display: block;
            opacity: 1;
        }

        .fullscreen-lyrics-content {
            position: relative;
            z-index: 2;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0;
        }

        .close-fullscreen-btn {
            position: fixed;
            top: 50px;
            right: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 10000;
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .fullscreen-lyrics-lines {
            width: 100%;
            flex-grow: 1;
            padding: 0 20px 0 40px;
            margin-top: 20px;
            overflow-y: auto;
            text-align: left;
            scrollbar-width: none;
            touch-action: pan-y; 
            mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
        }
        
        .fullscreen-lyrics-lines::-webkit-scrollbar {
            display: none;
        }

        .fullscreen-lyric-line {
            font-size: clamp(2rem, 5vw, 3rem);
            line-height: 1.35;
            padding: 10px 0;
            margin: 25px 0;
            color: rgba(255, 255, 255, 0.4);
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            font-weight: 700;
            cursor: pointer;
        }
        
        .fullscreen-line-wrapper {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .fullscreen-lyric-line.active {
            color: #fff;
            font-size: clamp(2.5rem, 6vw, 3.5rem);
            font-weight: 800;
            transform: scale(1.01);
            text-shadow: 0 4px 30px rgba(0,0,0,0.4);
        }
        
        .fullscreen-translation-text {
            font-size: 0.6em;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        }
        
        .fullscreen-lyric-line.active .fullscreen-translation-text {
             color: rgba(255, 255, 255, 0.85);
        }

        .fullscreen-controls-panel {
            flex-shrink: 0;
            width: 90%;
            max-width: 600px;
            margin-bottom: 50px;
            padding: 15px 25px;
            border-radius: 40px;
        }

        .fullscreen-song-info {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .fullscreen-album-art {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            object-fit: cover;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .fullscreen-track-details {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            white-space: nowrap;
        }

        .fullscreen-song-title {
            font-size: 1.2rem;
            font-weight: 700;
            text-overflow: ellipsis;
        }

        .fullscreen-song-artist {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .fullscreen-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .fullscreen-progress {
            height: 100%;
            background: white;
            border-radius: 2px;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .fullscreen-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
        }

        .fullscreen-control-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            font-size: 2.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .fullscreen-control-btn.play {
            width: 65px;
            height: 65px;
            background: white;
            color: black;
            font-size: 2.5rem;
            padding-left: 5px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .fullscreen-control-btn:hover {
            transform: scale(1.1);
        }
        
        .fullscreen-control-btn.play:hover {
            transform: scale(1.05);
        }
        
        @media (max-width: 900px) {
            .fullscreen-lyrics-content {
                justify-content: flex-end;
                align-items: flex-start;
            }
            .fullscreen-lyrics-lines {
                margin-top: auto;
                height: 60vh;
                padding-bottom: 20px;
                padding-left: 20px;
                text-align: left;
            }
            .fullscreen-lyric-line {
                font-size: clamp(1.8rem, 5vw, 2.5rem);
            }
            .fullscreen-lyric-line.active {
                font-size: clamp(2.3rem, 6vw, 3rem);
            }
            .fullscreen-controls-panel {
                width: 95%;
                margin-bottom: 30px;
            }
            .close-fullscreen-btn {
                top: 20px;
                right: 20px;
            }
        }
        
        .search-results {
            border-radius: 20px;
            padding: 20px;
        }
        
        .results-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 15px;
            padding: 0 10px;
        }

        #resultsContainer {
            overflow: hidden;
        }
        
        .result-item {
            display: flex;
            align-items: center;
            padding: 12px 10px;
            gap: 15px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            position: relative;
            background: rgba(255, 255, 255, 0.05); 
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #resultsContainer .result-item:first-child {
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
        }
        #resultsContainer .result-item:last-child {
            border-bottom-left-radius: 15px;
            border-bottom-right-radius: 15px;
            border-bottom: none;
        }
        
        .result-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.005);
        }
        
        .result-item.active {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.005);
        }

        .result-album {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            object-fit: cover;
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .result-info {
            flex-grow: 1;
            min-width: 0;
            overflow: hidden;
        }

        .result-title {
            font-size: 1.1rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .result-artist {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .result-album-name {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 2px;
        }
        
        .result-platform-info {
            display: flex;
            gap: 8px;
            margin-top: 2px;
        }
        
        .search-results .loading {
            padding: 20px 10px;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
        }

        /* ========== Ë∞ÉËØïÊéßÂà∂Âè∞Ê†∑Âºè ========== */
        .debug-console {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            width: 400px;
            max-height: 500px;
            background: rgba(20, 20, 20, 0.95);
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            transition: all 0.3s ease;
        }
        
        .debug-console.collapsed {
            height: auto;
        }
        
        .debug-console.expanded {
            height: 500px;
        }
        
        .debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: rgba(40, 40, 40, 0.9);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: move;
            user-select: none;
        }
        
        .debug-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .debug-controls {
            display: flex;
            gap: 5px;
        }
        
        .debug-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .debug-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .debug-btn.clear {
            color: #ff6b6b;
        }
        
        .debug-btn.clear:hover {
            background: rgba(255, 107, 107, 0.2);
        }
        
        .debug-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Courier New', Monaco, monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .debug-log {
            margin-bottom: 8px;
            padding: 8px 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.03);
            border-left: 3px solid #4dabf7;
            word-break: break-all;
            white-space: pre-wrap;
            color: #e9ecef;
        }
        
        .debug-log.error {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.08);
            color: #ffc9c9;
        }
        
        .debug-log.warning {
            border-left-color: #ffd43b;
            background: rgba(255, 212, 59, 0.08);
            color: #ffec99;
        }
        
        .debug-log.info {
            border-left-color: #4dabf7;
            background: rgba(77, 171, 247, 0.08);
            color: #c5f6fa;
        }
        
        .debug-log.success {
            border-left-color: #51cf66;
            background: rgba(81, 207, 102, 0.08);
            color: #b2f2bb;
        }
        
        .debug-log.api {
            border-left-color: #9775fa;
            background: rgba(151, 117, 250, 0.08);
            color: #d0bfff;
        }
        
        .debug-timestamp {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 2px;
        }
        
        .debug-message {
            margin-top: 2px;
        }
        
        .debug-toggle-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            width: 50px;
            height: 50px;
            border-radius: 25px;
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        .debug-toggle-btn:hover {
            background: rgba(60, 60, 60, 0.9);
            transform: scale(1.05);
        }
        
        .debug-toggle-btn.hidden {
            display: none;
        }
        
        .debug-console.hidden {
            display: none;
        }
        
        /* ÊªöÂä®Êù°Ê†∑Âºè */
        .debug-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .debug-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        .debug-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }
        
        .debug-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        @media (max-width: 600px) {
            .debug-console {
                width: 95%;
                right: 2.5%;
                bottom: 80px;
                max-height: 300px;
            }
            
            .debug-console.expanded {
                height: 300px;
            }
            
            .result-item {
                padding: 10px;
            }
        }

        @media (max-width: 600px) {
            .result-item {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gradientCanvas"></canvas>

    <div class="container">
        <div class="header liquid-glass-effect">
            <h1>Èü≥‰πêÊí≠ÊîæÂô®</h1>
        </div>
        
        <div class="search-section">
            <div class="search-box">
                <input type="text" class="search-input" id="searchInput" placeholder="ÊêúÁ¥¢Ê≠åÊõ≤„ÄÅÊ≠åÊâãÊàñ‰∏ìËæë..." value="Âë®Êù∞‰º¶">
            </div>
            <!-- Êñ∞Â¢ûÔºöAPIÈÄâÊã©Âô® -->
            <select class="api-select" id="apiSelect" title="ÈÄâÊã©APIÊé•Âè£Ê∫ê">
                <option value="gdstudio" selected>ÂéüAPI (GDStudio)</option>
                <option value="tunehub">Â§áÁî®API (TuneHub)</option>
            </select>
                        <button class="algo-toggle-btn" id="algoToggleBtn" title="ÂàáÊç¢‰∏ìËæëÂ∞ÅÈù¢È¢úËâ≤ÊèêÂèñÁÆóÊ≥ï">ÁÆóÊ≥ïÔºöÂéü(‰∏≠‰ΩçÂàáÂàÜ)</button>
<select class="source-select" id="sourceSelect">
                <option value="kuwo" selected>ÈÖ∑ÊàëÈü≥‰πê</option>
                <option value="joox">JOOXÈü≥‰πê</option>
                <option value="netease">ÁΩëÊòì‰∫ëÈü≥‰πê</option>
                <!-- TuneHub API‰∏ìÁî®ÈÄâÈ°π -->
                <option value="qq">QQÈü≥‰πê (‰ªÖTuneHub)</option>
                <option value="aggregate">ËÅöÂêàÊêúÁ¥¢ (‰ªÖTuneHub)</option>
            </select>
            <button class="search-btn" id="searchBtn">ÊêúÁ¥¢</button>
        </div>
        
        <div class="player-container">
            <div class="now-playing liquid-glass-effect">
                
                <div class="speed-control">
                    <span>ÈÄüÂ∫¶</span>
                    <input type="range" id="speedSlider" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>

                <div class="album-art-placeholder">‚ô™</div>
                <img src="" alt="‰∏ìËæëÂ∞ÅÈù¢" class="album-art" id="albumArt">
                <div class="song-info">
                    <h2 class="song-title" id="songTitle">ËØ∑ÈÄâÊã©Ê≠åÊõ≤</h2>
                    <p class="song-artist" id="songArtist">Êú™Áü•Ëâ∫ÊúØÂÆ∂</p>
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar">
                        <div class="progress" id="progress"></div>
                        <div class="progress-handle" id="progressHandle"></div>
                    </div>
                    <div class="time-info">
                        <span id="currentTime">0:00</span>
                        <span id="duration">0:00</span>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="control-btn" id="prevBtn">‚èÆ</button>
                    <button class="control-btn play-btn" id="playBtn">‚ñ∂</button>
                    <button class="control-btn" id="nextBtn">‚è≠</button>
                </div>
                
                <select class="quality-select" id="qualitySelect">
                    <option value="128">Ê†áÂáÜÂìÅË¥® (128k)</option>
                    <option value="192">ËâØÂ•ΩÂìÅË¥® (192k)</option>
                    <option value="320">È´òÂìÅË¥® (320k)</option>
                    <option value="740">Êó†ÊçüÂìÅË¥® (740k)</option>
                    <option value="999" selected>È´òËß£ÊûêÂ∫¶ (999k)</option>
                </select>
            </div>
            
            <div class="lyrics-container liquid-glass-effect" id="lyricsContainer">
                <h3 class="lyrics-title">Ê≠åËØç</h3>
                <div class="lyrics-content" id="lyricsContent">
                    <div class="loading">ÊöÇÊó†Ê≠åËØç</div>
                </div>
                <button class="fullscreen-lyrics-btn" id="fullscreenLyricsBtn">
                    <span>‚õ∂</span> ÂÖ®Â±èÊ≤âÊµ∏Ê®°Âºè
                </button>
            </div>
        </div>
        
        <div class="search-results liquid-glass-effect">
            <h3 class="results-title">ÊêúÁ¥¢ÁªìÊûú</h3>
            <div id="resultsContainer">
                <div class="loading">ÁÇπÂáªÊêúÁ¥¢ÊåâÈíÆÂºÄÂßãÊêúÁ¥¢Èü≥‰πê</div>
            </div>
        </div>
    </div>

    <div class="fullscreen-lyrics-overlay" id="fullscreenLyricsOverlay">
        <button class="close-fullscreen-btn" id="closeFullscreenBtn">‚úï</button>
        
        <div class="fullscreen-lyrics-content">
            <div class="fullscreen-lyrics-lines" id="fullscreenLyricsLines">
                <div class="loading">ÊöÇÊó†Ê≠åËØç</div>
            </div>

            <div class="fullscreen-controls-panel liquid-glass-effect">
                
                <div class="fullscreen-song-info">
                    <img src="" alt="‰∏ìËæëÂ∞ÅÈù¢" class="fullscreen-album-art" id="fullscreenAlbumArt">
                    <div class="fullscreen-track-details">
                        <div class="fullscreen-song-title" id="fullscreenSongTitle">Ê≠åÊõ≤ÂêçÁß∞</div>
                        <div class="fullscreen-song-artist" id="fullscreenSongArtist">Ëâ∫ÊúØÂÆ∂</div>
                    </div>
                </div>
                
                <div class="fullscreen-progress-bar" id="fullscreenProgressBar">
                    <div class="fullscreen-progress" id="fullscreenProgress"></div>
                </div>
                
                <div class="fullscreen-controls">
                    <button class="fullscreen-control-btn" id="fullscreenPrevBtn">‚èÆ</button>
                    <button class="fullscreen-control-btn play" id="fullscreenPlayBtn">‚ñ∂</button>
                    <button class="fullscreen-control-btn" id="fullscreenNextBtn">‚è≠</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Ë∞ÉËØïÊéßÂà∂Âè∞ -->
    <button class="debug-toggle-btn" id="debugToggleBtn">üêõ</button>
    
    <div class="debug-console hidden" id="debugConsole">
        <div class="debug-header">
            <div class="debug-title">
                <span>üîß Ë∞ÉËØïÊéßÂà∂Âè∞</span>
            </div>
            <div class="debug-controls">
                <button class="debug-btn clear" id="debugClearBtn" title="Ê∏ÖÁ©∫Êó•Âøó">üóëÔ∏è</button>
                <button class="debug-btn" id="debugMinimizeBtn" title="ÊúÄÂ∞èÂåñ">‚àí</button>
                <button class="debug-btn" id="debugCloseBtn" title="ÂÖ≥Èó≠">‚úï</button>
            </div>
        </div>
        <div class="debug-content" id="debugContent">
            <div class="debug-log info">
                <div class="debug-timestamp">Á≥ªÁªüÂêØÂä®</div>
                <div class="debug-message">Ë∞ÉËØïÊéßÂà∂Âè∞Â∑≤ÂàùÂßãÂåñÔºåÁ≠âÂæÖÊìç‰Ωú...</div>
            </div>
        </div>
    </div>

    <audio id="audioPlayer"></audio>

    <script>
        // ========== Ë∞ÉËØïÊéßÂà∂Âè∞Á≥ªÁªü ==========
        // ‰øùÊåÅÂéüÊúâÁöÑË∞ÉËØïÊéßÂà∂Âè∞ÈÄªËæëÔºå‰ΩÜÂª∂ËøüÂàùÂßãÂåñ
        let debugConsole = null;
        
        function initDebugConsole() {
            if (document.getElementById('debugConsole') && !debugConsole) {
                class DebugConsole {
                    constructor() {
                        this.consoleElement = document.getElementById('debugConsole');
                        this.contentElement = document.getElementById('debugContent');
                        this.toggleBtn = document.getElementById('debugToggleBtn');
                        this.clearBtn = document.getElementById('debugClearBtn');
                        this.minimizeBtn = document.getElementById('debugMinimizeBtn');
                        this.closeBtn = document.getElementById('debugCloseBtn');
                        this.isExpanded = true;
                        this.isVisible = false;
                        this.logCount = 0;
                        this.maxLogs = 100;
                        
                        this.init();
                    }
                    
                    init() {
                        // ÁªëÂÆö‰∫ã‰ª∂
                        this.toggleBtn.addEventListener('click', () => this.toggleVisibility());
                        this.clearBtn.addEventListener('click', () => this.clearLogs());
                        this.minimizeBtn.addEventListener('click', () => this.toggleSize());
                        this.closeBtn.addEventListener('click', () => this.hide());
                        
                        // ÂàùÂßãÁä∂ÊÄÅ
                        this.consoleElement.classList.add('expanded');
                        
                        this.log('Á≥ªÁªü', 'Ë∞ÉËØïÊéßÂà∂Âè∞ÂàùÂßãÂåñÂÆåÊàê', 'info');
                    }
                    
                    toggleVisibility() {
                        this.isVisible = !this.isVisible;
                        if (this.isVisible) {
                            this.show();
                        } else {
                            this.hide();
                        }
                    }
                    
                    show() {
                        this.consoleElement.classList.remove('hidden');
                        this.toggleBtn.classList.add('hidden');
                        this.isVisible = true;
                        this.log('Á≥ªÁªü', 'Ë∞ÉËØïÊéßÂà∂Âè∞Â∑≤ÊâìÂºÄ', 'info');
                    }
                    
                    hide() {
                        this.consoleElement.classList.add('hidden');
                        this.toggleBtn.classList.remove('hidden');
                        this.isVisible = false;
                    }
                    
                    toggleSize() {
                        this.isExpanded = !this.isExpanded;
                        if (this.isExpanded) {
                            this.consoleElement.classList.remove('collapsed');
                            this.consoleElement.classList.add('expanded');
                            this.minimizeBtn.textContent = '‚àí';
                            this.minimizeBtn.title = 'ÊúÄÂ∞èÂåñ';
                        } else {
                            this.consoleElement.classList.remove('expanded');
                            this.consoleElement.classList.add('collapsed');
                            this.minimizeBtn.textContent = '‚ñ°';
                            this.minimizeBtn.title = 'ÊúÄÂ§ßÂåñ';
                        }
                    }
                    
                    clearLogs() {
                        this.contentElement.innerHTML = '';
                        this.logCount = 0;
                        this.log('Á≥ªÁªü', 'Êó•ÂøóÂ∑≤Ê∏ÖÁ©∫', 'info');
                    }
                    
                    log(category, message, type = 'info') {
                        this.logCount++;
                        
                        // ÈôêÂà∂Êó•ÂøóÊï∞Èáè
                        if (this.logCount > this.maxLogs) {
                            const logs = this.contentElement.querySelectorAll('.debug-log');
                            if (logs.length > this.maxLogs) {
                                logs[0].remove();
                            }
                        }
                        
                        const timestamp = new Date().toLocaleTimeString('zh-CN', {
                            hour12: false,
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                        
                        const logElement = document.createElement('div');
                        logElement.className = `debug-log ${type}`;
                        
                        logElement.innerHTML = `
                            <div class="debug-timestamp">[${timestamp}] [${category}]</div>
                            <div class="debug-message">${this.escapeHtml(message)}</div>
                        `;
                        
                        this.contentElement.appendChild(logElement);
                        
                        // Ëá™Âä®ÊªöÂä®Âà∞Â∫ïÈÉ®
                        this.contentElement.scrollTop = this.contentElement.scrollHeight;
                    }
                    
                    error(category, message) {
                        this.log(category, message, 'error');
                    }
                    
                    warn(category, message) {
                        this.log(category, message, 'warning');
                    }
                    
                    info(category, message) {
                        this.log(category, message, 'info');
                    }
                    
                    success(category, message) {
                        this.log(category, message, 'success');
                    }
                    
                    api(category, message) {
                        this.log(category, message, 'api');
                    }
                    
                    escapeHtml(text) {
                        const div = document.createElement('div');
                        div.textContent = text;
                        return div.innerHTML;
                    }
                }
                
                debugConsole = new DebugConsole();
            }
        }

        // ========== Âä®ÊÄÅÁΩëÊ†ºÊ∏êÂèòÁ≥ªÁªü ==========
        const canvas = document.getElementById('gradientCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        
        let gradientPoints = [];
        let animationId = null;
        let lastTime = 0;
        let ANIMATION_SPEED_MULTIPLIER = 1.0; 
        
        // ÈªòËÆ§ÈÖçËâ≤ÊñπÊ°à
        const defaultPalette = [
            { r: 47, g: 72, b: 88 },    
            { r: 146, g: 60, b: 88 },   
            { r: 240, g: 99, b: 164 },  
            { r: 45, g: 52, b: 54 },    
            { r: 85, g: 52, b: 124 },   
            { r: 255, g: 159, b: 67 }   
        ];

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // ÂàùÂßãÂåñ 6x6 ÁΩëÊ†ºÁÇπ
        function initGradientPoints(colors = null) {
            gradientPoints = [];
            const cols = 6;
            const rows = 6;
            const width = canvas.width;
            const height = canvas.height;
            const cellW = width / cols;
            const cellH = height / rows;
            const palette = colors && colors.length > 0 ? colors : defaultPalette;

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const baseX = j * cellW + cellW / 2;
                    const baseY = i * cellH + cellH / 2;
                    
                    const colorIdx = (i * cols + j) % palette.length;
                    const initialColor = palette[colorIdx];

                    gradientPoints.push({
                        x: baseX,
                        y: baseY,
                        baseX: baseX,
                        baseY: baseY,
                        color: { ...initialColor },
                        targetColor: { ...initialColor },

                        rangeX: cellW * 1.5,
                        rangeY: cellH * 1.5,
                        phaseX: Math.random() * Math.PI * 2,
                        phaseY: Math.random() * Math.PI * 2,
                        speedX: (0.0001 + Math.random() * 0.0003) * (Math.random() > 0.5 ? 1 : -1),
                        speedY: (0.0001 + Math.random() * 0.0003) * (Math.random() > 0.5 ? 1 : -1),
                        
                        radiusBase: Math.max(width, height) * 0.35, 
                        radiusPhase: Math.random() * Math.PI * 2,
                        radiusSpeed: 0.0005 + Math.random() * 0.0005,
                        
                        phaseZ: Math.random() * Math.PI * 2,
                        speedZ: 0.001 + Math.random() * 0.0015
                    });
                }
            }
        }

        // Ê†∏ÂøÉÊ∏≤ÊüìÂæ™ÁéØ
        function animate(time) {
            if (!lastTime) lastTime = time;
            const deltaTime = time - lastTime;
            lastTime = time;

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-over';

            gradientPoints.forEach(p => {
                const speed = ANIMATION_SPEED_MULTIPLIER;
                p.phaseX += p.speedX * deltaTime * speed;
                p.phaseY += p.speedY * deltaTime * speed;
                p.radiusPhase += p.radiusSpeed * deltaTime * speed;
                p.phaseZ += p.speedZ * deltaTime * speed;

                p.x = p.baseX + Math.sin(p.phaseX) * p.rangeX / 3 + Math.sin(p.phaseZ) * p.rangeX / 6;
                p.y = p.baseY + Math.cos(p.phaseY) * p.rangeY / 3 + Math.cos(p.phaseZ) * p.rangeY / 6;

                const ease = 0.015;
                p.color.r += (p.targetColor.r - p.color.r) * ease;
                p.color.g += (p.targetColor.g - p.color.g) * ease;
                p.color.b += (p.targetColor.b - p.color.b) * ease;

                const currentRadius = p.radiusBase + Math.sin(p.radiusPhase) * (p.radiusBase * 0.1);
                
                const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, currentRadius);
                
                const r = Math.round(p.color.r);
                const gVal = Math.round(p.color.g);
                const b = Math.round(p.color.b);
                
                g.addColorStop(0, `rgba(${r}, ${gVal}, ${b}, 0.8)`);
                g.addColorStop(0.3, `rgba(${r}, ${gVal}, ${b}, 0.5)`);
                g.addColorStop(1, `rgba(${r}, ${gVal}, ${b}, 0)`);

                ctx.fillStyle = g;
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
            });

            animationId = requestAnimationFrame(animate);
        }

        // ========== ÂÆåÊï¥ÁâàÈ¢úËâ≤ÈáèÂåñÁÆóÊ≥ïÔºà‰∏≠‰ΩçÂàáÂàÜÊ≥ï / K-meansÔºâ ==========
        function extractMainColors(img) {
            try {
                if (debugConsole) debugConsole.log('È¢úËâ≤ÊèêÂèñ', 'ÂºÄÂßãÊèêÂèñ‰∏ìËæëÂ∞ÅÈù¢‰∏ªË¶ÅÈ¢úËâ≤...', 'info');
                
                // ÂàõÂª∫CanvasÂ§ÑÁêÜÂõæÂÉè
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // ËÆæÁΩÆCanvasÂ∞∫ÂØ∏ÔºàÈÄÇÂΩìÁº©Â∞è‰ª•ÊèêÈ´òÊÄßËÉΩÔºâ
                const maxSize = 200;
                let width = img.width;
                let height = img.height;
                
                if (width > maxSize || height > maxSize) {
                    const scale = maxSize / Math.max(width, height);
                    width = Math.floor(width * scale);
                    height = Math.floor(height * scale);
                }
                
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);
                
                // Ëé∑ÂèñÂõæÂÉèÊï∞ÊçÆ
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                // Êî∂ÈõÜÊâÄÊúâÂÉèÁ¥†È¢úËâ≤
                const pixels = [];
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    // ÂøΩÁï•ÂÆåÂÖ®ÈÄèÊòéÊàñÊé•ËøëÈÄèÊòéÁöÑÂÉèÁ¥†
                    if (data[i + 3] < 50) continue;
                    
                    pixels.push({ r, g, b });
                }
                
                if (pixels.length === 0) {
                    if (debugConsole) debugConsole.warn('È¢úËâ≤ÊèêÂèñ', 'Êú™ÊèêÂèñÂà∞ÊúâÊïàÂÉèÁ¥†È¢úËâ≤Ôºå‰ΩøÁî®ÈªòËÆ§ÈÖçËâ≤ÊñπÊ°à');
                    return defaultPalette;
                }
                
                if (debugConsole) debugConsole.log('È¢úËâ≤ÊèêÂèñ', `ÊàêÂäüÈááÈõÜ ${pixels.length} ‰∏™ÂÉèÁ¥†ÁÇπÈ¢úËâ≤`, 'success');
                

                // Ê†πÊçÆÈÄâÊã©ÁöÑÁÆóÊ≥ïÊèêÂèñÈ¢úËâ≤
                const colorCount = 12; // ÈúÄË¶ÅÊèêÂèñÁöÑÈ¢úËâ≤Êï∞Èáè
                let colors = [];
                // ----------- Êñ∞Â¢ûÔºöÊ£ÄÊµãÊï¥‰ΩìÈ•±ÂíåÂ∫¶Âíå‰∫ÆÂ∫¶ÔºåÂçïËâ≤ÂõæÁâá‰ΩøÁî®ÊüîÂíåÊ∏êÂèòÈÖçËâ≤ -------------
                // ‰ΩøÁî® HSL ÁªüËÆ°Âπ≥ÂùáÈ•±ÂíåÂ∫¶Âíå‰∫ÆÂ∫¶ÔºåÂèÇËÄÉ‰∫ÜÂõæÂÉèÊ£ÄÊµã‰∏≠‰ΩøÁî® HSV ÁöÑÊúÄ‰ΩéÈ•±ÂíåÂ∫¶Âíå‰∫ÆÂ∫¶ÈòàÂÄºÂà§Êñ≠ÂõæÂÉèÊòØÂê¶‰∏∫ÂΩ©Ëâ≤ÁöÑÊÄùË∑Ø„Äê949361421858664‚Ä†L24-L29„Äë„ÄÇ
                const sampleSize = Math.min(pixels.length, 1000);
                let sumS = 0, sumL = 0;
                let sumR = 0, sumG = 0, sumB = 0;
                const stride = Math.floor(pixels.length / sampleSize) || 1;
                let countSamp = 0;
                for (let i = 0; i < pixels.length && countSamp < sampleSize; i += stride) {
                    const p = pixels[i];
                    const hsl = rgbToHsl(p.r, p.g, p.b);
                    sumS += hsl.s;
                    sumL += hsl.l;
                    sumR += p.r;
                    sumG += p.g;
                    sumB += p.b;
                    countSamp++;
                }
                const avgS = sumS / countSamp;
                const avgL = sumL / countSamp;
                const avgColor = {
                    r: Math.round(sumR / countSamp),
                    g: Math.round(sumG / countSamp),
                    b: Math.round(sumB / countSamp)
                };
                // ÂΩìÂπ≥ÂùáÈ•±ÂíåÂ∫¶Êàñ‰∫ÆÂ∫¶‰Ωé‰∫éÈòàÂÄºÊó∂ÔºåËÆ§ÂÆöÂõæÂÉèËøë‰ººÈªëÁôΩÊàñÁÅ∞Ëâ≤Ôºå‰ΩøÁî®Ê∏êÂèòËâ≤ËÄåÈùûK‚Äëmeans„ÄÇ
                if (avgS < 0.15 || avgL < 0.15) {
                    // ÁîüÊàê‰ªéÊöóÂà∞‰∫ÆÁöÑÊüîÂíåÊ∏êÂèòË∞ÉËâ≤Êùø
                    const palette = [];
                    const maxLighten = 0.5; // ÊúÄÂ§ß‰∫ÆÂåñÊØî‰æãÔºå0.5Ë°®Á§∫Â¢û‰∫Æ‰∏ÄÂçä
                    for (let i = 0; i < colorCount; i++) {
                        const factor = (i / (colorCount - 1)) * maxLighten;
                        palette.push(lightenColor(avgColor, factor));
                    }
                    colors = palette;
                    if (debugConsole) debugConsole.log('È¢úËâ≤ÊèêÂèñ', `Ê£ÄÊµãÂà∞‰ΩéÈ•±ÂíåÂ∫¶/‰Ωé‰∫ÆÂ∫¶ÂõæÂÉèÔºåÁîüÊàêÊ∏êÂèòËâ≤Ë∞ÉÊùø`, 'info');
                } else if (COLOR_EXTRACTION_ALGO === 'kmeans') {
                    // ‰ΩøÁî®Â¢ûÂº∫ÁöÑ K‚Äëmeans ÁâàÊú¨Âú® Lab Á©∫Èó¥‰∏≠ÊèêÂèñ‰∏ªË¶ÅÈ¢úËâ≤„ÄÇËØ•ÁÆóÊ≥ïÂà©Áî® k‚Äëmeans++ ÂàùÂßãÂåñÂíå
                    // ÊÑüÁü•È¢úËâ≤Á©∫Èó¥‰ª•ÊèêÈ´òÁ®≥ÂÆöÊÄßÔºåÂêåÊó∂ËøáÊª§ÊéâÈ•±ÂíåÂ∫¶Ëøá‰ΩéÊàñ‰∫ÆÂ∫¶ÊûÅÁ´ØÁöÑÈ¢úËâ≤Ôºå‰ª•Êõ¥Êé•Ëøë
                    // Apple Music Âä®ÊÄÅËÉåÊôØÁöÑÈÄâËâ≤È£éÊ†º„Äê671412349456928‚Ä†L56-L66„Äë„Äê85381015035948‚Ä†L190-L205„Äë„ÄÇ
                    colors = kMeansAppleStyle(pixels, colorCount, 20);
                    if (debugConsole) debugConsole.log('È¢úËâ≤ÊèêÂèñ', `Â¢ûÂº∫ K-means ÊèêÂèñÂà∞ ${colors.length} Áßç‰∏ªË¶ÅÈ¢úËâ≤`, 'success');
                } else {
                    // ÂéüÁÆóÊ≥ïÔºö‰∏≠‰ΩçÂàáÂàÜÊ≥ïÊèêÂèñÈ¢úËâ≤
                    const buckets = medianCut(pixels, colorCount);
                    // ËÆ°ÁÆóÊØè‰∏™bucketÁöÑÂπ≥ÂùáÈ¢úËâ≤
                    colors = buckets.map(bucket => {
                        let r = 0, g = 0, b = 0;
                        const count = bucket.length;
                        for (let i = 0; i < count; i++) {
                            r += bucket[i].r;
                            g += bucket[i].g;
                            b += bucket[i].b;
                        }
                        return {
                            r: Math.round(r / count),
                            g: Math.round(g / count),
                            b: Math.round(b / count)
                        };
                    });
                    if (debugConsole) debugConsole.log('È¢úËâ≤ÊèêÂèñ', `‰∏≠‰ΩçÂàáÂàÜÊ≥ïÊàêÂäüÊèêÂèñ ${colors.length} Áßç‰∏ªË¶ÅÈ¢úËâ≤`, 'success');
                }

                if (debugConsole) debugConsole.log('È¢úËâ≤ÊèêÂèñ', `ÊèêÂèñÁöÑÈ¢úËâ≤: ${JSON.stringify(colors)}`, 'info');

                return colors;
            } catch (error) {
                if (debugConsole) debugConsole.error('È¢úËâ≤ÊèêÂèñ', `È¢úËâ≤ÊèêÂèñËøáÁ®ãÂá∫Áé∞ÂºÇÂ∏∏: ${error.message}\nÂ†ÜÊ†à: ${error.stack}`);
                return defaultPalette;
            }
        }



// K-meansËÅöÁ±ªÊèêÂèñ‰∏ªË¶ÅÈ¢úËâ≤
function kMeansQuantize(pixels, k = 12, maxIter = 10) {
    // ‰∏∫ÊÄßËÉΩÊéßÂà∂ÔºöÊúÄÂ§öÈááÊ†∑Á∫¶8000‰∏™ÂÉèÁ¥†
    const maxSamples = 8000;
    let samples = pixels;
    if (pixels.length > maxSamples) {
        const stride = Math.ceil(pixels.length / maxSamples);
        samples = [];
        for (let i = 0; i < pixels.length; i += stride) {
            samples.push(pixels[i]);
        }
    }

    // ÈöèÊú∫ÂàùÂßãÂåñËÅöÁ±ª‰∏≠ÂøÉ
    const centroids = [];
    for (let i = 0; i < k; i++) {
        const p = samples[Math.floor(Math.random() * samples.length)];
        centroids.push({ r: p.r, g: p.g, b: p.b });
    }

    const assignments = new Array(samples.length).fill(-1);
    let counts = new Array(k).fill(0);

    for (let iter = 0; iter < maxIter; iter++) {
        const sumR = new Array(k).fill(0);
        const sumG = new Array(k).fill(0);
        const sumB = new Array(k).fill(0);
        counts = new Array(k).fill(0);

        let changed = false;

        for (let i = 0; i < samples.length; i++) {
            const p = samples[i];
            let best = 0;
            let bestDist = Infinity;

            for (let c = 0; c < k; c++) {
                const dr = p.r - centroids[c].r;
                const dg = p.g - centroids[c].g;
                const db = p.b - centroids[c].b;
                const dist = dr * dr + dg * dg + db * db;
                if (dist < bestDist) {
                    bestDist = dist;
                    best = c;
                }
            }

            if (assignments[i] !== best) {
                changed = true;
                assignments[i] = best;
            }

            counts[best]++;
            sumR[best] += p.r;
            sumG[best] += p.g;
            sumB[best] += p.b;
        }

        // Êõ¥Êñ∞ËÅöÁ±ª‰∏≠ÂøÉ
        for (let c = 0; c < k; c++) {
            if (counts[c] > 0) {
                centroids[c].r = sumR[c] / counts[c];
                centroids[c].g = sumG[c] / counts[c];
                centroids[c].b = sumB[c] / counts[c];
            } else {
                // Á©∫Á∞áÈáçÊñ∞ÈöèÊú∫ÂàùÂßãÂåñ
                const p = samples[Math.floor(Math.random() * samples.length)];
                centroids[c] = { r: p.r, g: p.g, b: p.b };
            }
        }

        if (!changed) break;
    }

    // ÊåâÁ∞áÂ§ßÂ∞èÊéíÂ∫èÔºàÊõ¥‚Äú‰∏ªËâ≤‚Äù‰ºòÂÖàÔºâ
    const items = centroids.map((c, idx) => ({
        r: Math.round(c.r),
        g: Math.round(c.g),
        b: Math.round(c.b),
        count: counts[idx] || 0
    })).sort((a, b) => b.count - a.count);

    return items.map(({ r, g, b }) => ({ r, g, b }));
}

        /*
         * ------------------------------------------------------------------------
         * Apple‚Äëstyle K‚ÄëMeans color extraction
         *
         * The following helper functions implement color space conversions and
         * k‚Äëmeans++ initialization so that we can perform clustering in the
         * perceptual CIE¬†Lab space. Apple Music‚Äôs dynamic backgrounds avoid
         * greys and extremes; therefore after clustering we filter out colors
         * with very low saturation or very high/low lightness using HSL.  The
         * resulting palette better approximates the subtle, balanced backgrounds
         * used in Apple‚Äôs apps.  References: K‚Äëmeans clustering randomly
         * initializes centroids then iteratively assigns points and updates
         * centers„Äê671412349456928‚Ä†L56-L66„Äë.  Dynamic theming guidelines stress
         * checking the luma and contrast of extracted colors to ensure
         * readability„Äê85381015035948‚Ä†L190-L205„Äë.
         */

        // Convert sRGB to XYZ. Assumes r,g,b in [0,255]. Returns x,y,z in [0,1].
        function rgbToXyz(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
            const x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
            const y = r * 0.2126729 + g * 0.7151522 + b * 0.0721750;
            const z = r * 0.0193339 + g * 0.1191920 + b * 0.9503041;
            return { x, y, z };
        }

        // Convert XYZ to CIE¬†Lab. Input x,y,z in [0,1]. Returns L,a,b.
        function xyzToLab(x, y, z) {
            const refX = 0.95047;
            const refY = 1.00000;
            const refZ = 1.08883;
            let xr = x / refX;
            let yr = y / refY;
            let zr = z / refZ;
            const epsilon = 0.008856;
            const kappa = 903.3;
            const fx = xr > epsilon ? Math.cbrt(xr) : (kappa * xr + 16) / 116;
            const fy = yr > epsilon ? Math.cbrt(yr) : (kappa * yr + 16) / 116;
            const fz = zr > epsilon ? Math.cbrt(zr) : (kappa * zr + 16) / 116;
            const L = 116 * fy - 16;
            const a = 500 * (fx - fy);
            const b = 200 * (fy - fz);
            return { L, a, b };
        }

        // Convert Lab to XYZ. Input L,a,b. Returns x,y,z.
        function labToXyz(L, a, b) {
            const refX = 0.95047;
            const refY = 1.00000;
            const refZ = 1.08883;
            const fy = (L + 16) / 116;
            const fx = a / 500 + fy;
            const fz = fy - b / 200;
            const epsilon = 0.008856;
            const cube = (t) => t * t * t;
            let xr = cube(fx) > epsilon ? cube(fx) : (116 * fx - 16) / 903.3;
            let yr = cube(fy) > epsilon ? cube(fy) : (116 * fy - 16) / 903.3;
            let zr = cube(fz) > epsilon ? cube(fz) : (116 * fz - 16) / 903.3;
            const x = xr * refX;
            const y = yr * refY;
            const z = zr * refZ;
            return { x, y, z };
        }

        // Convert XYZ to sRGB. Input x,y,z in [0,1]. Returns r,g,b in [0,255].
        function xyzToRgb(x, y, z) {
            let r = x * 3.2404542 + y * -1.5371385 + z * -0.4985314;
            let g = x * -0.9692660 + y * 1.8760108 + z * 0.0415560;
            let bb = x * 0.0556434 + y * -0.2040259 + z * 1.0572252;
            // gamma correction
            r = r <= 0.0031308 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055;
            g = g <= 0.0031308 ? 12.92 * g : 1.055 * Math.pow(g, 1 / 2.4) - 0.055;
            bb = bb <= 0.0031308 ? 12.92 * bb : 1.055 * Math.pow(bb, 1 / 2.4) - 0.055;
            return {
                r: Math.min(255, Math.max(0, Math.round(r * 255))),
                g: Math.min(255, Math.max(0, Math.round(g * 255))),
                b: Math.min(255, Math.max(0, Math.round(bb * 255)))
            };
        }

        // Combined conversion: RGB ‚Üí Lab
        function rgbToLab(r, g, b) {
            const xyz = rgbToXyz(r, g, b);
            return xyzToLab(xyz.x, xyz.y, xyz.z);
        }

        // Combined conversion: Lab ‚Üí RGB
        function labToRgb(L, a, b) {
            const xyz = labToXyz(L, a, b);
            return xyzToRgb(xyz.x, xyz.y, xyz.z);
        }

        // Convert RGB to HSL. Returns h in degrees, s and l in [0,1].
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h = 0, s = 0;
            const l = (max + min) / 2;
            if (max !== min) {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h: h * 360, s, l };
        }

        // Lighten a color towards white by a given factor (0..1).
        // This helper is used for monochrome images where we want a subtle gradient palette.
        function lightenColor(color, factor) {
            return {
                r: Math.round(color.r + (255 - color.r) * factor),
                g: Math.round(color.g + (255 - color.g) * factor),
                b: Math.round(color.b + (255 - color.b) * factor)
            };
        }

        // k‚Äëmeans++ initialization for Lab points
        function initializeCentroidsPlusPlus(samples, k) {
            const centroids = [];
            // first centroid randomly selected
            const firstIndex = Math.floor(Math.random() * samples.length);
            centroids.push({ L: samples[firstIndex].L, a: samples[firstIndex].a, b: samples[firstIndex].b });
            while (centroids.length < k) {
                const distances = new Array(samples.length);
                let total = 0;
                for (let i = 0; i < samples.length; i++) {
                    let minDist = Infinity;
                    const s = samples[i];
                    for (const c of centroids) {
                        const dL = s.L - c.L;
                        const da = s.a - c.a;
                        const db = s.b - c.b;
                        const dist = dL * dL + da * da + db * db;
                        if (dist < minDist) minDist = dist;
                    }
                    distances[i] = minDist;
                    total += minDist;
                }
                let threshold = Math.random() * total;
                let index = 0;
                while (threshold > 0 && index < samples.length) {
                    threshold -= distances[index];
                    index++;
                }
                const chosen = samples[Math.min(index, samples.length - 1)];
                centroids.push({ L: chosen.L, a: chosen.a, b: chosen.b });
            }
            return centroids;
        }

        // Enhanced K‚Äëmeans color quantization using Lab space and basic filtering
        function kMeansAppleStyle(pixels, k = 12, maxIter = 20) {
            // Downsample to ~8000 samples to speed up processing
            const maxSamples = 8000;
            let samples = pixels;
            if (pixels.length > maxSamples) {
                const stride = Math.ceil(pixels.length / maxSamples);
                samples = [];
                for (let i = 0; i < pixels.length; i += stride) {
                    samples.push(pixels[i]);
                }
            }
            // Convert samples to Lab
            const labSamples = samples.map(p => {
                const lab = rgbToLab(p.r, p.g, p.b);
                return { L: lab.L, a: lab.a, b: lab.b, r: p.r, g: p.g, b2: p.b };
            });
            // Initialize centroids
            let centroids = initializeCentroidsPlusPlus(labSamples, k);
            const assignments = new Array(labSamples.length).fill(-1);
            let counts = new Array(k).fill(0);
            for (let iter = 0; iter < maxIter; iter++) {
                const sumL = new Array(k).fill(0);
                const suma = new Array(k).fill(0);
                const sumb = new Array(k).fill(0);
                counts = new Array(k).fill(0);
                let changed = false;
                // assignment step
                for (let i = 0; i < labSamples.length; i++) {
                    const s = labSamples[i];
                    let best = 0;
                    let bestDist = Infinity;
                    for (let c = 0; c < k; c++) {
                        const dL = s.L - centroids[c].L;
                        const da = s.a - centroids[c].a;
                        const db = s.b - centroids[c].b;
                        const dist = dL * dL + da * da + db * db;
                        if (dist < bestDist) {
                            bestDist = dist;
                            best = c;
                        }
                    }
                    if (assignments[i] !== best) {
                        changed = true;
                        assignments[i] = best;
                    }
                    counts[best]++;
                    sumL[best] += s.L;
                    suma[best] += s.a;
                    sumb[best] += s.b;
                }
                // update step
                for (let c = 0; c < k; c++) {
                    if (counts[c] > 0) {
                        centroids[c].L = sumL[c] / counts[c];
                        centroids[c].a = suma[c] / counts[c];
                        centroids[c].b = sumb[c] / counts[c];
                    } else {
                        // reinitialize empty cluster to farthest sample
                        let maxDist = -1;
                        let chosen = labSamples[0];
                        for (const s of labSamples) {
                            let minDist = Infinity;
                            for (let j = 0; j < k; j++) {
                                const dL = s.L - centroids[j].L;
                                const da = s.a - centroids[j].a;
                                const dbb = s.b - centroids[j].b;
                                const dist = dL * dL + da * da + dbb * dbb;
                                if (dist < minDist) minDist = dist;
                            }
                            if (minDist > maxDist) {
                                maxDist = minDist;
                                chosen = s;
                            }
                        }
                        centroids[c] = { L: chosen.L, a: chosen.a, b: chosen.b };
                    }
                }
                if (!changed) break;
            }
            // Convert centroids to RGB and calculate scores based on population, saturation and lightness.
            const items = centroids.map((c, idx) => {
                const rgb = labToRgb(c.L, c.a, c.b);
                const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
                // Score favours clusters with more pixels, higher saturation and moderate lightness.
                // Adding constants prevents zeroing out clusters with low saturation or extreme brightness entirely.
                const pop = counts[idx] || 0;
                const satFactor = 0.5 + hsl.s; // range [0.5, 1.5]
                const lightFactor = 0.3 + (1 - Math.abs(hsl.l - 0.5)); // range [0.3, 1.3]
                const score = pop * satFactor * lightFactor;
                return { r: rgb.r, g: rgb.g, b: rgb.b, count: pop, hsl, score };
            }).sort((a, b) => b.score - a.score);
            // Filter out greys and extremes using HSL thresholds
            const filtered = [];
            for (const item of items) {
                const { hsl } = item;
                if (hsl.s > 0.1 && hsl.l > 0.1 && hsl.l < 0.95) {
                    filtered.push({ r: item.r, g: item.g, b: item.b });
                }
            }
            // If not enough colours pass the filter, fall back to the highest‚Äëscoring centroids.
            let result = filtered;
            if (result.length < k) {
                for (const item of items) {
                    const exists = result.find(c => c.r === item.r && c.g === item.g && c.b === item.b);
                    if (!exists) {
                        result.push({ r: item.r, g: item.g, b: item.b });
                    }
                    if (result.length >= k) break;
                }
            }
            return result.slice(0, k);
        }

        // ‰∏≠‰ΩçÂàáÂàÜÊ≥ïÂÆûÁé∞
        function medianCut(pixels, targetColors) {
            // ÂàùÂßãÂåñ‰∏Ä‰∏™bucketÂåÖÂê´ÊâÄÊúâÂÉèÁ¥†
            let buckets = [pixels];
            
            // ÊåÅÁª≠ÂàáÂàÜÁõ¥Âà∞ËææÂà∞ÁõÆÊ†áÈ¢úËâ≤Êï∞Èáè
            while (buckets.length < targetColors) {
                // ÊâæÂà∞ÊúÄÂ§ßÁöÑbucketÊù•ÂàáÂàÜ
                let largestBucketIndex = 0;
                let largestBucketSize = 0;
                
                for (let i = 0; i < buckets.length; i++) {
                    if (buckets[i].length > largestBucketSize) {
                        largestBucketSize = buckets[i].length;
                        largestBucketIndex = i;
                    }
                }
                
                const bucketToSplit = buckets[largestBucketIndex];
                
                // Â¶ÇÊûúbucketÂ§™Â∞èÔºåÊó†Ê≥ïÁªßÁª≠ÂàáÂàÜ
                if (bucketToSplit.length < 2) {
                    break;
                }
                
                // ÊâæÂà∞È¢úËâ≤ËåÉÂõ¥ÊúÄÂ§ßÁöÑÈÄöÈÅì
                let rMin = 255, rMax = 0;
                let gMin = 255, gMax = 0;
                let bMin = 255, bMax = 0;
                
                for (let i = 0; i < bucketToSplit.length; i++) {
                    const pixel = bucketToSplit[i];
                    rMin = Math.min(rMin, pixel.r);
                    rMax = Math.max(rMax, pixel.r);
                    gMin = Math.min(gMin, pixel.g);
                    gMax = Math.max(gMax, pixel.g);
                    bMin = Math.min(bMin, pixel.b);
                    bMax = Math.max(bMax, pixel.b);
                }
                
                const rRange = rMax - rMin;
                const gRange = gMax - gMin;
                const bRange = bMax - bMin;
                
                // Á°ÆÂÆöÂàáÂàÜÈÄöÈÅì
                let splitChannel;
                if (rRange >= gRange && rRange >= bRange) {
                    splitChannel = 'r';
                } else if (gRange >= rRange && gRange >= bRange) {
                    splitChannel = 'g';
                } else {
                    splitChannel = 'b';
                }
                
                // ÊåâÈÄâÂÆöÈÄöÈÅìÊéíÂ∫è
                bucketToSplit.sort((a, b) => a[splitChannel] - b[splitChannel]);
                
                // ÊâæÂà∞‰∏≠‰ΩçÊï∞
                const medianIndex = Math.floor(bucketToSplit.length / 2);
                
                // ÂàáÂàÜbucket
                const bucket1 = bucketToSplit.slice(0, medianIndex);
                const bucket2 = bucketToSplit.slice(medianIndex);
                
                // ÊõøÊç¢Âéübucket‰∏∫‰∏§‰∏™Êñ∞bucket
                buckets.splice(largestBucketIndex, 1, bucket1, bucket2);
            }
            
            return buckets;
        }

        // ‰ªé‰∏ìËæëÂ∞ÅÈù¢ÊèêÂèñ‰∏ªË¶ÅÈ¢úËâ≤
        function updateGradientFromAlbum(imageUrl) {
            if (!imageUrl) {
                if (debugConsole) debugConsole.warn('Ê∏êÂèòËÉåÊôØ', 'Êó†‰∏ìËæëÂ∞ÅÈù¢URLÔºå‰ΩøÁî®ÈªòËÆ§È¢úËâ≤');
                gradientPoints.forEach((p, i) => {
                    const newColor = defaultPalette[i % defaultPalette.length];
                    p.targetColor = { ...newColor };
                });
                return;
            }
            
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                try {
                    if (debugConsole) debugConsole.log('Ê∏êÂèòËÉåÊôØ', 'ÂºÄÂßã‰ªé‰∏ìËæëÂ∞ÅÈù¢ÊèêÂèñÈ¢úËâ≤...', 'info');
                    const colors = extractMainColors(img);
                    
                    // Á°Æ‰øùÊàë‰ª¨ÊúâË∂≥Â§üÁöÑÈ¢úËâ≤
                    let extendedColors = [];
                    while (extendedColors.length < 36) {
                        extendedColors = extendedColors.concat(colors);
                    }
                    
                    // Êõ¥Êñ∞Ê∏êÂèòÁÇπÁöÑÁõÆÊ†áÈ¢úËâ≤
                    gradientPoints.forEach((p, i) => {
                        const newColor = extendedColors[i];
                        if (newColor) {
                            p.targetColor = { ...newColor };
                        }
                    });
                    
                    if (debugConsole) debugConsole.success('Ê∏êÂèòËÉåÊôØ', '‰∏ìËæëÂ∞ÅÈù¢È¢úËâ≤ÊèêÂèñÂÆåÊàêÔºåÊ∏êÂèòËÉåÊôØÂ∑≤Êõ¥Êñ∞');
                } catch (error) {
                    if (debugConsole) debugConsole.error('Ê∏êÂèòËÉåÊôØ', `‰∏ìËæëÂ∞ÅÈù¢È¢úËâ≤ÊèêÂèñÂ§±Ë¥•: ${error.message}`);
                }
            };
            
            img.onerror = (e) => {
                if (debugConsole) debugConsole.error('Ê∏êÂèòËÉåÊôØ', `‰∏ìËæëÂ∞ÅÈù¢ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•: ${imageUrl}\nÈîôËØØ‰ø°ÊÅØ: ${e.message}`);
                // Âä†ËΩΩÂ§±Ë¥•‰ΩøÁî®ÈªòËÆ§Ëâ≤
                gradientPoints.forEach((p, i) => {
                    const newColor = defaultPalette[i % defaultPalette.length];
                    p.targetColor = { ...newColor };
                });
            };
            
            img.src = imageUrl;
        }

        function startGradientAnimation() {
            if (animationId) cancelAnimationFrame(animationId);
            resizeCanvas();
            initGradientPoints(); 
            animate(0);
            if (debugConsole) debugConsole.log('Ê∏êÂèòËÉåÊôØ', 'Âä®ÊÄÅÊ∏êÂèòËÉåÊôØÁ≥ªÁªüÂ∑≤ÂêØÂä®', 'success');
        }

        // ========== Èü≥‰πêÊí≠ÊîæÂô®ÈÄªËæë ==========
        const searchInput = document.getElementById('searchInput');
        const apiSelect = document.getElementById('apiSelect'); // Êñ∞Â¢ûÔºöAPIÈÄâÊã©Âô®
        const algoToggleBtn = document.getElementById('algoToggleBtn'); // Êñ∞Â¢ûÔºöÈ¢úËâ≤ÁÆóÊ≥ïÂàáÊç¢ÊåâÈíÆ
        const sourceSelect = document.getElementById('sourceSelect');
        const searchBtn = document.getElementById('searchBtn');
        const albumArt = document.getElementById('albumArt');
        const albumArtPlaceholder = document.querySelector('.album-art-placeholder');
        const songTitle = document.getElementById('songTitle');
        const songArtist = document.getElementById('songArtist');
        const progressBar = document.getElementById('progressBar');
        const progress = document.getElementById('progress');
        const progressHandle = document.getElementById('progressHandle');
        const currentTime = document.getElementById('currentTime');
        const duration = document.getElementById('duration');
        const playBtn = document.getElementById('playBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const qualitySelect = document.getElementById('qualitySelect');
        const lyricsContainer = document.getElementById('lyricsContainer');
        const lyricsContent = document.getElementById('lyricsContent');
        const resultsContainer = document.getElementById('resultsContainer');
        const audioPlayer = document.getElementById('audioPlayer');

        const fullscreenLyricsBtn = document.getElementById('fullscreenLyricsBtn');
        const fullscreenLyricsOverlay = document.getElementById('fullscreenLyricsOverlay');
        const closeFullscreenBtn = document.getElementById('closeFullscreenBtn');
        const fullscreenAlbumArt = document.getElementById('fullscreenAlbumArt');
        const fullscreenSongTitle = document.getElementById('fullscreenSongTitle');
        const fullscreenSongArtist = document.getElementById('fullscreenSongArtist');
        const fullscreenLyricsLines = document.getElementById('fullscreenLyricsLines');
        const fullscreenProgressBar = document.getElementById('fullscreenProgressBar');
        const fullscreenProgress = document.getElementById('fullscreenProgress');
        const fullscreenPlayBtn = document.getElementById('fullscreenPlayBtn');
        const fullscreenPrevBtn = document.getElementById('fullscreenPrevBtn');
        const fullscreenNextBtn = document.getElementById('fullscreenNextBtn');
        
        const speedSlider = document.getElementById('speedSlider');

        let currentTrack = null;
        let searchResults = [];
        let requestTimestamps = [];
        let mergedLyricsData = null;
        let isDragging = false;
        let userScrolledLyrics = false;
        let currentAlbumUrl = null;
        
        // APIÈÖçÁΩÆ - ‰∏§Â•óÁã¨Á´ãÁ≥ªÁªü
        const API_CONFIG = {
            gdstudio: {
                name: 'ÂéüAPI (GDStudio)',
                baseUrl: 'https://music-api.gdstudio.xyz/api.php',
                // ÂéüAPIÈü≥Ë¥®ÈÄâÈ°π
                qualities: [
                    { value: '128', label: 'Ê†áÂáÜÂìÅË¥® (128k)' },
                    { value: '192', label: 'ËâØÂ•ΩÂìÅË¥® (192k)' },
                    { value: '320', label: 'È´òÂìÅË¥® (320k)' },
                    { value: '740', label: 'Êó†ÊçüÂìÅË¥® (740k)' },
                    { value: '999', label: 'È´òËß£ÊûêÂ∫¶ (999k)' }
                ]
            },
            tunehub: {
                name: 'Â§áÁî®API (TuneHub)',
                // TuneHub API Âü∫Á°ÄË∑ØÂæÑÔºå‰ΩøÁî® music-dl.sayqz.com Êèê‰æõÁöÑÊé•Âè£
                baseUrl: 'https://music-dl.sayqz.com/api/',
                // TuneHub APIÈü≥Ë¥®ÈÄâÈ°π - ‰∏éÈü≥‰πê‰∏ãËΩΩ.htmlÂÆåÂÖ®‰∏ÄËá¥
                qualities: [
                    { value: '128k', label: 'Ê†áÂáÜÂìÅË¥® (128k)' },
                    { value: '320k', label: 'È´òÂìÅË¥® (320k)' },
                    { value: 'flac', label: 'Êó†ÊçüÂìÅË¥® (FLAC)' },
                    { value: 'flac24bit', label: 'È´òËß£ÊûêÂ∫¶ (24bit FLAC)' }
                ]
            }
        };

        // Êõ¥Êñ∞Èü≥‰πêÊ∫êÈÄâÊã©ÈÄâÈ°π
        function updateSourceOptions() {
            const api = apiSelect.value;
            const sourceOptions = sourceSelect.options;
            
            // ÈáçÁΩÆÊâÄÊúâÈÄâÈ°π
            for (let i = 0; i < sourceOptions.length; i++) {
                sourceOptions[i].disabled = false;
                sourceOptions[i].style.display = '';
            }
            
            if (api === 'tunehub') {
                // TuneHub APIÊîØÊåÅÁöÑÂπ≥Âè∞
                if (debugConsole) debugConsole.info('APIÂàáÊç¢', 'ÂàáÊç¢Âà∞TuneHub APIÔºåÊõ¥Êñ∞Âπ≥Âè∞ÈÄâÈ°π');
                
                // ÂêØÁî®TuneHubÊîØÊåÅÁöÑÈÄâÈ°πÔºåÁ¶ÅÁî®‰∏çÊîØÊåÅÁöÑ
                for (let i = 0; i < sourceOptions.length; i++) {
                    const option = sourceOptions[i];
                    const value = option.value;
                    
                    // TuneHubÊîØÊåÅÁöÑÂπ≥Âè∞Ôºönetease, kuwo, qq, aggregate
                    if (value === 'netease' || value === 'kuwo' || value === 'qq' || value === 'aggregate') {
                        option.disabled = false;
                        option.style.display = '';
                    } else {
                        option.disabled = true;
                        option.style.display = 'none';
                    }
                }
                
                // ËÆæÁΩÆÈªòËÆ§ÂÄº
                if (!['netease', 'kuwo', 'qq', 'aggregate'].includes(sourceSelect.value)) {
                    sourceSelect.value = 'netease';
                }
            } else {
                // ÂéüAPIÊîØÊåÅÁöÑÂπ≥Âè∞
                if (debugConsole) debugConsole.info('APIÂàáÊç¢', 'ÂàáÊç¢Âà∞ÂéüAPIÔºåÊÅ¢Â§çÂπ≥Âè∞ÈÄâÈ°π');
                
                // ÊÅ¢Â§çÊâÄÊúâÈÄâÈ°π
                for (let i = 0; i < sourceOptions.length; i++) {
                    const option = sourceOptions[i];
                    const value = option.value;
                    
                    // ÂéüAPIÊîØÊåÅÁöÑÂπ≥Âè∞Ôºökuwo, joox, netease
                    if (value === 'kuwo' || value === 'joox' || value === 'netease') {
                        option.disabled = false;
                        option.style.display = '';
                    } else {
                        option.disabled = true;
                        option.style.display = 'none';
                    }
                }
                
                // ËÆæÁΩÆÈªòËÆ§ÂÄº
                if (!['kuwo', 'joox', 'netease'].includes(sourceSelect.value)) {
                    sourceSelect.value = 'kuwo';
                }
            }
        }

        // Êõ¥Êñ∞Èü≥Ë¥®ÈÄâÈ°π
        function updateQualityOptions() {
            const api = apiSelect.value;
            const apiConfig = API_CONFIG[api];
            const qualitySelect = document.getElementById('qualitySelect');
            
            // Ê∏ÖÁ©∫Áé∞ÊúâÈÄâÈ°π
            qualitySelect.innerHTML = '';
            
            // Ê∑ªÂä†Êñ∞ÈÄâÈ°π
            apiConfig.qualities.forEach(quality => {
                const option = document.createElement('option');
                option.value = quality.value;
                option.textContent = quality.label;
                qualitySelect.appendChild(option);
            });
            
            if (debugConsole) debugConsole.info('Èü≥Ë¥®ÈÄâÈ°π', `Â∑≤Êõ¥Êñ∞‰∏∫ ${apiConfig.name} ÁöÑÈü≥Ë¥®ÈÄâÈ°π`);
        }

        // APIÈÄâÊã©Âô®‰∫ã‰ª∂
        apiSelect.addEventListener('change', () => {
            if (debugConsole) debugConsole.info('APIÂàáÊç¢', `ÂàáÊç¢Âà∞: ${apiSelect.value} - ${API_CONFIG[apiSelect.value].name}`);
            updateSourceOptions();
            updateQualityOptions();
        });

        // ÂàùÂßãÂåñÊó∂Êõ¥Êñ∞ÈÄâÈ°π
        updateSourceOptions();
        updateQualityOptions();


// ========== È¢úËâ≤ÊèêÂèñÁÆóÊ≥ïÂàáÊç¢ÔºàÂéüÔºö‰∏≠‰ΩçÂàáÂàÜ / Êñ∞ÔºöK-meansÔºâ ==========
let COLOR_EXTRACTION_ALGO = localStorage.getItem('colorExtractionAlgo') || 'medianCut'; // 'medianCut' | 'kmeans'

function updateAlgoToggleButton() {
    if (!algoToggleBtn) return;
    algoToggleBtn.textContent = COLOR_EXTRACTION_ALGO === 'kmeans' ? 'ÁÆóÊ≥ïÔºöK-means' : 'ÁÆóÊ≥ïÔºöÂéü(‰∏≠‰ΩçÂàáÂàÜ)';
}

if (algoToggleBtn) {
    updateAlgoToggleButton();
    algoToggleBtn.addEventListener('click', () => {
        COLOR_EXTRACTION_ALGO = (COLOR_EXTRACTION_ALGO === 'kmeans') ? 'medianCut' : 'kmeans';
        localStorage.setItem('colorExtractionAlgo', COLOR_EXTRACTION_ALGO);
        updateAlgoToggleButton();
        if (debugConsole) debugConsole.info('È¢úËâ≤ÊèêÂèñ', `Â∑≤ÂàáÊç¢È¢úËâ≤ÊèêÂèñÁÆóÊ≥ï‰∏∫: ${COLOR_EXTRACTION_ALGO === 'kmeans' ? 'K-means' : 'Âéü(‰∏≠‰ΩçÂàáÂàÜ)'}`);

        // Â¶ÇÊûúÂΩìÂâçÂ∑≤Êúâ‰∏ìËæëÂ∞ÅÈù¢ÔºåÁ´ãÂç≥ÊåâÊñ∞ÁÆóÊ≥ïÂà∑Êñ∞ËÉåÊôØ
        if (currentAlbumUrl) {
            updateGradientFromAlbum(currentAlbumUrl);
        }
    });
}


        function checkRateLimit() {
            const now = Date.now();
            const fiveMinutesAgo = now - 5 * 60 * 1000;
            requestTimestamps = requestTimestamps.filter(timestamp => timestamp > fiveMinutesAgo);
            
            if (requestTimestamps.length >= 60) {
                const message = 'APIËØ∑Ê±ÇÈ¢ëÁéáËøáÈ´òÔºåÂ∑≤Ë∂ÖËøáÈôêÂà∂Ôºà5ÂàÜÈíüÂÜÖÊúÄÂ§ö60Ê¨°ËØ∑Ê±ÇÔºâ„ÄÇËØ∑Á≠âÂæÖ5ÂàÜÈíüÂêéÂÜçËØï„ÄÇÂΩìÂâçËØ∑Ê±ÇÊ¨°Êï∞Ôºö' + requestTimestamps.length;
                if (debugConsole) debugConsole.error('APIÈôêÂà∂', message);
                return false;
            }
            
            requestTimestamps.push(now);
            if (debugConsole) debugConsole.info('APIËØ∑Ê±Ç', `ÂΩìÂâç5ÂàÜÈíüÂÜÖAPIËØ∑Ê±ÇÊ¨°Êï∞: ${requestTimestamps.length}/60`);
            return true;
        }

        // TuneHub APIËØ∑Ê±ÇÂáΩÊï∞ - ÂÆåÂÖ®ÊåâÁÖßÈü≥‰πê‰∏ãËΩΩ.htmlÁöÑÊñπÂºè
        async function tunehubRequest(params) {
            try {
                const apiConfig = API_CONFIG.tunehub;
                const url = new URL(apiConfig.baseUrl);
                
                // Áõ¥Êé•‰ΩøÁî®ÂèÇÊï∞Ôºå‰∏çËøõË°åÊò†Â∞Ñ
                Object.keys(params).forEach(k => {
                    if (params[k] !== undefined && params[k] !== null) {
                        url.searchParams.append(k, params[k]);
                    }
                });
                
                const urlString = url.toString();
                if (debugConsole) debugConsole.api('TuneHub APIËØ∑Ê±Ç', `ÂèëÈÄÅËØ∑Ê±Ç: ${urlString}`);
                
                const response = await fetch(urlString);
                
                if (!response.ok) {
                    const errorMsg = `HTTPËØ∑Ê±ÇÂ§±Ë¥•: Áä∂ÊÄÅÁ†Å ${response.status} ${response.statusText}`;
                    if (debugConsole) debugConsole.error('TuneHub APIËØ∑Ê±Ç', errorMsg);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // Èü≥È¢ëURLËØ∑Ê±ÇËøîÂõûÊñáÊú¨
                if (params.type === 'url') {
                    const audioUrl = await response.text();
                    if (debugConsole) debugConsole.api('TuneHub APIËØ∑Ê±Ç', `Èü≥È¢ëURLËé∑ÂèñÊàêÂäü: ${audioUrl.substring(0, 100)}...`);
                    return { url: audioUrl };
                }
                
                // ÂÖ∂‰ªñËØ∑Ê±ÇËøîÂõûJSON
                const data = await response.json();
                if (debugConsole) debugConsole.api('TuneHub APIËØ∑Ê±Ç', `ËØ∑Ê±ÇÊàêÂäüÔºåËøîÂõûÊï∞ÊçÆ`);
                return data;
            } catch (error) {
                const errorMsg = `TuneHub APIËØ∑Ê±ÇÂºÇÂ∏∏: ${error.message}\nÈîôËØØÂ†ÜÊ†à: ${error.stack}`;
                if (debugConsole) debugConsole.error('TuneHub APIËØ∑Ê±Ç', errorMsg);
                return null;
            }
        }

        // ÂéüAPIËØ∑Ê±ÇÂáΩÊï∞
        async function gdstudioRequest(params) {
            try {
                const apiConfig = API_CONFIG.gdstudio;
                const queryString = new URLSearchParams(params).toString();
                const url = `${apiConfig.baseUrl}?${queryString}`;
                
                if (debugConsole) debugConsole.api('ÂéüAPIËØ∑Ê±Ç', `ÂèëÈÄÅËØ∑Ê±Ç: ${url}`);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    const errorMsg = `HTTPËØ∑Ê±ÇÂ§±Ë¥•: Áä∂ÊÄÅÁ†Å ${response.status} ${response.statusText}`;
                    if (debugConsole) debugConsole.error('ÂéüAPIËØ∑Ê±Ç', errorMsg);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                let data;
                try {
                    // Ê†πÊçÆÂìçÂ∫îÁöÑContent-TypeÂÜ≥ÂÆöËß£ÊûêÊñπÂºè„ÄÇÈÉ®ÂàÜËØ∑Ê±ÇÔºàÂ¶Çtypes=urlÔºâÂèØËÉΩËøîÂõûÁ∫ØÊñáÊú¨ÔºåËÄåÈùûJSON
                    const contentType = response.headers.get('Content-Type') || '';
                    if (contentType.includes('application/json')) {
                        data = await response.json();
                    } else {
                        const text = await response.text();
                        // Â¶ÇÊûúËØ∑Ê±ÇÁöÑÊòØÈü≥È¢ëURLÔºåÂàôÁõ¥Êé•ÂåÖË£ÖÊàêÂØπË±°
                        if (params.types === 'url') {
                            data = { url: text };
                        } else {
                            // Â∞ùËØïËß£Êûê‰∏∫JSONÔºåÂê¶ÂàôËøîÂõûÂ≠óÁ¨¶‰∏≤
                            try {
                                data = JSON.parse(text);
                            } catch {
                                data = text;
                            }
                        }
                    }
                } catch (parseErr) {
                    // Â¶ÇÊûúËß£ÊûêÈîôËØØÔºåÊäõÂá∫ÂºÇÂ∏∏‰ª•‰æøÂ§ñÂ±ÇÊçïËé∑
                    throw new Error('Ëß£ÊûêAPIÂìçÂ∫îÂ§±Ë¥•: ' + parseErr.message);
                }
                if (debugConsole) debugConsole.api('ÂéüAPIËØ∑Ê±Ç', `ËØ∑Ê±ÇÊàêÂäüÔºåËøîÂõûÊï∞ÊçÆ`);
                return data;
            } catch (error) {
                const errorMsg = `ÂéüAPIËØ∑Ê±ÇÂºÇÂ∏∏: ${error.message}\nÈîôËØØÂ†ÜÊ†à: ${error.stack}`;
                if (debugConsole) debugConsole.error('ÂéüAPIËØ∑Ê±Ç', errorMsg);
                return null;
            }
        }

        // Áªü‰∏ÄAPIËØ∑Ê±ÇÂáΩÊï∞
        async function apiRequest(params, apiType = null) {
            const api = apiType || apiSelect.value;
            
            if (!checkRateLimit()) {
                const errorMsg = 'APIËØ∑Ê±ÇÈ¢ëÁéáÈôêÂà∂Ôºö5ÂàÜÈíüÂÜÖÊúÄÂ§ö60Ê¨°ËØ∑Ê±ÇÔºåÂΩìÂâçÂ∑≤Ë∂ÖÈôê„ÄÇ';
                if (debugConsole) debugConsole.error('APIÈôêÂà∂', errorMsg);
                return null;
            }
            
            if (api === 'gdstudio') {
                return await gdstudioRequest(params);
            } else if (api === 'tunehub') {
                // Â∞ÜÂéüAPIÂèÇÊï∞ËΩ¨Êç¢‰∏∫TuneHubÂèÇÊï∞
                let tunehubParams = {};
                
                if (params.types === 'search') {
                    // Â§ÑÁêÜËÅöÂêàÊêúÁ¥¢
                    if (params.source === 'aggregate') {
                        tunehubParams = {
                            type: 'aggregateSearch',
                            keyword: params.name,
                            limit: params.count || 20
                        };
                    } else {
                        tunehubParams = {
                            source: params.source,
                            type: 'search',
                            keyword: params.name,
                            limit: params.count || 20,
                            page: params.pages || 1
                        };
                    }
                } else if (params.types === 'url') {
                    // Áõ¥Êé•‰ΩøÁî®Èü≥‰πê‰∏ãËΩΩ.html‰∏≠ÁöÑÊñπÂºè
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'url',
                        br: params.br // Áõ¥Êé•‰ΩøÁî®Èü≥Ë¥®ÂÄºÔºå‰∏çÊò†Â∞Ñ
                    };
                } else if (params.types === 'pic') {
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'pic'
                    };
                } else if (params.types === 'lyric') {
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'lrc'
                    };
                }
                
                return await tunehubRequest(tunehubParams);
            }
        }

        async function searchMusic(keyword, source = null) {
            if (!keyword.trim()) {
                const errorMsg = 'ÊêúÁ¥¢Â§±Ë¥•: ÊêúÁ¥¢ÂÖ≥ÈîÆËØç‰∏∫Á©∫ÔºåËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÊ≠åÊõ≤Âêç„ÄÅÊ≠åÊâãÂêçÊàñ‰∏ìËæëÂêçËøõË°åÊêúÁ¥¢„ÄÇ';
                if (debugConsole) debugConsole.error('ÊêúÁ¥¢', errorMsg);
                
                const d = document.createElement('div');
                d.className = 'error';
                d.textContent = 'ËØ∑ËæìÂÖ•ÊêúÁ¥¢ÂÖ≥ÈîÆËØç';
                resultsContainer.prepend(d);
                setTimeout(() => d.remove(), 4000);
                return;
            }
            
            const api = apiSelect.value;
            const selectedSource = source || sourceSelect.value;
            
            if (debugConsole) debugConsole.info('ÊêúÁ¥¢', `ÂºÄÂßãÊêúÁ¥¢: "${keyword}" (API: ${api}, Ê∫ê: ${selectedSource})`);
            resultsContainer.innerHTML = '<div class="loading">ÊêúÁ¥¢‰∏≠...</div>';
            
            let data;
            if (api === 'gdstudio') {
                // ÂéüAPIÊêúÁ¥¢
                data = await apiRequest({
                    types: 'search',
                    source: selectedSource,
                    name: keyword,
                    count: 20,
                    pages: 1
                });
            } else if (api === 'tunehub') {
                // TuneHub APIÊêúÁ¥¢
                data = await apiRequest({
                    types: 'search',
                    source: selectedSource,
                    name: keyword,
                    count: 20,
                    pages: 1
                });
            }
            
            if (data) {
                if (api === 'gdstudio' && Array.isArray(data) && data.length > 0) {
                    // ÂéüAPIÊêúÁ¥¢ÁªìÊûú - Ê∑ªÂä†Âπ≥Âè∞‰ø°ÊÅØ
                    searchResults = data.map(track => ({
                        ...track,
                        platform: selectedSource,
                        api: 'gdstudio'
                    }));
                    if (debugConsole) debugConsole.success('ÊêúÁ¥¢', `ÊêúÁ¥¢ÊàêÂäüÔºåÊâæÂà∞ ${data.length} ‰∏™ÁªìÊûú`);
                    displaySearchResults(searchResults, api);
                } else if (api === 'tunehub' && data.code === 200 && data.data) {
                    // TuneHubËøîÂõûÁöÑÊï∞ÊçÆÊ†ºÂºè
                    let tracks = [];
                    
                    if (selectedSource === 'aggregate') {
                        // ËÅöÂêàÊêúÁ¥¢ËøîÂõûÁöÑÊï∞ÊçÆÊ†ºÂºè
                        if (data.data.results && Array.isArray(data.data.results)) {
                            tracks = data.data.results.map(item => ({
                                id: item.id,
                                name: item.name,
                                artist: item.artist || 'Êú™Áü•Ëâ∫ÊúØÂÆ∂',
                                album: item.album || 'Êú™Áü•‰∏ìËæë',
                                pic_id: item.id,
                                pic_url: item.pic,
                                lyric_id: item.id,
                                source: item.platform,
                                platform: item.platform,
                                api: 'tunehub'
                            }));
                        }
                    } else {
                        // ÊôÆÈÄöÊêúÁ¥¢ËøîÂõûÁöÑÊï∞ÊçÆÊ†ºÂºè
                        if (data.data.results && Array.isArray(data.data.results)) {
                            tracks = data.data.results.map(item => ({
                                id: item.id,
                                name: item.name,
                                artist: item.artist || 'Êú™Áü•Ëâ∫ÊúØÂÆ∂',
                                album: item.album || 'Êú™Áü•‰∏ìËæë',
                                pic_id: item.id,
                                pic_url: item.pic,
                                lyric_id: item.id,
                                source: selectedSource,
                                platform: selectedSource,
                                api: 'tunehub'
                            }));
                        }
                    }
                    
                    if (tracks.length > 0) {
                        searchResults = tracks;
                        if (debugConsole) debugConsole.success('ÊêúÁ¥¢', `ÊêúÁ¥¢ÊàêÂäüÔºåÊâæÂà∞ ${tracks.length} ‰∏™ÁªìÊûú`);
                        displaySearchResults(tracks, api);
                    } else {
                        if (debugConsole) debugConsole.warn('ÊêúÁ¥¢', `Êú™ÊâæÂà∞Áõ∏ÂÖ≥ÁªìÊûúÔºåÂÖ≥ÈîÆËØç: "${keyword}"ÔºåAPI: ${api}ÔºåÊ∫ê: ${selectedSource}`);
                        resultsContainer.innerHTML = '<div class="loading">Êú™ÊâæÂà∞ÁªìÊûú</div>';
                    }
                } else {
                    if (debugConsole) debugConsole.warn('ÊêúÁ¥¢', `Êú™ÊâæÂà∞Áõ∏ÂÖ≥ÁªìÊûúÔºåÂÖ≥ÈîÆËØç: "${keyword}"ÔºåAPI: ${api}ÔºåÊ∫ê: ${selectedSource}`);
                    resultsContainer.innerHTML = '<div class="loading">Êú™ÊâæÂà∞ÁªìÊûú</div>';
                }
            } else {
                if (debugConsole) debugConsole.warn('ÊêúÁ¥¢', `APIËøîÂõûÁ©∫Êï∞ÊçÆÔºåÂÖ≥ÈîÆËØç: "${keyword}"ÔºåAPI: ${api}ÔºåÊ∫ê: ${selectedSource}`);
                resultsContainer.innerHTML = '<div class="loading">Êú™ÊâæÂà∞ÁªìÊûú</div>';
            }
        }

        // ---------- ÊêúÁ¥¢ÁªìÊûúÊòæÁ§∫ ----------
        function displaySearchResults(results, api) {
            resultsContainer.innerHTML = '';
            
            if (results.length === 0) {
                resultsContainer.innerHTML = '<div class="loading">Êú™ÊâæÂà∞ÁªìÊûú</div>';
                return;
            }
            
            results.forEach((track) => {
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                if (currentTrack && currentTrack.id === track.id && currentTrack.api === track.api) {
                    resultItem.classList.add('active');
                }
                
                // Ê†πÊçÆAPIÊûÑÂª∫‰∏ìËæëÂ∞ÅÈù¢URL
                let albumArtUrl;
                if (api === 'gdstudio') {
                    albumArtUrl = track.pic_id ? 
                        `https://music-api.gdstudio.xyz/api.php?types=pic&source=${track.source}&id=${track.pic_id}&size=150` : 
                        'https://placehold.co/50x50/333333/ffffff?text=‚ô™';
                } else if (api === 'tunehub') {
                    // TuneHub: ‰ºòÂÖà‰ΩøÁî® pic_urlÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÊ†πÊçÆ pic_id ÊûÑÂª∫
                    if (track.pic_url) {
                        albumArtUrl = track.pic_url;
                    } else if (track.pic_id) {
                        // ‰ΩøÁî® music-dl.sayqz.com API ÊûÑÂª∫Â∞ÅÈù¢Âú∞ÂùÄ
                        albumArtUrl = `https://music-dl.sayqz.com/api/?type=pic&source=${track.source}&id=${track.pic_id}`;
                    } else {
                        albumArtUrl = 'https://placehold.co/50x50/333333/ffffff?text=‚ô™';
                    }
                }

                // Ëé∑ÂèñÂπ≥Âè∞ÊòæÁ§∫ÂêçÁß∞
                let platformName = '';
                let platformClass = '';
                if (track.platform) {
                    platformName = track.platform.toUpperCase();
                    platformClass = track.platform;
                }

                resultItem.innerHTML = `
                    <img src="${albumArtUrl}" class="result-album" onerror="this.src='https://placehold.co/50x50/333333/ffffff?text=‚ô™'">
                    <div class="result-info">
                        <div class="result-title">${track.name || 'Êú™Áü•Ê≠åÊõ≤'}</div>
                        <div class="result-artist">${track.artist || 'Êú™Áü•Ëâ∫ÊúØÂÆ∂'}</div>
                        <div class="result-album-name">${track.album || 'Êú™Áü•‰∏ìËæë'}</div>
                        <div class="result-platform-info">
                            <span class="platform-badge ${platformClass}">${platformName}</span>
                            <span class="api-select-label">${track.api === 'tunehub' ? 'Â§áÁî®API' : 'ÂéüAPI'}</span>
                        </div>
                    </div>
                `;
                
                resultItem.__trackData = track;
                resultItem.addEventListener('click', () => {
                    if (debugConsole) debugConsole.info('Êí≠ÊîæÊéßÂà∂', `ÁÇπÂáªÊí≠ÊîæÊ≠åÊõ≤: ${track.name} - ${track.artist} (API: ${track.api || api}, Âπ≥Âè∞: ${track.platform})`);
                    playTrack(track);
                    document.querySelectorAll('.result-item').forEach(item => item.classList.remove('active'));
                    resultItem.classList.add('active');
                });
                
                resultsContainer.appendChild(resultItem);
            });
            
            if (debugConsole) debugConsole.success('ÊêúÁ¥¢ÁªìÊûú', `ÊàêÂäüÊ∏≤Êüì ${results.length} ‰∏™ÊêúÁ¥¢ÁªìÊûú`);
        }

        async function playTrack(track) {
            try {
                currentTrack = track;
                
                if (debugConsole) debugConsole.info('Êí≠ÊîæÊéßÂà∂', `ÂºÄÂßãÊí≠ÊîæÊ≠åÊõ≤: ${track.name} - ${track.artist} (ID: ${track.id}, API: ${track.api || apiSelect.value}, Âπ≥Âè∞: ${track.platform})`);
                
                songTitle.textContent = track.name || 'Êú™Áü•Ê≠åÊõ≤';
                songArtist.textContent = `${track.artist || 'Êú™Áü•Ëâ∫ÊúØÂÆ∂'}`;
                fullscreenSongTitle.textContent = track.name || 'Êú™Áü•Ê≠åÊõ≤';
                fullscreenSongArtist.textContent = track.artist || 'Êú™Áü•Ëâ∫ÊúØÂÆ∂';
                
                albumArt.style.display = 'none';
                albumArtPlaceholder.style.display = 'flex';
                
                // Êõ¥Êñ∞ active Áä∂ÊÄÅ
                document.querySelectorAll('.result-item').forEach(item => {
                    if(item.__trackData && item.__trackData.id === track.id && item.__trackData.api === track.api) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
                
                lyricsContent.innerHTML = '<div class="loading">Âä†ËΩΩ‰∏≠...</div>';
                fullscreenLyricsLines.innerHTML = '<div class="loading">Âä†ËΩΩ‰∏≠...</div>';
                userScrolledLyrics = false;
                
                // Ê†πÊçÆtrackÁöÑAPIËé∑ÂèñÈü≥È¢ëURL
                const quality = qualitySelect.value;
                const apiToUse = track.api || apiSelect.value;
                
                if (debugConsole) debugConsole.info('Êí≠ÊîæÊéßÂà∂', `ËØ∑Ê±ÇÈü≥È¢ëURLÔºåÈü≥Ë¥®: ${quality}, API: ${apiToUse}, Âπ≥Âè∞: ${track.platform}`);
                
                let urlData;
                // Áªü‰∏Ä‰ΩøÁî® apiRequest Ëé∑ÂèñÈü≥È¢ëÈìæÊé•„ÄÇÊ†πÊçÆÂΩìÂâçtrack.apiÊàñÈÄâ‰∏≠ÁöÑAPIÁ°ÆÂÆöË∞ÉÁî®Êù•Ê∫ê„ÄÇ
                // ÂØπ‰∫é TuneHubÔºåËøô‰ºöÈÄöËøá tunehubRequest ÊãâÂèñÁúüÂÆûÈü≥È¢ëÈìæÊé•ÔºàÊàñÁõ¥Êé•ËøîÂõûÈü≥È¢ëÂú∞ÂùÄÔºâÔºõ
                // ÂØπ‰∫é GDStudioÔºåÂàôÈÄöËøá gdstudioRequest Ëé∑ÂèñÈìæÊé•„ÄÇ
                urlData = await apiRequest({
                    types: 'url',
                    source: track.platform || track.source || sourceSelect.value,
                    id: track.id,
                    br: quality
                }, apiToUse);
                
                if (urlData && urlData.url) {
                    if (debugConsole) debugConsole.success('Êí≠ÊîæÊéßÂà∂', `ÊàêÂäüËé∑ÂèñÈü≥È¢ëURL: ${urlData.url.substring(0, 100)}...`);
                    
                    audioPlayer.src = urlData.url;
                    audioPlayer.play()
                        .then(() => {
                            playBtn.innerHTML = '‚è∏';
                            fullscreenPlayBtn.innerHTML = '‚è∏';
                            updateMediaSession(track);
                            if (debugConsole) debugConsole.success('Êí≠ÊîæÊéßÂà∂', 'Èü≥È¢ëÊí≠ÊîæÂºÄÂßã');
                        })
                        .catch(e => {
                            const errorMsg = `Èü≥È¢ëÊí≠ÊîæÂ§±Ë¥•: ${e.message}\nÈîôËØØÂêçÁß∞: ${e.name}\nÈîôËØØÂ†ÜÊ†à: ${e.stack}`;
                            if (debugConsole) debugConsole.error('Êí≠ÊîæÊéßÂà∂', errorMsg);
                        });
                    
                    // Âä†ËΩΩ‰∏ìËæëÂ∞ÅÈù¢
                    if (track.pic_url) {
                        // Áõ¥Êé•‰ΩøÁî®ÊêúÁ¥¢Êó∂ÂæóÂà∞ÁöÑÂõæÁâáURL
                        if (debugConsole) debugConsole.info('‰∏ìËæëÂ∞ÅÈù¢', `‰ΩøÁî®ÊêúÁ¥¢ÁªìÊûú‰∏≠ÁöÑ‰∏ìËæëÂ∞ÅÈù¢URL: ${track.pic_url}`);
                        currentAlbumUrl = track.pic_url;
                        albumArt.src = track.pic_url;
                        albumArt.style.display = 'block';
                        albumArtPlaceholder.style.display = 'none';
                        fullscreenAlbumArt.src = track.pic_url;
                        
                        // ‰ΩøÁî®È¢úËâ≤ÈáèÂåñÁÆóÊ≥ïÊèêÂèñ‰∏ªË¶ÅÈ¢úËâ≤Âπ∂Êõ¥Êñ∞ËÉåÊôØ
                        updateGradientFromAlbum(track.pic_url);
                    } else if (track.pic_id) {
                        if (debugConsole) debugConsole.info('‰∏ìËæëÂ∞ÅÈù¢', `ÂºÄÂßãÂä†ËΩΩ‰∏ìËæëÂ∞ÅÈù¢ÔºåÂõæÁâáID: ${track.pic_id}, API: ${apiToUse}`);
                        loadAlbumCover(track, apiToUse);
                    }
                    
                    // Âä†ËΩΩÊ≠åËØç
                    if (track.lyric_id || track.id) {
                        const lyricId = track.lyric_id || track.id;
                        if (debugConsole) debugConsole.info('Ê≠åËØç', `ÂºÄÂßãÂä†ËΩΩÊ≠åËØçÔºåÊ≠åËØçID: ${lyricId}, API: ${apiToUse}`);
                        loadLyrics(track, apiToUse);
                    }
                } else {
                    const errorMsg = `Êó†Ê≥ïÊí≠ÊîæÊ≠§Ê≠åÊõ≤ÔºåÂèØËÉΩÊ≤°ÊúâÂØπÂ∫îÁöÑÈü≥Ë¥®ÊàñÈìæÊé•Â§±Êïà„ÄÇ\nÊ≠åÊõ≤ID: ${track.id}\nÈü≥Ë¥®: ${quality}\nAPI: ${apiToUse}\nÂπ≥Âè∞: ${track.platform}`;
                    if (debugConsole) debugConsole.error('Êí≠ÊîæÊéßÂà∂', errorMsg);
                }
            } catch (error) {
                const errorMsg = `Êí≠ÊîæÊ≠åÊõ≤ËøáÁ®ã‰∏≠Âá∫Áé∞ÂºÇÂ∏∏: ${error.message}\nÈîôËØØÂ†ÜÊ†à: ${error.stack}`;
                if (debugConsole) debugConsole.error('Êí≠ÊîæÊéßÂà∂', errorMsg);
            }
        }

        // ---------- ÊµèËßàÂô®/iOSÈîÅÂ±è‰∏ìËæëÂ∞ÅÈù¢ÈÉ®ÂàÜ ----------
        function updateMediaSession(track) {
            if ('mediaSession' in navigator) {
                try {
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: track.name || 'Êú™Áü•Ê≠åÊõ≤',
                        artist: track.artist || 'Êú™Áü•Ëâ∫ÊúØÂÆ∂',
                        album: track.album || 'Êú™Áü•‰∏ìËæë',
                        artwork: currentAlbumUrl ? [
                            { src: currentAlbumUrl, sizes: '256x256', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '384x384', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '512x512', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '768x768', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '1024x1024', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '1536x1536', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '2048x2048', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '3000x3000', type: 'image/jpeg' }
                        ] : []
                    });
                    
                    navigator.mediaSession.setActionHandler('play', () => {
                        audioPlayer.play();
                        playBtn.innerHTML = '‚è∏';
                        fullscreenPlayBtn.innerHTML = '‚è∏';
                    });
                    
                    navigator.mediaSession.setActionHandler('pause', () => {
                        audioPlayer.pause();
                        playBtn.innerHTML = '‚ñ∂';
                        fullscreenPlayBtn.innerHTML = '‚ñ∂';
                    });
                    
                    navigator.mediaSession.setActionHandler('previoustrack', () => {
                        prevBtn.click();
                    });
                    
                    navigator.mediaSession.setActionHandler('nexttrack', () => {
                        nextBtn.click();
                    });
                    
                    if (debugConsole) debugConsole.success('Â™í‰Ωì‰ºöËØù', 'ÊµèËßàÂô®/iOSÈîÅÂ±èÂ™í‰Ωì‰ºöËØùÂ∑≤Êõ¥Êñ∞');
                } catch (error) {
                    if (debugConsole) debugConsole.error('Â™í‰Ωì‰ºöËØù', `Êõ¥Êñ∞Â™í‰Ωì‰ºöËØùÂ§±Ë¥•: ${error.message}`);
                }
            }
        }

        async function loadAlbumCover(track, api) {
            if (!track.pic_id) {
                if (debugConsole) debugConsole.warn('‰∏ìËæëÂ∞ÅÈù¢', 'Êó†‰∏ìËæëÂ∞ÅÈù¢IDÔºåË∑≥ËøáÂ∞ÅÈù¢Âä†ËΩΩ');
                return;
            }
            
            if (debugConsole) debugConsole.info('‰∏ìËæëÂ∞ÅÈù¢', `ËØ∑Ê±Ç‰∏ìËæëÂ∞ÅÈù¢ÔºåÂõæÁâáID: ${track.pic_id}, API: ${api}`);
            
            let picData;
            if (api === 'tunehub') {
                // TuneHub API - Áõ¥Êé•ÊûÑÂª∫URL
                const apiConfig = API_CONFIG.tunehub;
                const url = new URL(apiConfig.baseUrl);
                url.searchParams.append('source', track.platform || track.source || sourceSelect.value);
                url.searchParams.append('id', track.pic_id);
                url.searchParams.append('type', 'pic');
                
                picData = { url: url.toString() };
            } else {
                // ÂéüAPI
                let sizeParam = '3000';
                if (track.platform === 'joox' || track.source === 'joox') {
                    sizeParam = '';
                    if (debugConsole) debugConsole.info('‰∏ìËæëÂ∞ÅÈù¢', 'JOOXÈü≥‰πêÊ∫êÔºå‰ΩøÁî®ÂéüÂßãÂ∞∫ÂØ∏');
                }
                
                picData = await apiRequest({
                    types: 'pic',
                    source: track.platform || track.source || sourceSelect.value,
                    id: track.pic_id,
                    size: sizeParam
                });
            }
            
            if (picData && picData.url) {
                currentAlbumUrl = picData.url;
                if (debugConsole) debugConsole.success('‰∏ìËæëÂ∞ÅÈù¢', `ÊàêÂäüÂä†ËΩΩ‰∏ìËæëÂ∞ÅÈù¢: ${picData.url}`);
                
                albumArt.src = picData.url;
                albumArt.style.display = 'block';
                albumArtPlaceholder.style.display = 'none';
                fullscreenAlbumArt.src = picData.url;
                
                // ‰ΩøÁî®È¢úËâ≤ÈáèÂåñÁÆóÊ≥ïÊèêÂèñ‰∏ªË¶ÅÈ¢úËâ≤Âπ∂Êõ¥Êñ∞ËÉåÊôØ
                updateGradientFromAlbum(picData.url);
                
                // Êõ¥Êñ∞mediaSessionÁöÑartwork
                if ('mediaSession' in navigator && navigator.mediaSession.metadata) {
                    try {
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: navigator.mediaSession.metadata.title,
                            artist: navigator.mediaSession.metadata.artist,
                            album: navigator.mediaSession.metadata.album,
                            artwork: [
                                { src: picData.url, sizes: '256x256', type: 'image/jpeg' },
                                { src: picData.url, sizes: '384x384', type: 'image/jpeg' },
                                { src: picData.url, sizes: '512x512', type: 'image/jpeg' },
                                { src: picData.url, sizes: '768x768', type: 'image/jpeg' },
                                { src: picData.url, sizes: '1024x1024', type: 'image/jpeg' },
                                { src: picData.url, sizes: '1536x1536', type: 'image/jpeg' },
                                { src: picData.url, sizes: '2048x2048', type: 'image/jpeg' },
                                { src: picData.url, sizes: '3000x3000', type: 'image/jpeg' }
                            ]
                        });
                        if (debugConsole) debugConsole.info('Â™í‰Ωì‰ºöËØù', '‰∏ìËæëÂ∞ÅÈù¢Â∑≤Êõ¥Êñ∞Âà∞Â™í‰Ωì‰ºöËØù');
                    } catch (error) {
                        if (debugConsole) debugConsole.error('Â™í‰Ωì‰ºöËØù', `Êõ¥Êñ∞‰∏ìËæëÂ∞ÅÈù¢Âà∞Â™í‰Ωì‰ºöËØùÂ§±Ë¥•: ${error.message}`);
                    }
                }
                
                albumArt.onerror = () => {
                    const errorMsg = `‰∏ìËæëÂ∞ÅÈù¢ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•: ${picData.url}`;
                    if (debugConsole) debugConsole.error('‰∏ìËæëÂ∞ÅÈù¢', errorMsg);
                    albumArt.style.display = 'none';
                    albumArtPlaceholder.style.display = 'flex';
                };
            } else {
                if (debugConsole) debugConsole.error('‰∏ìËæëÂ∞ÅÈù¢', `Êó†Ê≥ïËé∑Âèñ‰∏ìËæëÂ∞ÅÈù¢Êï∞ÊçÆÔºåÂõæÁâáID: ${track.pic_id}`);
            }
        }

        // ---------- Ê≠åËØçËß£Êûê ----------
        function parseLRC(lrcText) {
            const lines = [];
            if (!lrcText) return lines;
            
            const lrcLines = lrcText.split('\n');
            
            lrcLines.forEach(line => {
                const timeMatch = line.match(/\[(\d+):(\d+)\.(\d+)\]/);
                if (timeMatch) {
                    const min = parseInt(timeMatch[1]);
                    const sec = parseInt(timeMatch[2]);
                    const ms = parseInt(timeMatch[3]) * 10;
                    let text = line.replace(/\[.*?\]/g, '').trim();

                    let words = [];
                    const wordMatch = text.matchAll(/\(([^)]+?)<(\d+:\d+:\d+)>\)/g);
                    let hasWordTiming = false;

                    for (const match of wordMatch) {
                        const wordText = match[1];
                        const wordTimeStr = match[2].split(':');
                        const wordTime = parseInt(wordTimeStr[0])*60 + parseInt(wordTimeStr[1]) + parseInt(wordTimeStr[2])/1000;
                        words.push({ text: wordText, time: wordTime });
                        hasWordTiming = true;
                    }

                    if (hasWordTiming) {
                         text = words.map(w => w.text).join('');
                    }

                    if (text) {
                        lines.push({
                            time: min * 60 + sec + ms/1000,
                            text: text,
                            words: hasWordTiming ? words : null
                        });
                    }
                }
            });
            return lines;
        }

        async function loadLyrics(track, api) {
            try {
                const lyricId = track.lyric_id || track.id;
                
                if (debugConsole) debugConsole.info('Ê≠åËØç', `ÂºÄÂßãËØ∑Ê±ÇÊ≠åËØçÊï∞ÊçÆÔºåÊ≠åËØçID: ${lyricId}, API: ${api}`);
                
                let lyricData;
                if (api === 'tunehub') {
                    // TuneHub API - Áõ¥Êé•ÊûÑÂª∫URL
                    const apiConfig = API_CONFIG.tunehub;
                    const url = new URL(apiConfig.baseUrl);
                    url.searchParams.append('source', track.platform || track.source || sourceSelect.value);
                    url.searchParams.append('id', lyricId);
                    url.searchParams.append('type', 'lrc');
                    
                    const response = await fetch(url.toString());
                    if (response.ok) {
                        const text = await response.text();
                        lyricData = { lyric: text };
                    }
                } else {
                    // ÂéüAPI
                    lyricData = await apiRequest({
                        types: 'lyric',
                        source: track.platform || track.source || sourceSelect.value,
                        id: lyricId
                    });
                }
                
                mergedLyricsData = null;
                
                if (!lyricData || (!lyricData.lyric && !lyricData.tlyric)) {
                    if (debugConsole) debugConsole.warn('Ê≠åËØç', `Êú™ÊâæÂà∞Ê≠åËØçÊï∞ÊçÆÔºåÊ≠åËØçID: ${lyricId}`);
                    const noLyric = '<div class="loading">ÊöÇÊó†Ê≠åËØç</div>';
                    lyricsContent.innerHTML = noLyric;
                    fullscreenLyricsLines.innerHTML = noLyric;
                    return;
                }
                
                if (debugConsole) debugConsole.info('Ê≠åËØç', `ÊàêÂäüËé∑ÂèñÊ≠åËØçÊï∞ÊçÆÔºåÂéüÂßãÊ≠åËØçÈïøÂ∫¶: ${lyricData.lyric ? lyricData.lyric.length : 0}ÔºåÁøªËØëÊ≠åËØçÈïøÂ∫¶: ${lyricData.tlyric ? lyricData.tlyric.length : 0}`);
                
                const originalLines = parseLRC(lyricData.lyric);
                const translationLines = parseLRC(lyricData.tlyric);
                
                // ÂêàÂπ∂Âπ∂ÊéíÂ∫èÊ≠åËØç
                const combinedLines = originalLines.map(o => {
                    const t = translationLines.find(t => t.time === o.time);
                    return {
                        time: o.time,
                        original: o.text,
                        translation: t ? t.text : null,
                        words: o.words
                    };
                }).sort((a, b) => a.time - b.time);

                mergedLyricsData = combinedLines;
                if (debugConsole) debugConsole.success('Ê≠åËØç', `Ê≠åËØçËß£ÊûêÂÆåÊàêÔºåÂÖ± ${combinedLines.length} Ë°åÊ≠åËØç`);
                displayMergedLyrics(combinedLines);
            } catch (error) {
                const errorMsg = `Ê≠åËØçÂä†ËΩΩÂ§±Ë¥•: ${error.message}\nÊ≠åËØçID: ${track.lyric_id || track.id}\nÈîôËØØÂ†ÜÊ†à: ${error.stack}`;
                if (debugConsole) debugConsole.error('Ê≠åËØç', errorMsg);
            }
        }

        function displayMergedLyrics(lines) {
            try {
                lyricsContent.innerHTML = '';
                fullscreenLyricsLines.innerHTML = '';
                
                if (lines.length === 0) {
                    if (debugConsole) debugConsole.warn('Ê≠åËØç', 'Ê≠åËØçÊï∞ÊçÆ‰∏∫Á©∫ÔºåÊó†Ê≠åËØçÂèØÊòæÁ§∫');
                    const noLyric = '<div class="loading">ÊöÇÊó†Ê≠åËØç</div>';
                    lyricsContent.innerHTML = noLyric;
                    fullscreenLyricsLines.innerHTML = noLyric;
                    return;
                }

                const fragMini = document.createDocumentFragment();
                const fragFull = document.createDocumentFragment();
                
                lines.forEach(l => {
                    const createLineHtml = (text, isOriginal = true, isFullscreen = false) => {
                        if (l.words && isOriginal) {
                            return l.words.map(w => 
                                `<span class="word-highlight" data-word-time="${w.time}">${w.text}</span>`
                            ).join('');
                        }
                        return text;
                    };

                    // Mini Player Rendering
                    const div = document.createElement('div');
                    div.className = 'lyric-line';
                    div.dataset.time = l.time;
                    div.innerHTML = `
                        <span class="original-text">${createLineHtml(l.original, true, false)}</span>
                        ${l.translation ? `<span class="translation-text">${l.translation}</span>` : ''}
                    `;
                    div.onclick = () => {
                        audioPlayer.currentTime = l.time;
                        userScrolledLyrics = false; // ÁÇπÂáªÊ≠åËØçÂêéÈáçÁΩÆÊªöÂä®Áä∂ÊÄÅ
                        if (debugConsole) debugConsole.info('Ê≠åËØç', `ÁÇπÂáªÊ≠åËØçË∑≥ËΩ¨Âà∞: ${l.time} Áßí`);
                    };
                    fragMini.appendChild(div);
                    
                    // Fullscreen Player Rendering
                    const divFull = document.createElement('div');
                    divFull.className = 'fullscreen-lyric-line';
                    divFull.dataset.time = l.time;
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'fullscreen-line-wrapper';
                    
                    const original = document.createElement('span');
                    original.className = 'fullscreen-original-text';
                    original.innerHTML = createLineHtml(l.original, true, true);
                    wrapper.appendChild(original);

                    if (l.translation) {
                        const translation = document.createElement('span');
                        translation.className = 'fullscreen-translation-text';
                        translation.textContent = l.translation;
                        wrapper.appendChild(translation);
                    }

                    divFull.appendChild(wrapper);
                    divFull.onclick = () => {
                        audioPlayer.currentTime = l.time;
                        userScrolledLyrics = false;
                    };
                    fragFull.appendChild(divFull);
                });
                
                lyricsContent.appendChild(fragMini);
                fullscreenLyricsLines.appendChild(fragFull);
                
                if (debugConsole) debugConsole.success('Ê≠åËØçÊ∏≤Êüì', `ÊàêÂäüÊ∏≤Êüì ${lines.length} Ë°åÊ≠åËØç`);
            } catch (error) {
                const errorMsg = `Ê≠åËØçÊ∏≤ÊüìÂ§±Ë¥•: ${error.message}\nÈîôËØØÂ†ÜÊ†à: ${error.stack}`;
                if (debugConsole) debugConsole.error('Ê≠åËØçÊ∏≤Êüì', errorMsg);
            }
        }

        function highlightCurrentLyric(time) {
            if (!mergedLyricsData) return;
            
            let activeIdx = -1;
            for(let i=0; i<mergedLyricsData.length; i++) {
                if(mergedLyricsData[i].time <= time + 0.2) activeIdx = i;
                else break;
            }
            
            if (activeIdx === -1) return;
            
            // --- Sync Mini Player ---
            const miniLines = lyricsContent.querySelectorAll('.lyric-line');
            miniLines.forEach(l => l.classList.remove('active'));
            if(miniLines[activeIdx]) {
                miniLines[activeIdx].classList.add('active');
                // Âè™Âú®Áî®Êà∑Ê≤°ÊúâÊªöÂä®Êó∂ÊâçËá™Âä®ÊªöÂä®
                if(!userScrolledLyrics) {
                    miniLines[activeIdx].scrollIntoView({behavior: 'smooth', block: 'center'});
                }
            }
            
            // --- Sync Fullscreen Player ---
            const fullLines = fullscreenLyricsLines.querySelectorAll('.fullscreen-lyric-line');
            fullLines.forEach(l => l.classList.remove('active'));
            if(fullLines[activeIdx]) {
                fullLines[activeIdx].classList.add('active');
                fullLines[activeIdx].scrollIntoView({behavior: 'smooth', block: 'center'});
            }
            
            // ÈÄêËØçÈ´ò‰∫ÆÈÄªËæë
            if (mergedLyricsData[activeIdx] && mergedLyricsData[activeIdx].words) {
                 const currentLineWords = (miniLines[activeIdx] || fullLines[activeIdx]).querySelectorAll('.word-highlight');
                 
                 currentLineWords.forEach(wordSpan => {
                     const wordTime = parseFloat(wordSpan.dataset.word-time);
                     if (wordTime <= time) {
                         wordSpan.style.color = '#ffcc00'; 
                     } else {
                         wordSpan.style.color = 'inherit'; 
                     }
                 });
            }
        }

        function formatTime(s) {
            if(isNaN(s) || s < 0) return '0:00';
            const m = Math.floor(s/60);
            const se = Math.floor(s%60);
            return `${m}:${se<10?'0':''}${se}`;
        }

        // --- Event Listeners ---
        
        searchBtn.onclick = () => {
            if (debugConsole) debugConsole.info('ÊêúÁ¥¢', `ÊâãÂä®Ëß¶ÂèëÊêúÁ¥¢: "${searchInput.value}" (API: ${apiSelect.value}, Ê∫ê: ${sourceSelect.value})`);
            searchMusic(searchInput.value, sourceSelect.value);
        };
        
        searchInput.onkeypress = (e) => {
            if (e.key === 'Enter') {
                if (debugConsole) debugConsole.info('ÊêúÁ¥¢', `ÂõûËΩ¶ÈîÆËß¶ÂèëÊêúÁ¥¢: "${searchInput.value}"`);
                searchBtn.click();
            }
        };
        
        // Êí≠ÊîæÊéßÂà∂
        const togglePlay = () => {
            if(audioPlayer.paused) {
                if(audioPlayer.src) {
                    if (debugConsole) debugConsole.info('Êí≠ÊîæÊéßÂà∂', 'ÁÇπÂáªÊí≠ÊîæÊåâÈíÆÔºåÂºÄÂßãÊí≠Êîæ');
                    audioPlayer.play();
                } else {
                    if (debugConsole) debugConsole.warn('Êí≠ÊîæÊéßÂà∂', 'ÁÇπÂáªÊí≠ÊîæÊåâÈíÆÔºå‰ΩÜÊó†Èü≥È¢ëÊ∫êÂèØÊí≠Êîæ');
                }
            } else {
                if (debugConsole) debugConsole.info('Êí≠ÊîæÊéßÂà∂', 'ÁÇπÂáªÊöÇÂÅúÊåâÈíÆÔºåÊöÇÂÅúÊí≠Êîæ');
                audioPlayer.pause();
            }
        };
        
        playBtn.onclick = togglePlay;
        fullscreenPlayBtn.onclick = togglePlay;
        
        audioPlayer.onplay = () => {
            playBtn.innerHTML = '‚è∏';
            fullscreenPlayBtn.innerHTML = '‚è∏';
            if (debugConsole) debugConsole.info('Êí≠ÊîæÁä∂ÊÄÅ', 'Èü≥È¢ëÂºÄÂßãÊí≠Êîæ');
        };
        
        audioPlayer.onpause = () => {
            playBtn.innerHTML = '‚ñ∂';
            fullscreenPlayBtn.innerHTML = '‚ñ∂';
            if (debugConsole) debugConsole.info('Êí≠ÊîæÁä∂ÊÄÅ', 'Èü≥È¢ëÊöÇÂÅúÊí≠Êîæ');
        };
        
        prevBtn.onclick = fullscreenPrevBtn.onclick = () => {
            if (debugConsole) debugConsole.info('Êí≠ÊîæÊéßÂà∂', 'ÁÇπÂáª‰∏ä‰∏ÄÊõ≤ÊåâÈíÆ');
            if(currentTrack && searchResults.length) {
                const idx = searchResults.findIndex(t => t.id === currentTrack.id && t.api === currentTrack.api);
                const prevIdx = (idx - 1 + searchResults.length) % searchResults.length;
                const prev = searchResults[prevIdx];
                playTrack(prev);
            } else {
                if (debugConsole) debugConsole.warn('Êí≠ÊîæÊéßÂà∂', 'Êó†Ê≥ïÂàáÊç¢Âà∞‰∏ä‰∏ÄÊõ≤ÔºöÂΩìÂâçÊó†Ê≠åÊõ≤ÊàñÊêúÁ¥¢ÁªìÊûú');
            }
        };
        
        nextBtn.onclick = fullscreenNextBtn.onclick = () => {
            if (debugConsole) debugConsole.info('Êí≠ÊîæÊéßÂà∂', 'ÁÇπÂáª‰∏ã‰∏ÄÊõ≤ÊåâÈíÆ');
            if(currentTrack && searchResults.length) {
                const idx = searchResults.findIndex(t => t.id === currentTrack.id && t.api === currentTrack.api);
                const nextIdx = (idx + 1) % searchResults.length;
                const next = searchResults[nextIdx];
                playTrack(next);
            } else {
                if (debugConsole) debugConsole.warn('Êí≠ÊîæÊéßÂà∂', 'Êó†Ê≥ïÂàáÊç¢Âà∞‰∏ã‰∏ÄÊõ≤ÔºöÂΩìÂâçÊó†Ê≠åÊõ≤ÊàñÊêúÁ¥¢ÁªìÊûú');
            }
        };

        // UI Toggles
        fullscreenLyricsBtn.onclick = () => {
            if (debugConsole) debugConsole.info('ÁïåÈù¢', 'ÊâìÂºÄÂÖ®Â±èÊ≠åËØçÊ®°Âºè');
            fullscreenLyricsOverlay.classList.add('active');
        };
        
        closeFullscreenBtn.onclick = () => {
            if (debugConsole) debugConsole.info('ÁïåÈù¢', 'ÂÖ≥Èó≠ÂÖ®Â±èÊ≠åËØçÊ®°Âºè');
            fullscreenLyricsOverlay.classList.remove('active');
        };
        
        // Progress Bars
        audioPlayer.ontimeupdate = () => {
            if(!audioPlayer.duration) return;
            const pct = (audioPlayer.currentTime/audioPlayer.duration)*100;
            progress.style.width = pct + '%';
            progressHandle.style.left = pct + '%';
            fullscreenProgress.style.width = pct + '%';
            currentTime.textContent = formatTime(audioPlayer.currentTime);
            highlightCurrentLyric(audioPlayer.currentTime);
        };
        
        audioPlayer.onloadedmetadata = () => {
            if (debugConsole) debugConsole.info('Èü≥È¢ë‰ø°ÊÅØ', `Èü≥È¢ëÂÖÉÊï∞ÊçÆÂä†ËΩΩÂÆåÊàêÔºåÊó∂Èïø: ${formatTime(audioPlayer.duration)}`);
            duration.textContent = formatTime(audioPlayer.duration);
        };
        
        audioPlayer.onended = () => {
            if (debugConsole) debugConsole.info('Êí≠ÊîæÁä∂ÊÄÅ', 'Èü≥È¢ëÊí≠ÊîæÁªìÊùüÔºåËá™Âä®Êí≠Êîæ‰∏ã‰∏ÄÊõ≤');
            nextBtn.click();
        };

        // Seek
        const seek = (e, bar) => {
            if(!audioPlayer.duration) return;
            const rect = bar.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : undefined);
            if (clientX === undefined) return;

            const p = Math.max(0, Math.min(1, (clientX - rect.left)/rect.width));
            const newTime = p * audioPlayer.duration;
            audioPlayer.currentTime = newTime;
            if (debugConsole) debugConsole.info('Êí≠ÊîæÊéßÂà∂', `Ë∑≥ËΩ¨Âà∞: ${formatTime(newTime)} (${p.toFixed(2) * 100}%)`);
        };

        // Mini player seek
        progressBar.onmousedown = (e) => { 
            isDragging = true; 
            if (debugConsole) debugConsole.info('Êí≠ÊîæÊéßÂà∂', 'ÂºÄÂßãÊãñÂä®ËøõÂ∫¶Êù°');
            seek(e, progressBar); 
        };
        
        progressBar.ontouchstart = (e) => { 
            isDragging = true; 
            if (debugConsole) debugConsole.info('Êí≠ÊîæÊéßÂà∂', 'Ëß¶Êë∏ÂºÄÂßãÊãñÂä®ËøõÂ∫¶Êù°');
            seek(e, progressBar); 
        };

        document.addEventListener('mousemove', (e) => { 
            if (isDragging) {
                seek(e, progressBar);
            }
        });
        
        document.addEventListener('touchmove', (e) => { 
            if (isDragging) {
                seek(e, progressBar);
            }
        });
        
        document.addEventListener('mouseup', () => { 
            if (isDragging) {
                if (debugConsole) debugConsole.info('Êí≠ÊîæÊéßÂà∂', 'ÁªìÊùüÊãñÂä®ËøõÂ∫¶Êù°');
                isDragging = false; 
            }
        });
        
        document.addEventListener('touchend', () => { 
            if (isDragging) {
                if (debugConsole) debugConsole.info('Êí≠ÊîæÊéßÂà∂', 'Ëß¶Êë∏ÁªìÊùüÊãñÂä®ËøõÂ∫¶Êù°');
                isDragging = false; 
            }
        });
        
        // Fullscreen seek
        fullscreenProgressBar.onclick = (e) => {
            if (debugConsole) debugConsole.info('Êí≠ÊîæÊéßÂà∂', 'ÁÇπÂáªÂÖ®Â±èËøõÂ∫¶Êù°');
            seek(e, fullscreenProgressBar);
        };
        
        fullscreenProgressBar.ontouchstart = (e) => {
            if (debugConsole) debugConsole.info('Êí≠ÊîæÊéßÂà∂', 'Ëß¶Êë∏ÂÖ®Â±èËøõÂ∫¶Êù°');
            seek(e, fullscreenProgressBar);
        };

        // Mesh Gradient Speed Control
        speedSlider.oninput = (e) => {
            ANIMATION_SPEED_MULTIPLIER = parseFloat(e.target.value);
            if (debugConsole) debugConsole.info('Ê∏êÂèòËÉåÊôØ', `Ê∏êÂèòÂä®ÁîªÈÄüÂ∫¶Ë∞ÉÊï¥‰∏∫: ${ANIMATION_SPEED_MULTIPLIER.toFixed(2)}x`);
        };

        // ‰øÆÂ§çÊ≠åËØçÊªöÂä® - ÁßªÈô§Ëá™Âä®ËøîÂõûÈÄªËæë
        lyricsContainer.addEventListener('wheel', (e) => {
            userScrolledLyrics = true;
            if (debugConsole) debugConsole.info('Ê≠åËØçÊªöÂä®', 'Áî®Êà∑ÊâãÂä®ÊªöÂä®Ê≠åËØçÔºåÁ¶ÅÁî®Ëá™Âä®ÊªöÂä®');
        });
        
        lyricsContainer.addEventListener('touchstart', () => {
            userScrolledLyrics = true;
            if (debugConsole) debugConsole.info('Ê≠åËØçÊªöÂä®', 'Áî®Êà∑Ëß¶Êë∏Ê≠åËØçÔºåÁ¶ÅÁî®Ëá™Âä®ÊªöÂä®');
        });

        // Resize
        window.onresize = () => {
            if (debugConsole) debugConsole.info('Á™óÂè£', 'Á™óÂè£Â§ßÂ∞èÊîπÂèòÔºåÈáçÊñ∞Ë∞ÉÊï¥Canvas');
            resizeCanvas();
        };
        
        // Init
        audioPlayer.volume = 0.7;
        
        // È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéÂàùÂßãÂåñÊâÄÊúâÁªÑ‰ª∂
        window.onload = () => {
            // ÂàùÂßãÂåñË∞ÉËØïÊéßÂà∂Âè∞
            initDebugConsole();
            
            // ÂêØÂä®Ê∏êÂèòÂä®Áîª
            startGradientAnimation();
            
            if (debugConsole) debugConsole.info('Á≥ªÁªü', 'È°µÈù¢Âä†ËΩΩÂÆåÊàêÔºåÂáÜÂ§áËá™Âä®ÊêúÁ¥¢ÊºîÁ§∫');
            
            // Âª∂ËøüÊâßË°åËá™Âä®ÊêúÁ¥¢ÔºåÁ°Æ‰øùÊâÄÊúâÁªÑ‰ª∂Â∑≤ÂàùÂßãÂåñ
            setTimeout(() => {
                if (debugConsole) debugConsole.info('ÊêúÁ¥¢', 'Ëá™Âä®ÊêúÁ¥¢ÊºîÁ§∫ÔºöÂë®Êù∞‰º¶ (ÂéüAPI - ÈÖ∑ÊàëÈü≥‰πê)');
                searchMusic('Âë®Êù∞‰º¶', 'kuwo');
            }, 800);
        };

        // ÈîôËØØÊçïËé∑
        window.onerror = function(message, source, lineno, colno, error) {
            const errorMsg = `ÂÖ®Â±ÄJavaScriptÈîôËØØ: ${message}\nÊù•Ê∫ê: ${source}\nË°åÂè∑: ${lineno}, ÂàóÂè∑: ${colno}\nÈîôËØØÂ†ÜÊ†à: ${error ? error.stack : 'Êó†Â†ÜÊ†à‰ø°ÊÅØ'}`;
            if (debugConsole) debugConsole.error('JavaScriptÈîôËØØ', errorMsg);
            return false;
        };

        // Êú™Â§ÑÁêÜÁöÑPromiseÈîôËØØ
        window.addEventListener('unhandledrejection', function(event) {
            const errorMsg = `Êú™Â§ÑÁêÜÁöÑPromiseÊãíÁªù: ${event.reason}\nPromise: ${event.promise}\nÈîôËØØÂ†ÜÊ†à: ${event.reason ? event.reason.stack : 'Êó†Â†ÜÊ†à‰ø°ÊÅØ'}`;
            if (debugConsole) debugConsole.error('PromiseÈîôËØØ', errorMsg);
        });

    </script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"7939e04a4baf43c8b86a560f74aac60e","server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"5ccbff2f5b094d9889bac76ef086ce1a","server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"7939e04a4baf43c8b86a560f74aac60e","server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"5ccbff2f5b094d9889bac76ef086ce1a","server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>
</html>