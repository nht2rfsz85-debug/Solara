<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>éŸ³ä¹æ’­æ”¾å™¨ - Apple Liquid Glass é£æ ¼</title>
    <style>
        /* åªæ·»åŠ å¿…è¦çš„CSSä¿®æ”¹ï¼Œå…¶ä»–CSSä¿æŒä¸å˜ */
        
        /* APIé€‰æ‹©å™¨æ ·å¼ */
        .api-select {
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
            min-width: 180px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .api-select:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .api-select option {
            background: #333;
            color: white;
        }
        
        

/* é¢œè‰²ç®—æ³•åˆ‡æ¢æŒ‰é’®æ ·å¼ */
.algo-toggle-btn {
    padding: 15px 20px;
    border: none;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    font-size: 1rem;
    backdrop-filter: blur(10px);
    min-width: 180px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.algo-toggle-btn:hover {
    background: rgba(255, 255, 255, 0.2);
}

        /* APIé€‰æ‹©å™¨æç¤ºæ ‡ç­¾ */
        .api-select-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
            margin-left: 5px;
            font-weight: normal;
        }
        
        @media (max-width: 768px) {
            .search-section {
                flex-direction: column;
            }
            
            .api-select, .algo-toggle-btn, .source-select, .quality-select {
                width: 100%;
            }
        }
        
        /* æœç´¢ç»“æœä¸­çš„å¹³å°æ ‡ç­¾ */
        .result-item .platform-badge {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 2px;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .result-item .platform-badge.kuwo {
            background: rgba(255, 87, 34, 0.2);
            color: #ff5722;
        }
        
        .result-item .platform-badge.netease {
            background: rgba(216, 30, 6, 0.2);
            color: #d81e06;
        }
        
        .result-item .platform-badge.qq {
            background: rgba(25, 137, 250, 0.2);
            color: #1989fa;
        }
        
        .result-item .platform-badge.joox {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
        
        .result-item .platform-badge.aggregate {
            background: rgba(156, 39, 176, 0.2);
            color: #9c27b0;
        }
        
        /* åŸæœ‰çš„æ‰€æœ‰CSSä¿æŒä¸å˜ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-overflow-scrolling: touch; 
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', 'Inter', sans-serif;
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
            position: relative;
            overflow-x: hidden; 
            background-color: #000;
            -webkit-font-smoothing: antialiased;
        }

        /* åŠ¨æ€èƒŒæ™¯åŠ¨ç”»ï¼Œç”¨äºå¯é€‰çš„èƒŒæ™¯æ¨¡å¼ */
        /* é‡‡ç”¨å¤šä¸ªå¾„å‘æ¸å˜å åŠ å¹¶ç¼“æ…¢ç§»åŠ¨ä½ç½®ï¼Œè¥é€ å‡ºç±»ä¼¼ html-music é¡¹ç›®ä¸­çš„æµåŠ¨èƒŒæ™¯æ•ˆæœ */
        body.swirl-gradient {
            background:
                radial-gradient(circle at 10% 10%, #ff6ec4, transparent 60%),
                radial-gradient(circle at 90% 90%, #7873f5, transparent 60%),
                radial-gradient(circle at 50% 50%, #42e695, transparent 60%);
            /* æ”¾å¤§èƒŒæ™¯å°ºå¯¸ä»¥è·å¾—æ›´æŸ”å’Œçš„è¿‡æ¸¡ */
            background-size: 200% 200%;
            animation: swirlBackground 25s linear infinite;
        }

        @keyframes swirlBackground {
            0% { background-position: 0% 0%, 100% 100%, 50% 50%; }
            50% { background-position: 50% 50%, 0% 0%, 100% 100%; }
            100% { background-position: 100% 100%, 50% 50%, 0% 0%; }
        }

        #gradientCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            transform: scale(1.05);
            filter: blur(15px);
            opacity: 0.9;
            transition: opacity 0.5s ease;
        }

        .liquid-glass-effect {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(35px) saturate(180%);
            -webkit-backdrop-filter: blur(35px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4), 
                        inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 20px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        .search-section {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .search-box {
            flex: 1;
            min-width: 300px;
            position: relative;
        }
        
        .search-input {
            width: 100%;
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(255,255,255,0.1);
        }
        
        .source-select, .quality-select {
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
            min-width: 150px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .source-select option, .quality-select option {
            background: #333;
            color: white;
        }

        .source-select:hover, .quality-select:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .search-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .search-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .player-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            .player-container {
                grid-template-columns: 1fr;
            }
        }
        
        .now-playing {
            border-radius: 20px;
            padding: 30px;
            position: relative;
        }
        
        .album-art {
            width: 100%;
            border-radius: 20px;
            margin-bottom: 25px;
            aspect-ratio: 1;
            object-fit: cover;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4);
            display: none;
            transition: transform 0.3s ease;
        }
        
        .album-art-placeholder {
            width: 100%;
            border-radius: 20px;
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 4rem;
            margin-bottom: 25px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
        }
        
        .song-info {
            margin-bottom: 25px;
        }
        
        .song-title {
            font-size: 1.8rem;
            margin-bottom: 8px;
            font-weight: 700;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .song-artist {
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.1rem;
            font-weight: 500;
        }
        
        .progress-container {
            margin-bottom: 25px;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
            margin-bottom: 12px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: white;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .progress-handle {
            position: absolute;
            top: 50%;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .progress-bar:hover .progress-handle {
            opacity: 1;
        }
        
        .time-info {
            display: flex;
            justify-content: space-between;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 25px;
            margin-bottom: 25px;
        }
        
        .control-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }
        
        .play-btn {
            background: rgba(255, 255, 255, 0.2);
            width: 70px;
            height: 70px;
            font-size: 2rem;
        }

        .play-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .speed-control {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.2);
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .speed-control input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            cursor: pointer;
        }
        
        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .lyrics-container {
            border-radius: 20px;
            padding: 30px;
            max-height: 400px;
            overflow-y: auto;
            touch-action: pan-y; 
            position: relative;
        }

        .lyrics-container::-webkit-scrollbar {
            width: 8px;
        }

        .lyrics-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .lyrics-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .lyrics-container::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .fullscreen-lyrics-btn {
            position: absolute;
            bottom: 25px;
            right: 25px;
            background: rgba(255, 255, 255, 0.25);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            z-index: 10;
            font-weight: 600;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .fullscreen-lyrics-btn:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .lyrics-content {
            line-height: 1.8;
            text-align: center;
        }
        
        .lyric-line {
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.5);
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            cursor: pointer;
            padding: 10px 15px;
            border-radius: 12px;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-weight: 500;
        }
        
        .lyric-line.active {
            color: #fff;
            font-size: 1.2rem;
            background: rgba(255, 255, 255, 0.15);
            font-weight: 700;
            transform: scale(1.02);
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .original-text, .translation-text {
            display: inline-block;
            transition: color 0.3s ease;
        }
        .translation-text {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
            font-weight: 400;
        }
        
        .lyric-line.active .translation-text {
            color: rgba(255, 255, 255, 0.85);
        }

        .word-highlight {
            color: #ffcc00;
            transition: color 0.1s linear;
        }

        .fullscreen-lyrics-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
            display: none;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.65); 
            transition: opacity 0.5s ease;
            opacity: 0;
            touch-action: none; 
        }

        .fullscreen-lyrics-overlay.active {
            display: block;
            opacity: 1;
        }

        .fullscreen-lyrics-content {
            position: relative;
            z-index: 2;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0;
        }

        .close-fullscreen-btn {
            position: fixed;
            top: 50px;
            right: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 10000;
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .fullscreen-lyrics-lines {
            width: 100%;
            flex-grow: 1;
            padding: 0 20px 0 40px;
            margin-top: 20px;
            overflow-y: auto;
            text-align: left;
            scrollbar-width: none;
            touch-action: pan-y; 
            mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
        }
        
        .fullscreen-lyrics-lines::-webkit-scrollbar {
            display: none;
        }

        .fullscreen-lyric-line {
            font-size: clamp(2rem, 5vw, 3rem);
            line-height: 1.35;
            padding: 10px 0;
            margin: 25px 0;
            color: rgba(255, 255, 255, 0.4);
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            font-weight: 700;
            cursor: pointer;
        }
        
        .fullscreen-line-wrapper {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .fullscreen-lyric-line.active {
            color: #fff;
            font-size: clamp(2.5rem, 6vw, 3.5rem);
            font-weight: 800;
            transform: scale(1.01);
            text-shadow: 0 4px 30px rgba(0,0,0,0.4);
        }
        
        .fullscreen-translation-text {
            font-size: 0.6em;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        }
        
        .fullscreen-lyric-line.active .fullscreen-translation-text {
             color: rgba(255, 255, 255, 0.85);
        }

        .fullscreen-controls-panel {
            flex-shrink: 0;
            width: 90%;
            max-width: 600px;
            margin-bottom: 50px;
            padding: 15px 25px;
            border-radius: 40px;
        }

        .fullscreen-song-info {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .fullscreen-album-art {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            object-fit: cover;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .fullscreen-track-details {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            white-space: nowrap;
        }

        .fullscreen-song-title {
            font-size: 1.2rem;
            font-weight: 700;
            text-overflow: ellipsis;
        }

        .fullscreen-song-artist {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .fullscreen-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .fullscreen-progress {
            height: 100%;
            background: white;
            border-radius: 2px;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .fullscreen-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
        }

        .fullscreen-control-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            font-size: 2.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .fullscreen-control-btn.play {
            width: 65px;
            height: 65px;
            background: white;
            color: black;
            font-size: 2.5rem;
            padding-left: 5px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .fullscreen-control-btn:hover {
            transform: scale(1.1);
        }
        
        .fullscreen-control-btn.play:hover {
            transform: scale(1.05);
        }
        
        @media (max-width: 900px) {
            .fullscreen-lyrics-content {
                justify-content: flex-end;
                align-items: flex-start;
            }
            .fullscreen-lyrics-lines {
                margin-top: auto;
                height: 60vh;
                padding-bottom: 20px;
                padding-left: 20px;
                text-align: left;
            }
            .fullscreen-lyric-line {
                font-size: clamp(1.8rem, 5vw, 2.5rem);
            }
            .fullscreen-lyric-line.active {
                font-size: clamp(2.3rem, 6vw, 3rem);
            }
            .fullscreen-controls-panel {
                width: 95%;
                margin-bottom: 30px;
            }
            .close-fullscreen-btn {
                top: 20px;
                right: 20px;
            }
        }
        
        .search-results {
            border-radius: 20px;
            padding: 20px;
        }
        
        .results-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 15px;
            padding: 0 10px;
        }

        #resultsContainer {
            overflow: hidden;
        }
        
        .result-item {
            display: flex;
            align-items: center;
            padding: 12px 10px;
            gap: 15px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            position: relative;
            background: rgba(255, 255, 255, 0.05); 
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #resultsContainer .result-item:first-child {
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
        }
        #resultsContainer .result-item:last-child {
            border-bottom-left-radius: 15px;
            border-bottom-right-radius: 15px;
            border-bottom: none;
        }
        
        .result-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.005);
        }
        
        .result-item.active {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.005);
        }

        .result-album {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            object-fit: cover;
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .result-info {
            flex-grow: 1;
            min-width: 0;
            overflow: hidden;
        }

        .result-title {
            font-size: 1.1rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .result-artist {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .result-album-name {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 2px;
        }
        
        .result-platform-info {
            display: flex;
            gap: 8px;
            margin-top: 2px;
        }
        
        .search-results .loading {
            padding: 20px 10px;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
        }

        /* ========== è°ƒè¯•æ§åˆ¶å°æ ·å¼ ========== */
        .debug-console {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            width: 400px;
            max-height: 500px;
            background: rgba(20, 20, 20, 0.95);
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            transition: all 0.3s ease;
        }
        
        .debug-console.collapsed {
            height: auto;
        }
        
        .debug-console.expanded {
            height: 500px;
        }
        
        .debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: rgba(40, 40, 40, 0.9);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: move;
            user-select: none;
        }
        
        .debug-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .debug-controls {
            display: flex;
            gap: 5px;
        }
        
        .debug-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .debug-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .debug-btn.clear {
            color: #ff6b6b;
        }
        
        .debug-btn.clear:hover {
            background: rgba(255, 107, 107, 0.2);
        }
        
        .debug-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Courier New', Monaco, monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .debug-log {
            margin-bottom: 8px;
            padding: 8px 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.03);
            border-left: 3px solid #4dabf7;
            word-break: break-all;
            white-space: pre-wrap;
            color: #e9ecef;
        }
        
        .debug-log.error {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.08);
            color: #ffc9c9;
        }
        
        .debug-log.warning {
            border-left-color: #ffd43b;
            background: rgba(255, 212, 59, 0.08);
            color: #ffec99;
        }
        
        .debug-log.info {
            border-left-color: #4dabf7;
            background: rgba(77, 171, 247, 0.08);
            color: #c5f6fa;
        }
        
        .debug-log.success {
            border-left-color: #51cf66;
            background: rgba(81, 207, 102, 0.08);
            color: #b2f2bb;
        }
        
        .debug-log.api {
            border-left-color: #9775fa;
            background: rgba(151, 117, 250, 0.08);
            color: #d0bfff;
        }
        
        .debug-timestamp {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 2px;
        }
        
        .debug-message {
            margin-top: 2px;
        }
        
        .debug-toggle-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            width: 50px;
            height: 50px;
            border-radius: 25px;
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        .debug-toggle-btn:hover {
            background: rgba(60, 60, 60, 0.9);
            transform: scale(1.05);
        }
        
        .debug-toggle-btn.hidden {
            display: none;
        }
        
        .debug-console.hidden {
            display: none;
        }
        
        /* æ»šåŠ¨æ¡æ ·å¼ */
        .debug-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .debug-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        .debug-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }
        
        .debug-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        @media (max-width: 600px) {
            .debug-console {
                width: 95%;
                right: 2.5%;
                bottom: 80px;
                max-height: 300px;
            }
            
            .debug-console.expanded {
                height: 300px;
            }
            
            .result-item {
                padding: 10px;
            }
        }

        @media (max-width: 600px) {
            .result-item {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- Canvas for Pixi.js dynamic background. It's hidden unless the dynamic background mode is active. -->
    <canvas id="pixiBackgroundCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -2; pointer-events: none; display: none;"></canvas>
    <canvas id="gradientCanvas"></canvas>

    <div class="container">
        <div class="header liquid-glass-effect">
            <h1>éŸ³ä¹æ’­æ”¾å™¨</h1>
        </div>
        
        <div class="search-section">
            <div class="search-box">
                <input type="text" class="search-input" id="searchInput" placeholder="æœç´¢æ­Œæ›²ã€æ­Œæ‰‹æˆ–ä¸“è¾‘..." value="å‘¨æ°ä¼¦">
            </div>
            <!-- æ–°å¢ï¼šAPIé€‰æ‹©å™¨ -->
            <select class="api-select" id="apiSelect" title="é€‰æ‹©APIæ¥å£æº">
                <option value="gdstudio" selected>åŸAPI (GDStudio)</option>
                <option value="tunehub">å¤‡ç”¨API (TuneHub)</option>
            </select>
                        <button class="algo-toggle-btn" id="algoToggleBtn" title="åˆ‡æ¢ä¸“è¾‘å°é¢é¢œè‰²æå–ç®—æ³•">ç®—æ³•ï¼šåŸ(ä¸­ä½åˆ‡åˆ†)</button>
                        <!-- æ–°å¢ï¼šèƒŒæ™¯æ¨¡å¼åˆ‡æ¢æŒ‰é’®ï¼Œå¯åœ¨å°é¢å–è‰²ä¸åŠ¨æ€åŠ¨æ•ˆä¹‹é—´åˆ‡æ¢ -->
                        <button class="algo-toggle-btn" id="backgroundToggleBtn" title="åˆ‡æ¢æ’­æ”¾å™¨èƒŒæ™¯é£æ ¼">èƒŒæ™¯ï¼šå°é¢å–è‰²</button>
<select class="source-select" id="sourceSelect">
                <option value="kuwo" selected>é…·æˆ‘éŸ³ä¹</option>
                <option value="joox">JOOXéŸ³ä¹</option>
                <option value="netease">ç½‘æ˜“äº‘éŸ³ä¹</option>
                <!-- TuneHub APIä¸“ç”¨é€‰é¡¹ -->
                <option value="qq">QQéŸ³ä¹ (ä»…TuneHub)</option>
                <option value="aggregate">èšåˆæœç´¢ (ä»…TuneHub)</option>
            </select>
            <button class="search-btn" id="searchBtn">æœç´¢</button>
        </div>
        
        <div class="player-container">
            <div class="now-playing liquid-glass-effect">
                
                <div class="speed-control">
                    <span>é€Ÿåº¦</span>
                    <input type="range" id="speedSlider" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>

                <div class="album-art-placeholder">â™ª</div>
                <img src="" alt="ä¸“è¾‘å°é¢" class="album-art" id="albumArt">
                <div class="song-info">
                    <h2 class="song-title" id="songTitle">è¯·é€‰æ‹©æ­Œæ›²</h2>
                    <p class="song-artist" id="songArtist">æœªçŸ¥è‰ºæœ¯å®¶</p>
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar">
                        <div class="progress" id="progress"></div>
                        <div class="progress-handle" id="progressHandle"></div>
                    </div>
                    <div class="time-info">
                        <span id="currentTime">0:00</span>
                        <span id="duration">0:00</span>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="control-btn" id="prevBtn">â®</button>
                    <button class="control-btn play-btn" id="playBtn">â–¶</button>
                    <button class="control-btn" id="nextBtn">â­</button>
                </div>
                
                <select class="quality-select" id="qualitySelect">
                    <option value="128">æ ‡å‡†å“è´¨ (128k)</option>
                    <option value="192">è‰¯å¥½å“è´¨ (192k)</option>
                    <option value="320">é«˜å“è´¨ (320k)</option>
                    <option value="740">æ— æŸå“è´¨ (740k)</option>
                    <option value="999" selected>é«˜è§£æåº¦ (999k)</option>
                </select>
            </div>
            
            <div class="lyrics-container liquid-glass-effect" id="lyricsContainer">
                <h3 class="lyrics-title">æ­Œè¯</h3>
                <div class="lyrics-content" id="lyricsContent">
                    <div class="loading">æš‚æ— æ­Œè¯</div>
                </div>
                <button class="fullscreen-lyrics-btn" id="fullscreenLyricsBtn">
                    <span>â›¶</span> å…¨å±æ²‰æµ¸æ¨¡å¼
                </button>
            </div>
        </div>
        
        <div class="search-results liquid-glass-effect">
            <h3 class="results-title">æœç´¢ç»“æœ</h3>
            <div id="resultsContainer">
                <div class="loading">ç‚¹å‡»æœç´¢æŒ‰é’®å¼€å§‹æœç´¢éŸ³ä¹</div>
            </div>
        </div>
    </div>

    <div class="fullscreen-lyrics-overlay" id="fullscreenLyricsOverlay">
        <button class="close-fullscreen-btn" id="closeFullscreenBtn">âœ•</button>
        
        <div class="fullscreen-lyrics-content">
            <div class="fullscreen-lyrics-lines" id="fullscreenLyricsLines">
                <div class="loading">æš‚æ— æ­Œè¯</div>
            </div>

            <div class="fullscreen-controls-panel liquid-glass-effect">
                
                <div class="fullscreen-song-info">
                    <img src="" alt="ä¸“è¾‘å°é¢" class="fullscreen-album-art" id="fullscreenAlbumArt">
                    <div class="fullscreen-track-details">
                        <div class="fullscreen-song-title" id="fullscreenSongTitle">æ­Œæ›²åç§°</div>
                        <div class="fullscreen-song-artist" id="fullscreenSongArtist">è‰ºæœ¯å®¶</div>
                    </div>
                </div>
                
                <div class="fullscreen-progress-bar" id="fullscreenProgressBar">
                    <div class="fullscreen-progress" id="fullscreenProgress"></div>
                </div>
                
                <div class="fullscreen-controls">
                    <button class="fullscreen-control-btn" id="fullscreenPrevBtn">â®</button>
                    <button class="fullscreen-control-btn play" id="fullscreenPlayBtn">â–¶</button>
                    <button class="fullscreen-control-btn" id="fullscreenNextBtn">â­</button>
                </div>
            </div>
        </div>
    </div>

    <!-- è°ƒè¯•æ§åˆ¶å° -->
    <button class="debug-toggle-btn" id="debugToggleBtn">ğŸ›</button>
    
    <div class="debug-console hidden" id="debugConsole">
        <div class="debug-header">
            <div class="debug-title">
                <span>ğŸ”§ è°ƒè¯•æ§åˆ¶å°</span>
            </div>
            <div class="debug-controls">
                <button class="debug-btn clear" id="debugClearBtn" title="æ¸…ç©ºæ—¥å¿—">ğŸ—‘ï¸</button>
                <button class="debug-btn" id="debugMinimizeBtn" title="æœ€å°åŒ–">âˆ’</button>
                <button class="debug-btn" id="debugCloseBtn" title="å…³é—­">âœ•</button>
            </div>
        </div>
        <div class="debug-content" id="debugContent">
            <div class="debug-log info">
                <div class="debug-timestamp">ç³»ç»Ÿå¯åŠ¨</div>
                <div class="debug-message">è°ƒè¯•æ§åˆ¶å°å·²åˆå§‹åŒ–ï¼Œç­‰å¾…æ“ä½œ...</div>
            </div>
        </div>
    </div>

    <audio id="audioPlayer"></audio>

    <script>
        // ========== è°ƒè¯•æ§åˆ¶å°ç³»ç»Ÿ ==========
        // ä¿æŒåŸæœ‰çš„è°ƒè¯•æ§åˆ¶å°é€»è¾‘ï¼Œä½†å»¶è¿Ÿåˆå§‹åŒ–
        let debugConsole = null;
        
        function initDebugConsole() {
            if (document.getElementById('debugConsole') && !debugConsole) {
                class DebugConsole {
                    constructor() {
                        this.consoleElement = document.getElementById('debugConsole');
                        this.contentElement = document.getElementById('debugContent');
                        this.toggleBtn = document.getElementById('debugToggleBtn');
                        this.clearBtn = document.getElementById('debugClearBtn');
                        this.minimizeBtn = document.getElementById('debugMinimizeBtn');
                        this.closeBtn = document.getElementById('debugCloseBtn');
                        this.isExpanded = true;
                        this.isVisible = false;
                        this.logCount = 0;
                        this.maxLogs = 100;
                        
                        this.init();
                    }
                    
                    init() {
                        // ç»‘å®šäº‹ä»¶
                        this.toggleBtn.addEventListener('click', () => this.toggleVisibility());
                        this.clearBtn.addEventListener('click', () => this.clearLogs());
                        this.minimizeBtn.addEventListener('click', () => this.toggleSize());
                        this.closeBtn.addEventListener('click', () => this.hide());
                        
                        // åˆå§‹çŠ¶æ€
                        this.consoleElement.classList.add('expanded');
                        
                        this.log('ç³»ç»Ÿ', 'è°ƒè¯•æ§åˆ¶å°åˆå§‹åŒ–å®Œæˆ', 'info');
                    }
                    
                    toggleVisibility() {
                        this.isVisible = !this.isVisible;
                        if (this.isVisible) {
                            this.show();
                        } else {
                            this.hide();
                        }
                    }
                    
                    show() {
                        this.consoleElement.classList.remove('hidden');
                        this.toggleBtn.classList.add('hidden');
                        this.isVisible = true;
                        this.log('ç³»ç»Ÿ', 'è°ƒè¯•æ§åˆ¶å°å·²æ‰“å¼€', 'info');
                    }
                    
                    hide() {
                        this.consoleElement.classList.add('hidden');
                        this.toggleBtn.classList.remove('hidden');
                        this.isVisible = false;
                    }
                    
                    toggleSize() {
                        this.isExpanded = !this.isExpanded;
                        if (this.isExpanded) {
                            this.consoleElement.classList.remove('collapsed');
                            this.consoleElement.classList.add('expanded');
                            this.minimizeBtn.textContent = 'âˆ’';
                            this.minimizeBtn.title = 'æœ€å°åŒ–';
                        } else {
                            this.consoleElement.classList.remove('expanded');
                            this.consoleElement.classList.add('collapsed');
                            this.minimizeBtn.textContent = 'â–¡';
                            this.minimizeBtn.title = 'æœ€å¤§åŒ–';
                        }
                    }
                    
                    clearLogs() {
                        this.contentElement.innerHTML = '';
                        this.logCount = 0;
                        this.log('ç³»ç»Ÿ', 'æ—¥å¿—å·²æ¸…ç©º', 'info');
                    }
                    
                    log(category, message, type = 'info') {
                        this.logCount++;
                        
                        // é™åˆ¶æ—¥å¿—æ•°é‡
                        if (this.logCount > this.maxLogs) {
                            const logs = this.contentElement.querySelectorAll('.debug-log');
                            if (logs.length > this.maxLogs) {
                                logs[0].remove();
                            }
                        }
                        
                        const timestamp = new Date().toLocaleTimeString('zh-CN', {
                            hour12: false,
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                        
                        const logElement = document.createElement('div');
                        logElement.className = `debug-log ${type}`;
                        
                        logElement.innerHTML = `
                            <div class="debug-timestamp">[${timestamp}] [${category}]</div>
                            <div class="debug-message">${this.escapeHtml(message)}</div>
                        `;
                        
                        this.contentElement.appendChild(logElement);
                        
                        // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
                        this.contentElement.scrollTop = this.contentElement.scrollHeight;
                    }
                    
                    error(category, message) {
                        this.log(category, message, 'error');
                    }
                    
                    warn(category, message) {
                        this.log(category, message, 'warning');
                    }
                    
                    info(category, message) {
                        this.log(category, message, 'info');
                    }
                    
                    success(category, message) {
                        this.log(category, message, 'success');
                    }
                    
                    api(category, message) {
                        this.log(category, message, 'api');
                    }
                    
                    escapeHtml(text) {
                        const div = document.createElement('div');
                        div.textContent = text;
                        return div.innerHTML;
                    }
                }
                
                debugConsole = new DebugConsole();
            }
        }

        // ========== åŠ¨æ€ç½‘æ ¼æ¸å˜ç³»ç»Ÿ ==========
        const canvas = document.getElementById('gradientCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        
        let gradientPoints = [];
        let animationId = null;
        let lastTime = 0;
        let ANIMATION_SPEED_MULTIPLIER = 1.0; 
        
        // é»˜è®¤é…è‰²æ–¹æ¡ˆ
        const defaultPalette = [
            { r: 47, g: 72, b: 88 },    
            { r: 146, g: 60, b: 88 },   
            { r: 240, g: 99, b: 164 },  
            { r: 45, g: 52, b: 54 },    
            { r: 85, g: 52, b: 124 },   
            { r: 255, g: 159, b: 67 }   
        ];

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // åˆå§‹åŒ– 6x6 ç½‘æ ¼ç‚¹
        function initGradientPoints(colors = null) {
            gradientPoints = [];
            const cols = 6;
            const rows = 6;
            const width = canvas.width;
            const height = canvas.height;
            const cellW = width / cols;
            const cellH = height / rows;
            const palette = colors && colors.length > 0 ? colors : defaultPalette;

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const baseX = j * cellW + cellW / 2;
                    const baseY = i * cellH + cellH / 2;
                    
                    const colorIdx = (i * cols + j) % palette.length;
                    const initialColor = palette[colorIdx];

                    gradientPoints.push({
                        x: baseX,
                        y: baseY,
                        baseX: baseX,
                        baseY: baseY,
                        color: { ...initialColor },
                        targetColor: { ...initialColor },

                        rangeX: cellW * 1.5,
                        rangeY: cellH * 1.5,
                        phaseX: Math.random() * Math.PI * 2,
                        phaseY: Math.random() * Math.PI * 2,
                        speedX: (0.0001 + Math.random() * 0.0003) * (Math.random() > 0.5 ? 1 : -1),
                        speedY: (0.0001 + Math.random() * 0.0003) * (Math.random() > 0.5 ? 1 : -1),
                        
                        radiusBase: Math.max(width, height) * 0.35, 
                        radiusPhase: Math.random() * Math.PI * 2,
                        radiusSpeed: 0.0005 + Math.random() * 0.0005,
                        
                        phaseZ: Math.random() * Math.PI * 2,
                        speedZ: 0.001 + Math.random() * 0.0015
                    });
                }
            }
        }

        // æ ¸å¿ƒæ¸²æŸ“å¾ªç¯
        function animate(time) {
            if (!lastTime) lastTime = time;
            const deltaTime = time - lastTime;
            lastTime = time;

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-over';

            gradientPoints.forEach(p => {
                const speed = ANIMATION_SPEED_MULTIPLIER;
                p.phaseX += p.speedX * deltaTime * speed;
                p.phaseY += p.speedY * deltaTime * speed;
                p.radiusPhase += p.radiusSpeed * deltaTime * speed;
                p.phaseZ += p.speedZ * deltaTime * speed;

                p.x = p.baseX + Math.sin(p.phaseX) * p.rangeX / 3 + Math.sin(p.phaseZ) * p.rangeX / 6;
                p.y = p.baseY + Math.cos(p.phaseY) * p.rangeY / 3 + Math.cos(p.phaseZ) * p.rangeY / 6;

                const ease = 0.015;
                p.color.r += (p.targetColor.r - p.color.r) * ease;
                p.color.g += (p.targetColor.g - p.color.g) * ease;
                p.color.b += (p.targetColor.b - p.color.b) * ease;

                const currentRadius = p.radiusBase + Math.sin(p.radiusPhase) * (p.radiusBase * 0.1);
                
                const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, currentRadius);
                
                const r = Math.round(p.color.r);
                const gVal = Math.round(p.color.g);
                const b = Math.round(p.color.b);
                
                g.addColorStop(0, `rgba(${r}, ${gVal}, ${b}, 0.8)`);
                g.addColorStop(0.3, `rgba(${r}, ${gVal}, ${b}, 0.5)`);
                g.addColorStop(1, `rgba(${r}, ${gVal}, ${b}, 0)`);

                ctx.fillStyle = g;
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
            });

            animationId = requestAnimationFrame(animate);
        }

        // ========== å®Œæ•´ç‰ˆé¢œè‰²é‡åŒ–ç®—æ³•ï¼ˆä¸­ä½åˆ‡åˆ†æ³• / K-meansï¼‰ ==========
        function extractMainColors(img) {
            try {
                if (debugConsole) debugConsole.log('é¢œè‰²æå–', 'å¼€å§‹æå–ä¸“è¾‘å°é¢ä¸»è¦é¢œè‰²...', 'info');
                
                // åˆ›å»ºCanvaså¤„ç†å›¾åƒ
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // è®¾ç½®Canvaså°ºå¯¸ï¼ˆé€‚å½“ç¼©å°ä»¥æé«˜æ€§èƒ½ï¼‰
                const maxSize = 200;
                let width = img.width;
                let height = img.height;
                
                if (width > maxSize || height > maxSize) {
                    const scale = maxSize / Math.max(width, height);
                    width = Math.floor(width * scale);
                    height = Math.floor(height * scale);
                }
                
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);
                
                // è·å–å›¾åƒæ•°æ®
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                // æ”¶é›†æ‰€æœ‰åƒç´ é¢œè‰²
                const pixels = [];
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    // å¿½ç•¥å®Œå…¨é€æ˜æˆ–æ¥è¿‘é€æ˜çš„åƒç´ 
                    if (data[i + 3] < 50) continue;
                    
                    pixels.push({ r, g, b });
                }
                
                if (pixels.length === 0) {
                    if (debugConsole) debugConsole.warn('é¢œè‰²æå–', 'æœªæå–åˆ°æœ‰æ•ˆåƒç´ é¢œè‰²ï¼Œä½¿ç”¨é»˜è®¤é…è‰²æ–¹æ¡ˆ');
                    return defaultPalette;
                }
                
                if (debugConsole) debugConsole.log('é¢œè‰²æå–', `æˆåŠŸé‡‡é›† ${pixels.length} ä¸ªåƒç´ ç‚¹é¢œè‰²`, 'success');
                

                // æ ¹æ®é€‰æ‹©çš„ç®—æ³•æå–é¢œè‰²
                const colorCount = 12; // éœ€è¦æå–çš„é¢œè‰²æ•°é‡
                let colors = [];
                // ----------- æ–°å¢ï¼šæ£€æµ‹æ•´ä½“é¥±å’Œåº¦å’Œäº®åº¦ï¼Œå•è‰²å›¾ç‰‡ä½¿ç”¨æŸ”å’Œæ¸å˜é…è‰² -------------
                // ä½¿ç”¨ HSL ç»Ÿè®¡å¹³å‡é¥±å’Œåº¦å’Œäº®åº¦ï¼Œå‚è€ƒäº†å›¾åƒæ£€æµ‹ä¸­ä½¿ç”¨ HSV çš„æœ€ä½é¥±å’Œåº¦å’Œäº®åº¦é˜ˆå€¼åˆ¤æ–­å›¾åƒæ˜¯å¦ä¸ºå½©è‰²çš„æ€è·¯ã€949361421858664â€ L24-L29ã€‘ã€‚
                const sampleSize = Math.min(pixels.length, 1000);
                let sumS = 0, sumL = 0;
                let sumR = 0, sumG = 0, sumB = 0;
                const stride = Math.floor(pixels.length / sampleSize) || 1;
                let countSamp = 0;
                for (let i = 0; i < pixels.length && countSamp < sampleSize; i += stride) {
                    const p = pixels[i];
                    const hsl = rgbToHsl(p.r, p.g, p.b);
                    sumS += hsl.s;
                    sumL += hsl.l;
                    sumR += p.r;
                    sumG += p.g;
                    sumB += p.b;
                    countSamp++;
                }
                const avgS = sumS / countSamp;
                const avgL = sumL / countSamp;
                const avgColor = {
                    r: Math.round(sumR / countSamp),
                    g: Math.round(sumG / countSamp),
                    b: Math.round(sumB / countSamp)
                };
                // å½“å¹³å‡é¥±å’Œåº¦æˆ–äº®åº¦ä½äºé˜ˆå€¼æ—¶ï¼Œè®¤å®šå›¾åƒè¿‘ä¼¼é»‘ç™½æˆ–ç°è‰²ï¼Œä½¿ç”¨æ¸å˜è‰²è€ŒéKâ€‘meansã€‚
                if (avgS < 0.15 || avgL < 0.15) {
                    // ç”Ÿæˆä»æš—åˆ°äº®çš„æŸ”å’Œæ¸å˜è°ƒè‰²æ¿
                    const palette = [];
                    const maxLighten = 0.5; // æœ€å¤§äº®åŒ–æ¯”ä¾‹ï¼Œ0.5è¡¨ç¤ºå¢äº®ä¸€åŠ
                    for (let i = 0; i < colorCount; i++) {
                        const factor = (i / (colorCount - 1)) * maxLighten;
                        palette.push(lightenColor(avgColor, factor));
                    }
                    colors = palette;
                    if (debugConsole) debugConsole.log('é¢œè‰²æå–', `æ£€æµ‹åˆ°ä½é¥±å’Œåº¦/ä½äº®åº¦å›¾åƒï¼Œç”Ÿæˆæ¸å˜è‰²è°ƒæ¿`, 'info');
                } else if (COLOR_EXTRACTION_ALGO === 'kmeans') {
                    // ä½¿ç”¨å¢å¼ºçš„ Kâ€‘means ç‰ˆæœ¬åœ¨ Lab ç©ºé—´ä¸­æå–ä¸»è¦é¢œè‰²ã€‚è¯¥ç®—æ³•åˆ©ç”¨ kâ€‘means++ åˆå§‹åŒ–å’Œ
                    // æ„ŸçŸ¥é¢œè‰²ç©ºé—´ä»¥æé«˜ç¨³å®šæ€§ï¼ŒåŒæ—¶è¿‡æ»¤æ‰é¥±å’Œåº¦è¿‡ä½æˆ–äº®åº¦æç«¯çš„é¢œè‰²ï¼Œä»¥æ›´æ¥è¿‘
                    // Apple Music åŠ¨æ€èƒŒæ™¯çš„é€‰è‰²é£æ ¼ã€671412349456928â€ L56-L66ã€‘ã€85381015035948â€ L190-L205ã€‘ã€‚
                    colors = kMeansAppleStyle(pixels, colorCount, 20);
                    if (debugConsole) debugConsole.log('é¢œè‰²æå–', `å¢å¼º K-means æå–åˆ° ${colors.length} ç§ä¸»è¦é¢œè‰²`, 'success');
                } else {
                    // åŸç®—æ³•ï¼šä¸­ä½åˆ‡åˆ†æ³•æå–é¢œè‰²
                    const buckets = medianCut(pixels, colorCount);
                    // è®¡ç®—æ¯ä¸ªbucketçš„å¹³å‡é¢œè‰²
                    colors = buckets.map(bucket => {
                        let r = 0, g = 0, b = 0;
                        const count = bucket.length;
                        for (let i = 0; i < count; i++) {
                            r += bucket[i].r;
                            g += bucket[i].g;
                            b += bucket[i].b;
                        }
                        return {
                            r: Math.round(r / count),
                            g: Math.round(g / count),
                            b: Math.round(b / count)
                        };
                    });
                    if (debugConsole) debugConsole.log('é¢œè‰²æå–', `ä¸­ä½åˆ‡åˆ†æ³•æˆåŠŸæå– ${colors.length} ç§ä¸»è¦é¢œè‰²`, 'success');
                }

                if (debugConsole) debugConsole.log('é¢œè‰²æå–', `æå–çš„é¢œè‰²: ${JSON.stringify(colors)}`, 'info');

                return colors;
            } catch (error) {
                if (debugConsole) debugConsole.error('é¢œè‰²æå–', `é¢œè‰²æå–è¿‡ç¨‹å‡ºç°å¼‚å¸¸: ${error.message}\nå †æ ˆ: ${error.stack}`);
                return defaultPalette;
            }
        }



// K-meansèšç±»æå–ä¸»è¦é¢œè‰²
function kMeansQuantize(pixels, k = 12, maxIter = 10) {
    // ä¸ºæ€§èƒ½æ§åˆ¶ï¼šæœ€å¤šé‡‡æ ·çº¦8000ä¸ªåƒç´ 
    const maxSamples = 8000;
    let samples = pixels;
    if (pixels.length > maxSamples) {
        const stride = Math.ceil(pixels.length / maxSamples);
        samples = [];
        for (let i = 0; i < pixels.length; i += stride) {
            samples.push(pixels[i]);
        }
    }

    // éšæœºåˆå§‹åŒ–èšç±»ä¸­å¿ƒ
    const centroids = [];
    for (let i = 0; i < k; i++) {
        const p = samples[Math.floor(Math.random() * samples.length)];
        centroids.push({ r: p.r, g: p.g, b: p.b });
    }

    const assignments = new Array(samples.length).fill(-1);
    let counts = new Array(k).fill(0);

    for (let iter = 0; iter < maxIter; iter++) {
        const sumR = new Array(k).fill(0);
        const sumG = new Array(k).fill(0);
        const sumB = new Array(k).fill(0);
        counts = new Array(k).fill(0);

        let changed = false;

        for (let i = 0; i < samples.length; i++) {
            const p = samples[i];
            let best = 0;
            let bestDist = Infinity;

            for (let c = 0; c < k; c++) {
                const dr = p.r - centroids[c].r;
                const dg = p.g - centroids[c].g;
                const db = p.b - centroids[c].b;
                const dist = dr * dr + dg * dg + db * db;
                if (dist < bestDist) {
                    bestDist = dist;
                    best = c;
                }
            }

            if (assignments[i] !== best) {
                changed = true;
                assignments[i] = best;
            }

            counts[best]++;
            sumR[best] += p.r;
            sumG[best] += p.g;
            sumB[best] += p.b;
        }

        // æ›´æ–°èšç±»ä¸­å¿ƒ
        for (let c = 0; c < k; c++) {
            if (counts[c] > 0) {
                centroids[c].r = sumR[c] / counts[c];
                centroids[c].g = sumG[c] / counts[c];
                centroids[c].b = sumB[c] / counts[c];
            } else {
                // ç©ºç°‡é‡æ–°éšæœºåˆå§‹åŒ–
                const p = samples[Math.floor(Math.random() * samples.length)];
                centroids[c] = { r: p.r, g: p.g, b: p.b };
            }
        }

        if (!changed) break;
    }

    // æŒ‰ç°‡å¤§å°æ’åºï¼ˆæ›´â€œä¸»è‰²â€ä¼˜å…ˆï¼‰
    const items = centroids.map((c, idx) => ({
        r: Math.round(c.r),
        g: Math.round(c.g),
        b: Math.round(c.b),
        count: counts[idx] || 0
    })).sort((a, b) => b.count - a.count);

    return items.map(({ r, g, b }) => ({ r, g, b }));
}

        /*
         * ------------------------------------------------------------------------
         * Appleâ€‘style Kâ€‘Means color extraction
         *
         * The following helper functions implement color space conversions and
         * kâ€‘means++ initialization so that we can perform clustering in the
         * perceptual CIEÂ Lab space. Apple Musicâ€™s dynamic backgrounds avoid
         * greys and extremes; therefore after clustering we filter out colors
         * with very low saturation or very high/low lightness using HSL.  The
         * resulting palette better approximates the subtle, balanced backgrounds
         * used in Appleâ€™s apps.  References: Kâ€‘means clustering randomly
         * initializes centroids then iteratively assigns points and updates
         * centersã€671412349456928â€ L56-L66ã€‘.  Dynamic theming guidelines stress
         * checking the luma and contrast of extracted colors to ensure
         * readabilityã€85381015035948â€ L190-L205ã€‘.
         */

        // Convert sRGB to XYZ. Assumes r,g,b in [0,255]. Returns x,y,z in [0,1].
        function rgbToXyz(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
            const x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
            const y = r * 0.2126729 + g * 0.7151522 + b * 0.0721750;
            const z = r * 0.0193339 + g * 0.1191920 + b * 0.9503041;
            return { x, y, z };
        }

        // Convert XYZ to CIEÂ Lab. Input x,y,z in [0,1]. Returns L,a,b.
        function xyzToLab(x, y, z) {
            const refX = 0.95047;
            const refY = 1.00000;
            const refZ = 1.08883;
            let xr = x / refX;
            let yr = y / refY;
            let zr = z / refZ;
            const epsilon = 0.008856;
            const kappa = 903.3;
            const fx = xr > epsilon ? Math.cbrt(xr) : (kappa * xr + 16) / 116;
            const fy = yr > epsilon ? Math.cbrt(yr) : (kappa * yr + 16) / 116;
            const fz = zr > epsilon ? Math.cbrt(zr) : (kappa * zr + 16) / 116;
            const L = 116 * fy - 16;
            const a = 500 * (fx - fy);
            const b = 200 * (fy - fz);
            return { L, a, b };
        }

        // Convert Lab to XYZ. Input L,a,b. Returns x,y,z.
        function labToXyz(L, a, b) {
            const refX = 0.95047;
            const refY = 1.00000;
            const refZ = 1.08883;
            const fy = (L + 16) / 116;
            const fx = a / 500 + fy;
            const fz = fy - b / 200;
            const epsilon = 0.008856;
            const cube = (t) => t * t * t;
            let xr = cube(fx) > epsilon ? cube(fx) : (116 * fx - 16) / 903.3;
            let yr = cube(fy) > epsilon ? cube(fy) : (116 * fy - 16) / 903.3;
            let zr = cube(fz) > epsilon ? cube(fz) : (116 * fz - 16) / 903.3;
            const x = xr * refX;
            const y = yr * refY;
            const z = zr * refZ;
            return { x, y, z };
        }

        // Convert XYZ to sRGB. Input x,y,z in [0,1]. Returns r,g,b in [0,255].
        function xyzToRgb(x, y, z) {
            let r = x * 3.2404542 + y * -1.5371385 + z * -0.4985314;
            let g = x * -0.9692660 + y * 1.8760108 + z * 0.0415560;
            let bb = x * 0.0556434 + y * -0.2040259 + z * 1.0572252;
            // gamma correction
            r = r <= 0.0031308 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055;
            g = g <= 0.0031308 ? 12.92 * g : 1.055 * Math.pow(g, 1 / 2.4) - 0.055;
            bb = bb <= 0.0031308 ? 12.92 * bb : 1.055 * Math.pow(bb, 1 / 2.4) - 0.055;
            return {
                r: Math.min(255, Math.max(0, Math.round(r * 255))),
                g: Math.min(255, Math.max(0, Math.round(g * 255))),
                b: Math.min(255, Math.max(0, Math.round(bb * 255)))
            };
        }

        // Combined conversion: RGB â†’ Lab
        function rgbToLab(r, g, b) {
            const xyz = rgbToXyz(r, g, b);
            return xyzToLab(xyz.x, xyz.y, xyz.z);
        }

        // Combined conversion: Lab â†’ RGB
        function labToRgb(L, a, b) {
            const xyz = labToXyz(L, a, b);
            return xyzToRgb(xyz.x, xyz.y, xyz.z);
        }

        // Convert RGB to HSL. Returns h in degrees, s and l in [0,1].
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h = 0, s = 0;
            const l = (max + min) / 2;
            if (max !== min) {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h: h * 360, s, l };
        }

        // Lighten a color towards white by a given factor (0..1).
        // This helper is used for monochrome images where we want a subtle gradient palette.
        function lightenColor(color, factor) {
            return {
                r: Math.round(color.r + (255 - color.r) * factor),
                g: Math.round(color.g + (255 - color.g) * factor),
                b: Math.round(color.b + (255 - color.b) * factor)
            };
        }

        // kâ€‘means++ initialization for Lab points
        function initializeCentroidsPlusPlus(samples, k) {
            const centroids = [];
            // first centroid randomly selected
            const firstIndex = Math.floor(Math.random() * samples.length);
            centroids.push({ L: samples[firstIndex].L, a: samples[firstIndex].a, b: samples[firstIndex].b });
            while (centroids.length < k) {
                const distances = new Array(samples.length);
                let total = 0;
                for (let i = 0; i < samples.length; i++) {
                    let minDist = Infinity;
                    const s = samples[i];
                    for (const c of centroids) {
                        const dL = s.L - c.L;
                        const da = s.a - c.a;
                        const db = s.b - c.b;
                        const dist = dL * dL + da * da + db * db;
                        if (dist < minDist) minDist = dist;
                    }
                    distances[i] = minDist;
                    total += minDist;
                }
                let threshold = Math.random() * total;
                let index = 0;
                while (threshold > 0 && index < samples.length) {
                    threshold -= distances[index];
                    index++;
                }
                const chosen = samples[Math.min(index, samples.length - 1)];
                centroids.push({ L: chosen.L, a: chosen.a, b: chosen.b });
            }
            return centroids;
        }

        // Enhanced Kâ€‘means color quantization using Lab space and basic filtering
        function kMeansAppleStyle(pixels, k = 12, maxIter = 20) {
            // Downsample to ~8000 samples to speed up processing
            const maxSamples = 8000;
            let samples = pixels;
            if (pixels.length > maxSamples) {
                const stride = Math.ceil(pixels.length / maxSamples);
                samples = [];
                for (let i = 0; i < pixels.length; i += stride) {
                    samples.push(pixels[i]);
                }
            }
            // Convert samples to Lab
            const labSamples = samples.map(p => {
                const lab = rgbToLab(p.r, p.g, p.b);
                return { L: lab.L, a: lab.a, b: lab.b, r: p.r, g: p.g, b2: p.b };
            });
            // Initialize centroids
            let centroids = initializeCentroidsPlusPlus(labSamples, k);
            const assignments = new Array(labSamples.length).fill(-1);
            let counts = new Array(k).fill(0);
            for (let iter = 0; iter < maxIter; iter++) {
                const sumL = new Array(k).fill(0);
                const suma = new Array(k).fill(0);
                const sumb = new Array(k).fill(0);
                counts = new Array(k).fill(0);
                let changed = false;
                // assignment step
                for (let i = 0; i < labSamples.length; i++) {
                    const s = labSamples[i];
                    let best = 0;
                    let bestDist = Infinity;
                    for (let c = 0; c < k; c++) {
                        const dL = s.L - centroids[c].L;
                        const da = s.a - centroids[c].a;
                        const db = s.b - centroids[c].b;
                        const dist = dL * dL + da * da + db * db;
                        if (dist < bestDist) {
                            bestDist = dist;
                            best = c;
                        }
                    }
                    if (assignments[i] !== best) {
                        changed = true;
                        assignments[i] = best;
                    }
                    counts[best]++;
                    sumL[best] += s.L;
                    suma[best] += s.a;
                    sumb[best] += s.b;
                }
                // update step
                for (let c = 0; c < k; c++) {
                    if (counts[c] > 0) {
                        centroids[c].L = sumL[c] / counts[c];
                        centroids[c].a = suma[c] / counts[c];
                        centroids[c].b = sumb[c] / counts[c];
                    } else {
                        // reinitialize empty cluster to farthest sample
                        let maxDist = -1;
                        let chosen = labSamples[0];
                        for (const s of labSamples) {
                            let minDist = Infinity;
                            for (let j = 0; j < k; j++) {
                                const dL = s.L - centroids[j].L;
                                const da = s.a - centroids[j].a;
                                const dbb = s.b - centroids[j].b;
                                const dist = dL * dL + da * da + dbb * dbb;
                                if (dist < minDist) minDist = dist;
                            }
                            if (minDist > maxDist) {
                                maxDist = minDist;
                                chosen = s;
                            }
                        }
                        centroids[c] = { L: chosen.L, a: chosen.a, b: chosen.b };
                    }
                }
                if (!changed) break;
            }
            // Convert centroids to RGB and calculate scores based on population, saturation and lightness.
            const items = centroids.map((c, idx) => {
                const rgb = labToRgb(c.L, c.a, c.b);
                const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
                // Score favours clusters with more pixels, higher saturation and moderate lightness.
                // Adding constants prevents zeroing out clusters with low saturation or extreme brightness entirely.
                const pop = counts[idx] || 0;
                const satFactor = 0.5 + hsl.s; // range [0.5, 1.5]
                const lightFactor = 0.3 + (1 - Math.abs(hsl.l - 0.5)); // range [0.3, 1.3]
                const score = pop * satFactor * lightFactor;
                return { r: rgb.r, g: rgb.g, b: rgb.b, count: pop, hsl, score };
            }).sort((a, b) => b.score - a.score);
            // Filter out greys and extremes using HSL thresholds
            const filtered = [];
            for (const item of items) {
                const { hsl } = item;
                if (hsl.s > 0.1 && hsl.l > 0.1 && hsl.l < 0.95) {
                    filtered.push({ r: item.r, g: item.g, b: item.b });
                }
            }
            // If not enough colours pass the filter, fall back to the highestâ€‘scoring centroids.
            let result = filtered;
            if (result.length < k) {
                for (const item of items) {
                    const exists = result.find(c => c.r === item.r && c.g === item.g && c.b === item.b);
                    if (!exists) {
                        result.push({ r: item.r, g: item.g, b: item.b });
                    }
                    if (result.length >= k) break;
                }
            }
            return result.slice(0, k);
        }

        // ä¸­ä½åˆ‡åˆ†æ³•å®ç°
        function medianCut(pixels, targetColors) {
            // åˆå§‹åŒ–ä¸€ä¸ªbucketåŒ…å«æ‰€æœ‰åƒç´ 
            let buckets = [pixels];
            
            // æŒç»­åˆ‡åˆ†ç›´åˆ°è¾¾åˆ°ç›®æ ‡é¢œè‰²æ•°é‡
            while (buckets.length < targetColors) {
                // æ‰¾åˆ°æœ€å¤§çš„bucketæ¥åˆ‡åˆ†
                let largestBucketIndex = 0;
                let largestBucketSize = 0;
                
                for (let i = 0; i < buckets.length; i++) {
                    if (buckets[i].length > largestBucketSize) {
                        largestBucketSize = buckets[i].length;
                        largestBucketIndex = i;
                    }
                }
                
                const bucketToSplit = buckets[largestBucketIndex];
                
                // å¦‚æœbucketå¤ªå°ï¼Œæ— æ³•ç»§ç»­åˆ‡åˆ†
                if (bucketToSplit.length < 2) {
                    break;
                }
                
                // æ‰¾åˆ°é¢œè‰²èŒƒå›´æœ€å¤§çš„é€šé“
                let rMin = 255, rMax = 0;
                let gMin = 255, gMax = 0;
                let bMin = 255, bMax = 0;
                
                for (let i = 0; i < bucketToSplit.length; i++) {
                    const pixel = bucketToSplit[i];
                    rMin = Math.min(rMin, pixel.r);
                    rMax = Math.max(rMax, pixel.r);
                    gMin = Math.min(gMin, pixel.g);
                    gMax = Math.max(gMax, pixel.g);
                    bMin = Math.min(bMin, pixel.b);
                    bMax = Math.max(bMax, pixel.b);
                }
                
                const rRange = rMax - rMin;
                const gRange = gMax - gMin;
                const bRange = bMax - bMin;
                
                // ç¡®å®šåˆ‡åˆ†é€šé“
                let splitChannel;
                if (rRange >= gRange && rRange >= bRange) {
                    splitChannel = 'r';
                } else if (gRange >= rRange && gRange >= bRange) {
                    splitChannel = 'g';
                } else {
                    splitChannel = 'b';
                }
                
                // æŒ‰é€‰å®šé€šé“æ’åº
                bucketToSplit.sort((a, b) => a[splitChannel] - b[splitChannel]);
                
                // æ‰¾åˆ°ä¸­ä½æ•°
                const medianIndex = Math.floor(bucketToSplit.length / 2);
                
                // åˆ‡åˆ†bucket
                const bucket1 = bucketToSplit.slice(0, medianIndex);
                const bucket2 = bucketToSplit.slice(medianIndex);
                
                // æ›¿æ¢åŸbucketä¸ºä¸¤ä¸ªæ–°bucket
                buckets.splice(largestBucketIndex, 1, bucket1, bucket2);
            }
            
            return buckets;
        }

        // ä»ä¸“è¾‘å°é¢æå–ä¸»è¦é¢œè‰²
        function updateGradientFromAlbum(imageUrl) {
            if (!imageUrl) {
                if (debugConsole) debugConsole.warn('æ¸å˜èƒŒæ™¯', 'æ— ä¸“è¾‘å°é¢URLï¼Œä½¿ç”¨é»˜è®¤é¢œè‰²');
                gradientPoints.forEach((p, i) => {
                    const newColor = defaultPalette[i % defaultPalette.length];
                    p.targetColor = { ...newColor };
                });
                return;
            }
            
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                try {
                    if (debugConsole) debugConsole.log('æ¸å˜èƒŒæ™¯', 'å¼€å§‹ä»ä¸“è¾‘å°é¢æå–é¢œè‰²...', 'info');
                    const colors = extractMainColors(img);
                    
                    // ç¡®ä¿æˆ‘ä»¬æœ‰è¶³å¤Ÿçš„é¢œè‰²
                    let extendedColors = [];
                    while (extendedColors.length < 36) {
                        extendedColors = extendedColors.concat(colors);
                    }
                    
                    // æ›´æ–°æ¸å˜ç‚¹çš„ç›®æ ‡é¢œè‰²
                    gradientPoints.forEach((p, i) => {
                        const newColor = extendedColors[i];
                        if (newColor) {
                            p.targetColor = { ...newColor };
                        }
                    });
                    
                    if (debugConsole) debugConsole.success('æ¸å˜èƒŒæ™¯', 'ä¸“è¾‘å°é¢é¢œè‰²æå–å®Œæˆï¼Œæ¸å˜èƒŒæ™¯å·²æ›´æ–°');
                } catch (error) {
                    if (debugConsole) debugConsole.error('æ¸å˜èƒŒæ™¯', `ä¸“è¾‘å°é¢é¢œè‰²æå–å¤±è´¥: ${error.message}`);
                }
            };
            
            img.onerror = (e) => {
                if (debugConsole) debugConsole.error('æ¸å˜èƒŒæ™¯', `ä¸“è¾‘å°é¢å›¾ç‰‡åŠ è½½å¤±è´¥: ${imageUrl}\né”™è¯¯ä¿¡æ¯: ${e.message}`);
                // åŠ è½½å¤±è´¥ä½¿ç”¨é»˜è®¤è‰²
                gradientPoints.forEach((p, i) => {
                    const newColor = defaultPalette[i % defaultPalette.length];
                    p.targetColor = { ...newColor };
                });
            };
            
            img.src = imageUrl;
        }

        function startGradientAnimation() {
            if (animationId) cancelAnimationFrame(animationId);
            resizeCanvas();
            initGradientPoints(); 
            animate(0);
            if (debugConsole) debugConsole.log('æ¸å˜èƒŒæ™¯', 'åŠ¨æ€åŠ¨æ•ˆèƒŒæ™¯ç³»ç»Ÿå·²å¯åŠ¨', 'success');
        }

        // ========== éŸ³ä¹æ’­æ”¾å™¨é€»è¾‘ ==========
        const searchInput = document.getElementById('searchInput');
        const apiSelect = document.getElementById('apiSelect'); // æ–°å¢ï¼šAPIé€‰æ‹©å™¨
        const algoToggleBtn = document.getElementById('algoToggleBtn'); // æ–°å¢ï¼šé¢œè‰²ç®—æ³•åˆ‡æ¢æŒ‰é’®
        const sourceSelect = document.getElementById('sourceSelect');
        const searchBtn = document.getElementById('searchBtn');
        const albumArt = document.getElementById('albumArt');
        const albumArtPlaceholder = document.querySelector('.album-art-placeholder');
        const songTitle = document.getElementById('songTitle');
        const songArtist = document.getElementById('songArtist');
        const progressBar = document.getElementById('progressBar');
        const progress = document.getElementById('progress');
        const progressHandle = document.getElementById('progressHandle');
        const currentTime = document.getElementById('currentTime');
        const duration = document.getElementById('duration');
        const playBtn = document.getElementById('playBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const qualitySelect = document.getElementById('qualitySelect');
        const lyricsContainer = document.getElementById('lyricsContainer');
        const lyricsContent = document.getElementById('lyricsContent');
        const resultsContainer = document.getElementById('resultsContainer');
        const audioPlayer = document.getElementById('audioPlayer');

        const fullscreenLyricsBtn = document.getElementById('fullscreenLyricsBtn');
        const fullscreenLyricsOverlay = document.getElementById('fullscreenLyricsOverlay');
        const closeFullscreenBtn = document.getElementById('closeFullscreenBtn');
        const fullscreenAlbumArt = document.getElementById('fullscreenAlbumArt');
        const fullscreenSongTitle = document.getElementById('fullscreenSongTitle');
        const fullscreenSongArtist = document.getElementById('fullscreenSongArtist');
        const fullscreenLyricsLines = document.getElementById('fullscreenLyricsLines');
        const fullscreenProgressBar = document.getElementById('fullscreenProgressBar');
        const fullscreenProgress = document.getElementById('fullscreenProgress');
        const fullscreenPlayBtn = document.getElementById('fullscreenPlayBtn');
        const fullscreenPrevBtn = document.getElementById('fullscreenPrevBtn');
        const fullscreenNextBtn = document.getElementById('fullscreenNextBtn');
        
        const speedSlider = document.getElementById('speedSlider');

        let currentTrack = null;
        let searchResults = [];
        let requestTimestamps = [];
        let mergedLyricsData = null;
        let isDragging = false;
        let userScrolledLyrics = false;
        let currentAlbumUrl = null;
        
        // APIé…ç½® - ä¸¤å¥—ç‹¬ç«‹ç³»ç»Ÿ
        const API_CONFIG = {
            gdstudio: {
                name: 'åŸAPI (GDStudio)',
                baseUrl: 'https://music-api.gdstudio.xyz/api.php',
                // åŸAPIéŸ³è´¨é€‰é¡¹
                qualities: [
                    { value: '128', label: 'æ ‡å‡†å“è´¨ (128k)' },
                    { value: '192', label: 'è‰¯å¥½å“è´¨ (192k)' },
                    { value: '320', label: 'é«˜å“è´¨ (320k)' },
                    { value: '740', label: 'æ— æŸå“è´¨ (740k)' },
                    { value: '999', label: 'é«˜è§£æåº¦ (999k)' }
                ]
            },
            tunehub: {
                name: 'å¤‡ç”¨API (TuneHub)',
                // TuneHub API åŸºç¡€è·¯å¾„ï¼Œä½¿ç”¨ music-dl.sayqz.com æä¾›çš„æ¥å£
                baseUrl: 'https://music-dl.sayqz.com/api/',
                // TuneHub APIéŸ³è´¨é€‰é¡¹ - ä¸éŸ³ä¹ä¸‹è½½.htmlå®Œå…¨ä¸€è‡´
                qualities: [
                    { value: '128k', label: 'æ ‡å‡†å“è´¨ (128k)' },
                    { value: '320k', label: 'é«˜å“è´¨ (320k)' },
                    { value: 'flac', label: 'æ— æŸå“è´¨ (FLAC)' },
                    { value: 'flac24bit', label: 'é«˜è§£æåº¦ (24bit FLAC)' }
                ]
            }
        };

        // æ›´æ–°éŸ³ä¹æºé€‰æ‹©é€‰é¡¹
        function updateSourceOptions() {
            const api = apiSelect.value;
            const sourceOptions = sourceSelect.options;
            
            // é‡ç½®æ‰€æœ‰é€‰é¡¹
            for (let i = 0; i < sourceOptions.length; i++) {
                sourceOptions[i].disabled = false;
                sourceOptions[i].style.display = '';
            }
            
            if (api === 'tunehub') {
                // TuneHub APIæ”¯æŒçš„å¹³å°
                if (debugConsole) debugConsole.info('APIåˆ‡æ¢', 'åˆ‡æ¢åˆ°TuneHub APIï¼Œæ›´æ–°å¹³å°é€‰é¡¹');
                
                // å¯ç”¨TuneHubæ”¯æŒçš„é€‰é¡¹ï¼Œç¦ç”¨ä¸æ”¯æŒçš„
                for (let i = 0; i < sourceOptions.length; i++) {
                    const option = sourceOptions[i];
                    const value = option.value;
                    
                    // TuneHubæ”¯æŒçš„å¹³å°ï¼šnetease, kuwo, qq, aggregate
                    if (value === 'netease' || value === 'kuwo' || value === 'qq' || value === 'aggregate') {
                        option.disabled = false;
                        option.style.display = '';
                    } else {
                        option.disabled = true;
                        option.style.display = 'none';
                    }
                }
                
                // è®¾ç½®é»˜è®¤å€¼
                if (!['netease', 'kuwo', 'qq', 'aggregate'].includes(sourceSelect.value)) {
                    sourceSelect.value = 'netease';
                }
            } else {
                // åŸAPIæ”¯æŒçš„å¹³å°
                if (debugConsole) debugConsole.info('APIåˆ‡æ¢', 'åˆ‡æ¢åˆ°åŸAPIï¼Œæ¢å¤å¹³å°é€‰é¡¹');
                
                // æ¢å¤æ‰€æœ‰é€‰é¡¹
                for (let i = 0; i < sourceOptions.length; i++) {
                    const option = sourceOptions[i];
                    const value = option.value;
                    
                    // åŸAPIæ”¯æŒçš„å¹³å°ï¼škuwo, joox, netease
                    if (value === 'kuwo' || value === 'joox' || value === 'netease') {
                        option.disabled = false;
                        option.style.display = '';
                    } else {
                        option.disabled = true;
                        option.style.display = 'none';
                    }
                }
                
                // è®¾ç½®é»˜è®¤å€¼
                if (!['kuwo', 'joox', 'netease'].includes(sourceSelect.value)) {
                    sourceSelect.value = 'kuwo';
                }
            }
        }

        // æ›´æ–°éŸ³è´¨é€‰é¡¹
        function updateQualityOptions() {
            const api = apiSelect.value;
            const apiConfig = API_CONFIG[api];
            const qualitySelect = document.getElementById('qualitySelect');
            
            // æ¸…ç©ºç°æœ‰é€‰é¡¹
            qualitySelect.innerHTML = '';
            
            // æ·»åŠ æ–°é€‰é¡¹
            apiConfig.qualities.forEach(quality => {
                const option = document.createElement('option');
                option.value = quality.value;
                option.textContent = quality.label;
                qualitySelect.appendChild(option);
            });
            
            if (debugConsole) debugConsole.info('éŸ³è´¨é€‰é¡¹', `å·²æ›´æ–°ä¸º ${apiConfig.name} çš„éŸ³è´¨é€‰é¡¹`);
        }

        // APIé€‰æ‹©å™¨äº‹ä»¶
        apiSelect.addEventListener('change', () => {
            if (debugConsole) debugConsole.info('APIåˆ‡æ¢', `åˆ‡æ¢åˆ°: ${apiSelect.value} - ${API_CONFIG[apiSelect.value].name}`);
            updateSourceOptions();
            updateQualityOptions();
        });

        // åˆå§‹åŒ–æ—¶æ›´æ–°é€‰é¡¹
        updateSourceOptions();
        updateQualityOptions();


// ========== é¢œè‰²æå–ç®—æ³•åˆ‡æ¢ï¼ˆåŸï¼šä¸­ä½åˆ‡åˆ† / æ–°ï¼šK-meansï¼‰ ==========
let COLOR_EXTRACTION_ALGO = localStorage.getItem('colorExtractionAlgo') || 'medianCut'; // 'medianCut' | 'kmeans'

// èƒŒæ™¯æ¨¡å¼ï¼š'extract' ä½¿ç”¨ä¸“è¾‘å°é¢å–è‰²ç”Ÿæˆæ¸å˜ï¼›'gradient' ä½¿ç”¨å†…ç½®åŠ¨æ€åŠ¨æ•ˆï¼ˆæ¶¡æ—‹ï¼‰èƒŒæ™¯
let currentBackgroundMode = localStorage.getItem('backgroundMode') || 'extract';

const backgroundToggleBtn = document.getElementById('backgroundToggleBtn');

// æ›´æ–°èƒŒæ™¯åˆ‡æ¢æŒ‰é’®æ–‡æœ¬
function updateBackgroundToggleLabel() {
    if (!backgroundToggleBtn) return;
    backgroundToggleBtn.textContent = currentBackgroundMode === 'extract' ? 'èƒŒæ™¯ï¼šå°é¢å–è‰²' : 'èƒŒæ™¯ï¼šåŠ¨æ€åŠ¨æ•ˆ';
}

// æ ¹æ®å½“å‰æ¨¡å¼åº”ç”¨èƒŒæ™¯æ ·å¼
function applyBackgroundMode() {
    const gradientCanvasEl = document.getElementById('gradientCanvas');
    if (currentBackgroundMode === 'gradient') {
        // å½“é€‰æ‹©åŠ¨æ€åŠ¨æ•ˆæ¨¡å¼æ—¶ï¼Œéšè—é¢œè‰²å–è‰²çš„æ¸å˜ç”»å¸ƒå¹¶å¯åŠ¨ Pixi èƒŒæ™¯
        if (gradientCanvasEl) gradientCanvasEl.style.display = 'none';
        // å±•ç¤º Pixi èƒŒæ™¯ç”»å¸ƒ
        const pixiCanvas = document.getElementById('pixiBackgroundCanvas');
        if (pixiCanvas) pixiCanvas.style.display = 'block';
        // ä½¿ç”¨å½“å‰ä¸“è¾‘å°é¢æˆ–é»˜è®¤å›¾ç‰‡å¯åŠ¨åŠ¨æ€åŠ¨æ•ˆèƒŒæ™¯
        const bgUrl = (typeof currentAlbumUrl !== 'undefined' && currentAlbumUrl) ? currentAlbumUrl : albumArt.src || fullscreenAlbumArt.src || '';
        if (typeof initPixiBackground !== 'undefined') {
            initPixiBackground(bgUrl);
        }
    } else {
        // å½“é€‰æ‹©å°é¢å–è‰²æ¨¡å¼æ—¶ï¼Œåœæ­¢ Pixi èƒŒæ™¯å¹¶æ˜¾ç¤ºé¢œè‰²å–è‰²çš„ç”»å¸ƒ
        const pixiCanvas = document.getElementById('pixiBackgroundCanvas');
        if (pixiCanvas) pixiCanvas.style.display = 'none';
        if (typeof destroyPixiBackground !== 'undefined') {
            destroyPixiBackground();
        }
        if (gradientCanvasEl) gradientCanvasEl.style.display = 'block';
    }
    updateBackgroundToggleLabel();
}

if (backgroundToggleBtn) {
    // é¦–æ¬¡åº”ç”¨èƒŒæ™¯æ ·å¼
    applyBackgroundMode();
    // ç›‘å¬ç‚¹å‡»åˆ‡æ¢èƒŒæ™¯æ¨¡å¼
    backgroundToggleBtn.addEventListener('click', () => {
        currentBackgroundMode = currentBackgroundMode === 'extract' ? 'gradient' : 'extract';
        localStorage.setItem('backgroundMode', currentBackgroundMode);
        applyBackgroundMode();
        // è‹¥åˆ‡å›å°é¢å–è‰²æ¨¡å¼ï¼Œä½¿ç”¨å½“å‰å°é¢é‡æ–°æ›´æ–°æ¸å˜é¢œè‰²
        if (currentBackgroundMode === 'extract' && typeof currentAlbumUrl !== 'undefined' && currentAlbumUrl) {
            updateGradientFromAlbum(currentAlbumUrl);
        }
    });
}

function updateAlgoToggleButton() {
    if (!algoToggleBtn) return;
    algoToggleBtn.textContent = COLOR_EXTRACTION_ALGO === 'kmeans' ? 'ç®—æ³•ï¼šK-means' : 'ç®—æ³•ï¼šåŸ(ä¸­ä½åˆ‡åˆ†)';
}

if (algoToggleBtn) {
    updateAlgoToggleButton();
    algoToggleBtn.addEventListener('click', () => {
        COLOR_EXTRACTION_ALGO = (COLOR_EXTRACTION_ALGO === 'kmeans') ? 'medianCut' : 'kmeans';
        localStorage.setItem('colorExtractionAlgo', COLOR_EXTRACTION_ALGO);
        updateAlgoToggleButton();
        if (debugConsole) debugConsole.info('é¢œè‰²æå–', `å·²åˆ‡æ¢é¢œè‰²æå–ç®—æ³•ä¸º: ${COLOR_EXTRACTION_ALGO === 'kmeans' ? 'K-means' : 'åŸ(ä¸­ä½åˆ‡åˆ†)'}`);

        // å¦‚æœå½“å‰å·²æœ‰ä¸“è¾‘å°é¢ï¼Œå¹¶ä¸”èƒŒæ™¯æ¨¡å¼ä¸ºå°é¢å–è‰²ï¼Œç«‹å³æŒ‰æ–°ç®—æ³•åˆ·æ–°èƒŒæ™¯
        if (currentAlbumUrl && currentBackgroundMode === 'extract') {
            updateGradientFromAlbum(currentAlbumUrl);
        }
    });
}


        function checkRateLimit() {
            const now = Date.now();
            const fiveMinutesAgo = now - 5 * 60 * 1000;
            requestTimestamps = requestTimestamps.filter(timestamp => timestamp > fiveMinutesAgo);
            
            if (requestTimestamps.length >= 60) {
                const message = 'APIè¯·æ±‚é¢‘ç‡è¿‡é«˜ï¼Œå·²è¶…è¿‡é™åˆ¶ï¼ˆ5åˆ†é’Ÿå†…æœ€å¤š60æ¬¡è¯·æ±‚ï¼‰ã€‚è¯·ç­‰å¾…5åˆ†é’Ÿåå†è¯•ã€‚å½“å‰è¯·æ±‚æ¬¡æ•°ï¼š' + requestTimestamps.length;
                if (debugConsole) debugConsole.error('APIé™åˆ¶', message);
                return false;
            }
            
            requestTimestamps.push(now);
            if (debugConsole) debugConsole.info('APIè¯·æ±‚', `å½“å‰5åˆ†é’Ÿå†…APIè¯·æ±‚æ¬¡æ•°: ${requestTimestamps.length}/60`);
            return true;
        }

        // TuneHub APIè¯·æ±‚å‡½æ•° - å®Œå…¨æŒ‰ç…§éŸ³ä¹ä¸‹è½½.htmlçš„æ–¹å¼
        async function tunehubRequest(params) {
            try {
                const apiConfig = API_CONFIG.tunehub;
                const url = new URL(apiConfig.baseUrl);
                
                // ç›´æ¥ä½¿ç”¨å‚æ•°ï¼Œä¸è¿›è¡Œæ˜ å°„
                Object.keys(params).forEach(k => {
                    if (params[k] !== undefined && params[k] !== null) {
                        url.searchParams.append(k, params[k]);
                    }
                });
                
                const urlString = url.toString();
                if (debugConsole) debugConsole.api('TuneHub APIè¯·æ±‚', `å‘é€è¯·æ±‚: ${urlString}`);
                
                const response = await fetch(urlString);
                
                if (!response.ok) {
                    const errorMsg = `HTTPè¯·æ±‚å¤±è´¥: çŠ¶æ€ç  ${response.status} ${response.statusText}`;
                    if (debugConsole) debugConsole.error('TuneHub APIè¯·æ±‚', errorMsg);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // éŸ³é¢‘URLè¯·æ±‚è¿”å›æ–‡æœ¬
                if (params.type === 'url') {
                    const audioUrl = await response.text();
                    if (debugConsole) debugConsole.api('TuneHub APIè¯·æ±‚', `éŸ³é¢‘URLè·å–æˆåŠŸ: ${audioUrl.substring(0, 100)}...`);
                    return { url: audioUrl };
                }
                
                // å…¶ä»–è¯·æ±‚è¿”å›JSON
                const data = await response.json();
                if (debugConsole) debugConsole.api('TuneHub APIè¯·æ±‚', `è¯·æ±‚æˆåŠŸï¼Œè¿”å›æ•°æ®`);
                return data;
            } catch (error) {
                const errorMsg = `TuneHub APIè¯·æ±‚å¼‚å¸¸: ${error.message}\né”™è¯¯å †æ ˆ: ${error.stack}`;
                if (debugConsole) debugConsole.error('TuneHub APIè¯·æ±‚', errorMsg);
                return null;
            }
        }

        // åŸAPIè¯·æ±‚å‡½æ•°
        async function gdstudioRequest(params) {
            try {
                const apiConfig = API_CONFIG.gdstudio;
                const queryString = new URLSearchParams(params).toString();
                const url = `${apiConfig.baseUrl}?${queryString}`;
                
                if (debugConsole) debugConsole.api('åŸAPIè¯·æ±‚', `å‘é€è¯·æ±‚: ${url}`);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    const errorMsg = `HTTPè¯·æ±‚å¤±è´¥: çŠ¶æ€ç  ${response.status} ${response.statusText}`;
                    if (debugConsole) debugConsole.error('åŸAPIè¯·æ±‚', errorMsg);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                let data;
                try {
                    // æ ¹æ®å“åº”çš„Content-Typeå†³å®šè§£ææ–¹å¼ã€‚éƒ¨åˆ†è¯·æ±‚ï¼ˆå¦‚types=urlï¼‰å¯èƒ½è¿”å›çº¯æ–‡æœ¬ï¼Œè€ŒéJSON
                    const contentType = response.headers.get('Content-Type') || '';
                    if (contentType.includes('application/json')) {
                        data = await response.json();
                    } else {
                        const text = await response.text();
                        // å¦‚æœè¯·æ±‚çš„æ˜¯éŸ³é¢‘URLï¼Œåˆ™ç›´æ¥åŒ…è£…æˆå¯¹è±¡
                        if (params.types === 'url') {
                            data = { url: text };
                        } else {
                            // å°è¯•è§£æä¸ºJSONï¼Œå¦åˆ™è¿”å›å­—ç¬¦ä¸²
                            try {
                                data = JSON.parse(text);
                            } catch {
                                data = text;
                            }
                        }
                    }
                } catch (parseErr) {
                    // å¦‚æœè§£æé”™è¯¯ï¼ŒæŠ›å‡ºå¼‚å¸¸ä»¥ä¾¿å¤–å±‚æ•è·
                    throw new Error('è§£æAPIå“åº”å¤±è´¥: ' + parseErr.message);
                }
                if (debugConsole) debugConsole.api('åŸAPIè¯·æ±‚', `è¯·æ±‚æˆåŠŸï¼Œè¿”å›æ•°æ®`);
                return data;
            } catch (error) {
                const errorMsg = `åŸAPIè¯·æ±‚å¼‚å¸¸: ${error.message}\né”™è¯¯å †æ ˆ: ${error.stack}`;
                if (debugConsole) debugConsole.error('åŸAPIè¯·æ±‚', errorMsg);
                return null;
            }
        }

        // ç»Ÿä¸€APIè¯·æ±‚å‡½æ•°
        async function apiRequest(params, apiType = null) {
            const api = apiType || apiSelect.value;
            
            if (!checkRateLimit()) {
                const errorMsg = 'APIè¯·æ±‚é¢‘ç‡é™åˆ¶ï¼š5åˆ†é’Ÿå†…æœ€å¤š60æ¬¡è¯·æ±‚ï¼Œå½“å‰å·²è¶…é™ã€‚';
                if (debugConsole) debugConsole.error('APIé™åˆ¶', errorMsg);
                return null;
            }
            
            if (api === 'gdstudio') {
                return await gdstudioRequest(params);
            } else if (api === 'tunehub') {
                // å°†åŸAPIå‚æ•°è½¬æ¢ä¸ºTuneHubå‚æ•°
                let tunehubParams = {};
                
                if (params.types === 'search') {
                    // å¤„ç†èšåˆæœç´¢
                    if (params.source === 'aggregate') {
                        tunehubParams = {
                            type: 'aggregateSearch',
                            keyword: params.name,
                            limit: params.count || 20
                        };
                    } else {
                        tunehubParams = {
                            source: params.source,
                            type: 'search',
                            keyword: params.name,
                            limit: params.count || 20,
                            page: params.pages || 1
                        };
                    }
                } else if (params.types === 'url') {
                    // ç›´æ¥ä½¿ç”¨éŸ³ä¹ä¸‹è½½.htmlä¸­çš„æ–¹å¼
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'url',
                        br: params.br // ç›´æ¥ä½¿ç”¨éŸ³è´¨å€¼ï¼Œä¸æ˜ å°„
                    };
                } else if (params.types === 'pic') {
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'pic'
                    };
                } else if (params.types === 'lyric') {
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'lrc'
                    };
                }
                
                return await tunehubRequest(tunehubParams);
            }
        }

        async function searchMusic(keyword, source = null) {
            if (!keyword.trim()) {
                const errorMsg = 'æœç´¢å¤±è´¥: æœç´¢å…³é”®è¯ä¸ºç©ºï¼Œè¯·è¾“å…¥æœ‰æ•ˆçš„æ­Œæ›²åã€æ­Œæ‰‹åæˆ–ä¸“è¾‘åè¿›è¡Œæœç´¢ã€‚';
                if (debugConsole) debugConsole.error('æœç´¢', errorMsg);
                
                const d = document.createElement('div');
                d.className = 'error';
                d.textContent = 'è¯·è¾“å…¥æœç´¢å…³é”®è¯';
                resultsContainer.prepend(d);
                setTimeout(() => d.remove(), 4000);
                return;
            }
            
            const api = apiSelect.value;
            const selectedSource = source || sourceSelect.value;
            
            if (debugConsole) debugConsole.info('æœç´¢', `å¼€å§‹æœç´¢: "${keyword}" (API: ${api}, æº: ${selectedSource})`);
            resultsContainer.innerHTML = '<div class="loading">æœç´¢ä¸­...</div>';
            
            let data;
            if (api === 'gdstudio') {
                // åŸAPIæœç´¢
                data = await apiRequest({
                    types: 'search',
                    source: selectedSource,
                    name: keyword,
                    count: 20,
                    pages: 1
                });
            } else if (api === 'tunehub') {
                // TuneHub APIæœç´¢
                data = await apiRequest({
                    types: 'search',
                    source: selectedSource,
                    name: keyword,
                    count: 20,
                    pages: 1
                });
            }
            
            if (data) {
                if (api === 'gdstudio' && Array.isArray(data) && data.length > 0) {
                    // åŸAPIæœç´¢ç»“æœ - æ·»åŠ å¹³å°ä¿¡æ¯
                    searchResults = data.map(track => ({
                        ...track,
                        platform: selectedSource,
                        api: 'gdstudio'
                    }));
                    if (debugConsole) debugConsole.success('æœç´¢', `æœç´¢æˆåŠŸï¼Œæ‰¾åˆ° ${data.length} ä¸ªç»“æœ`);
                    displaySearchResults(searchResults, api);
                } else if (api === 'tunehub' && data.code === 200 && data.data) {
                    // TuneHubè¿”å›çš„æ•°æ®æ ¼å¼
                    let tracks = [];
                    
                    if (selectedSource === 'aggregate') {
                        // èšåˆæœç´¢è¿”å›çš„æ•°æ®æ ¼å¼
                        if (data.data.results && Array.isArray(data.data.results)) {
                            tracks = data.data.results.map(item => ({
                                id: item.id,
                                name: item.name,
                                artist: item.artist || 'æœªçŸ¥è‰ºæœ¯å®¶',
                                album: item.album || 'æœªçŸ¥ä¸“è¾‘',
                                pic_id: item.id,
                                pic_url: item.pic,
                                lyric_id: item.id,
                                source: item.platform,
                                platform: item.platform,
                                api: 'tunehub'
                            }));
                        }
                    } else {
                        // æ™®é€šæœç´¢è¿”å›çš„æ•°æ®æ ¼å¼
                        if (data.data.results && Array.isArray(data.data.results)) {
                            tracks = data.data.results.map(item => ({
                                id: item.id,
                                name: item.name,
                                artist: item.artist || 'æœªçŸ¥è‰ºæœ¯å®¶',
                                album: item.album || 'æœªçŸ¥ä¸“è¾‘',
                                pic_id: item.id,
                                pic_url: item.pic,
                                lyric_id: item.id,
                                source: selectedSource,
                                platform: selectedSource,
                                api: 'tunehub'
                            }));
                        }
                    }
                    
                    if (tracks.length > 0) {
                        searchResults = tracks;
                        if (debugConsole) debugConsole.success('æœç´¢', `æœç´¢æˆåŠŸï¼Œæ‰¾åˆ° ${tracks.length} ä¸ªç»“æœ`);
                        displaySearchResults(tracks, api);
                    } else {
                        if (debugConsole) debugConsole.warn('æœç´¢', `æœªæ‰¾åˆ°ç›¸å…³ç»“æœï¼Œå…³é”®è¯: "${keyword}"ï¼ŒAPI: ${api}ï¼Œæº: ${selectedSource}`);
                        resultsContainer.innerHTML = '<div class="loading">æœªæ‰¾åˆ°ç»“æœ</div>';
                    }
                } else {
                    if (debugConsole) debugConsole.warn('æœç´¢', `æœªæ‰¾åˆ°ç›¸å…³ç»“æœï¼Œå…³é”®è¯: "${keyword}"ï¼ŒAPI: ${api}ï¼Œæº: ${selectedSource}`);
                    resultsContainer.innerHTML = '<div class="loading">æœªæ‰¾åˆ°ç»“æœ</div>';
                }
            } else {
                if (debugConsole) debugConsole.warn('æœç´¢', `APIè¿”å›ç©ºæ•°æ®ï¼Œå…³é”®è¯: "${keyword}"ï¼ŒAPI: ${api}ï¼Œæº: ${selectedSource}`);
                resultsContainer.innerHTML = '<div class="loading">æœªæ‰¾åˆ°ç»“æœ</div>';
            }
        }

        // ---------- æœç´¢ç»“æœæ˜¾ç¤º ----------
        function displaySearchResults(results, api) {
            resultsContainer.innerHTML = '';
            
            if (results.length === 0) {
                resultsContainer.innerHTML = '<div class="loading">æœªæ‰¾åˆ°ç»“æœ</div>';
                return;
            }
            
            results.forEach((track) => {
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                if (currentTrack && currentTrack.id === track.id && currentTrack.api === track.api) {
                    resultItem.classList.add('active');
                }
                
                // æ ¹æ®APIæ„å»ºä¸“è¾‘å°é¢URL
                let albumArtUrl;
                if (api === 'gdstudio') {
                    albumArtUrl = track.pic_id ? 
                        `https://music-api.gdstudio.xyz/api.php?types=pic&source=${track.source}&id=${track.pic_id}&size=150` : 
                        'https://placehold.co/50x50/333333/ffffff?text=â™ª';
                } else if (api === 'tunehub') {
                    // TuneHub: ä¼˜å…ˆä½¿ç”¨ pic_urlï¼Œå¦‚æœæ²¡æœ‰åˆ™æ ¹æ® pic_id æ„å»º
                    if (track.pic_url) {
                        albumArtUrl = track.pic_url;
                    } else if (track.pic_id) {
                        // ä½¿ç”¨ music-dl.sayqz.com API æ„å»ºå°é¢åœ°å€
                        albumArtUrl = `https://music-dl.sayqz.com/api/?type=pic&source=${track.source}&id=${track.pic_id}`;
                    } else {
                        albumArtUrl = 'https://placehold.co/50x50/333333/ffffff?text=â™ª';
                    }
                }

                // è·å–å¹³å°æ˜¾ç¤ºåç§°
                let platformName = '';
                let platformClass = '';
                if (track.platform) {
                    platformName = track.platform.toUpperCase();
                    platformClass = track.platform;
                }

                resultItem.innerHTML = `
                    <img src="${albumArtUrl}" class="result-album" onerror="this.src='https://placehold.co/50x50/333333/ffffff?text=â™ª'">
                    <div class="result-info">
                        <div class="result-title">${track.name || 'æœªçŸ¥æ­Œæ›²'}</div>
                        <div class="result-artist">${track.artist || 'æœªçŸ¥è‰ºæœ¯å®¶'}</div>
                        <div class="result-album-name">${track.album || 'æœªçŸ¥ä¸“è¾‘'}</div>
                        <div class="result-platform-info">
                            <span class="platform-badge ${platformClass}">${platformName}</span>
                            <span class="api-select-label">${track.api === 'tunehub' ? 'å¤‡ç”¨API' : 'åŸAPI'}</span>
                        </div>
                    </div>
                `;
                
                resultItem.__trackData = track;
                resultItem.addEventListener('click', () => {
                    if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', `ç‚¹å‡»æ’­æ”¾æ­Œæ›²: ${track.name} - ${track.artist} (API: ${track.api || api}, å¹³å°: ${track.platform})`);
                    playTrack(track);
                    document.querySelectorAll('.result-item').forEach(item => item.classList.remove('active'));
                    resultItem.classList.add('active');
                });
                
                resultsContainer.appendChild(resultItem);
            });
            
            if (debugConsole) debugConsole.success('æœç´¢ç»“æœ', `æˆåŠŸæ¸²æŸ“ ${results.length} ä¸ªæœç´¢ç»“æœ`);
        }

        async function playTrack(track) {
            try {
                currentTrack = track;
                
                if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', `å¼€å§‹æ’­æ”¾æ­Œæ›²: ${track.name} - ${track.artist} (ID: ${track.id}, API: ${track.api || apiSelect.value}, å¹³å°: ${track.platform})`);
                
                songTitle.textContent = track.name || 'æœªçŸ¥æ­Œæ›²';
                songArtist.textContent = `${track.artist || 'æœªçŸ¥è‰ºæœ¯å®¶'}`;
                fullscreenSongTitle.textContent = track.name || 'æœªçŸ¥æ­Œæ›²';
                fullscreenSongArtist.textContent = track.artist || 'æœªçŸ¥è‰ºæœ¯å®¶';
                
                albumArt.style.display = 'none';
                albumArtPlaceholder.style.display = 'flex';
                
                // æ›´æ–° active çŠ¶æ€
                document.querySelectorAll('.result-item').forEach(item => {
                    if(item.__trackData && item.__trackData.id === track.id && item.__trackData.api === track.api) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
                
                lyricsContent.innerHTML = '<div class="loading">åŠ è½½ä¸­...</div>';
                fullscreenLyricsLines.innerHTML = '<div class="loading">åŠ è½½ä¸­...</div>';
                userScrolledLyrics = false;
                
                // æ ¹æ®trackçš„APIè·å–éŸ³é¢‘URL
                const quality = qualitySelect.value;
                const apiToUse = track.api || apiSelect.value;
                
                if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', `è¯·æ±‚éŸ³é¢‘URLï¼ŒéŸ³è´¨: ${quality}, API: ${apiToUse}, å¹³å°: ${track.platform}`);
                
                let urlData;
                // ç»Ÿä¸€ä½¿ç”¨ apiRequest è·å–éŸ³é¢‘é“¾æ¥ã€‚æ ¹æ®å½“å‰track.apiæˆ–é€‰ä¸­çš„APIç¡®å®šè°ƒç”¨æ¥æºã€‚
                // å¯¹äº TuneHubï¼Œè¿™ä¼šé€šè¿‡ tunehubRequest æ‹‰å–çœŸå®éŸ³é¢‘é“¾æ¥ï¼ˆæˆ–ç›´æ¥è¿”å›éŸ³é¢‘åœ°å€ï¼‰ï¼›
                // å¯¹äº GDStudioï¼Œåˆ™é€šè¿‡ gdstudioRequest è·å–é“¾æ¥ã€‚
                urlData = await apiRequest({
                    types: 'url',
                    source: track.platform || track.source || sourceSelect.value,
                    id: track.id,
                    br: quality
                }, apiToUse);
                
                if (urlData && urlData.url) {
                    if (debugConsole) debugConsole.success('æ’­æ”¾æ§åˆ¶', `æˆåŠŸè·å–éŸ³é¢‘URL: ${urlData.url.substring(0, 100)}...`);
                    
                    audioPlayer.src = urlData.url;
                    audioPlayer.play()
                        .then(() => {
                            playBtn.innerHTML = 'â¸';
                            fullscreenPlayBtn.innerHTML = 'â¸';
                            updateMediaSession(track);
                            if (debugConsole) debugConsole.success('æ’­æ”¾æ§åˆ¶', 'éŸ³é¢‘æ’­æ”¾å¼€å§‹');
                        })
                        .catch(e => {
                            const errorMsg = `éŸ³é¢‘æ’­æ”¾å¤±è´¥: ${e.message}\né”™è¯¯åç§°: ${e.name}\né”™è¯¯å †æ ˆ: ${e.stack}`;
                            if (debugConsole) debugConsole.error('æ’­æ”¾æ§åˆ¶', errorMsg);
                        });
                    
                    // åŠ è½½ä¸“è¾‘å°é¢
                    if (track.pic_url) {
                        // ç›´æ¥ä½¿ç”¨æœç´¢æ—¶å¾—åˆ°çš„å›¾ç‰‡URL
                        if (debugConsole) debugConsole.info('ä¸“è¾‘å°é¢', `ä½¿ç”¨æœç´¢ç»“æœä¸­çš„ä¸“è¾‘å°é¢URL: ${track.pic_url}`);
                        currentAlbumUrl = track.pic_url;
                        albumArt.src = track.pic_url;
                        albumArt.style.display = 'block';
                        albumArtPlaceholder.style.display = 'none';
                        fullscreenAlbumArt.src = track.pic_url;
                        
                        // æ ¹æ®èƒŒæ™¯æ¨¡å¼æ›´æ–°èƒŒæ™¯ï¼šå°é¢å–è‰²æ¨¡å¼ä¸‹æ›´æ–°æ¸å˜ï¼›åŠ¨æ€åŠ¨æ•ˆæ¨¡å¼ä¸‹åˆ·æ–° Pixi èƒŒæ™¯
                        if (currentBackgroundMode === 'extract') {
                            updateGradientFromAlbum(track.pic_url);
                        } else {
                            if (typeof initPixiBackground !== 'undefined') {
                                initPixiBackground(track.pic_url);
                            }
                        }
                    } else if (track.pic_id) {
                        if (debugConsole) debugConsole.info('ä¸“è¾‘å°é¢', `å¼€å§‹åŠ è½½ä¸“è¾‘å°é¢ï¼Œå›¾ç‰‡ID: ${track.pic_id}, API: ${apiToUse}`);
                        loadAlbumCover(track, apiToUse);
                    }
                    
                    // åŠ è½½æ­Œè¯
                    if (track.lyric_id || track.id) {
                        const lyricId = track.lyric_id || track.id;
                        if (debugConsole) debugConsole.info('æ­Œè¯', `å¼€å§‹åŠ è½½æ­Œè¯ï¼Œæ­Œè¯ID: ${lyricId}, API: ${apiToUse}`);
                        loadLyrics(track, apiToUse);
                    }
                } else {
                    const errorMsg = `æ— æ³•æ’­æ”¾æ­¤æ­Œæ›²ï¼Œå¯èƒ½æ²¡æœ‰å¯¹åº”çš„éŸ³è´¨æˆ–é“¾æ¥å¤±æ•ˆã€‚\næ­Œæ›²ID: ${track.id}\néŸ³è´¨: ${quality}\nAPI: ${apiToUse}\nå¹³å°: ${track.platform}`;
                    if (debugConsole) debugConsole.error('æ’­æ”¾æ§åˆ¶', errorMsg);
                }
            } catch (error) {
                const errorMsg = `æ’­æ”¾æ­Œæ›²è¿‡ç¨‹ä¸­å‡ºç°å¼‚å¸¸: ${error.message}\né”™è¯¯å †æ ˆ: ${error.stack}`;
                if (debugConsole) debugConsole.error('æ’­æ”¾æ§åˆ¶', errorMsg);
            }
        }

        // ---------- æµè§ˆå™¨/iOSé”å±ä¸“è¾‘å°é¢éƒ¨åˆ† ----------
        function updateMediaSession(track) {
            if ('mediaSession' in navigator) {
                try {
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: track.name || 'æœªçŸ¥æ­Œæ›²',
                        artist: track.artist || 'æœªçŸ¥è‰ºæœ¯å®¶',
                        album: track.album || 'æœªçŸ¥ä¸“è¾‘',
                        artwork: currentAlbumUrl ? [
                            { src: currentAlbumUrl, sizes: '256x256', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '384x384', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '512x512', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '768x768', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '1024x1024', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '1536x1536', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '2048x2048', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '3000x3000', type: 'image/jpeg' }
                        ] : []
                    });
                    
                    navigator.mediaSession.setActionHandler('play', () => {
                        audioPlayer.play();
                        playBtn.innerHTML = 'â¸';
                        fullscreenPlayBtn.innerHTML = 'â¸';
                    });
                    
                    navigator.mediaSession.setActionHandler('pause', () => {
                        audioPlayer.pause();
                        playBtn.innerHTML = 'â–¶';
                        fullscreenPlayBtn.innerHTML = 'â–¶';
                    });
                    
                    navigator.mediaSession.setActionHandler('previoustrack', () => {
                        prevBtn.click();
                    });
                    
                    navigator.mediaSession.setActionHandler('nexttrack', () => {
                        nextBtn.click();
                    });
                    
                    if (debugConsole) debugConsole.success('åª’ä½“ä¼šè¯', 'æµè§ˆå™¨/iOSé”å±åª’ä½“ä¼šè¯å·²æ›´æ–°');
                } catch (error) {
                    if (debugConsole) debugConsole.error('åª’ä½“ä¼šè¯', `æ›´æ–°åª’ä½“ä¼šè¯å¤±è´¥: ${error.message}`);
                }
            }
        }

        async function loadAlbumCover(track, api) {
            if (!track.pic_id) {
                if (debugConsole) debugConsole.warn('ä¸“è¾‘å°é¢', 'æ— ä¸“è¾‘å°é¢IDï¼Œè·³è¿‡å°é¢åŠ è½½');
                return;
            }
            
            if (debugConsole) debugConsole.info('ä¸“è¾‘å°é¢', `è¯·æ±‚ä¸“è¾‘å°é¢ï¼Œå›¾ç‰‡ID: ${track.pic_id}, API: ${api}`);
            
            let picData;
            if (api === 'tunehub') {
                // TuneHub API - ç›´æ¥æ„å»ºURL
                const apiConfig = API_CONFIG.tunehub;
                const url = new URL(apiConfig.baseUrl);
                url.searchParams.append('source', track.platform || track.source || sourceSelect.value);
                url.searchParams.append('id', track.pic_id);
                url.searchParams.append('type', 'pic');
                
                picData = { url: url.toString() };
            } else {
                // åŸAPI
                let sizeParam = '3000';
                if (track.platform === 'joox' || track.source === 'joox') {
                    sizeParam = '';
                    if (debugConsole) debugConsole.info('ä¸“è¾‘å°é¢', 'JOOXéŸ³ä¹æºï¼Œä½¿ç”¨åŸå§‹å°ºå¯¸');
                }
                
                picData = await apiRequest({
                    types: 'pic',
                    source: track.platform || track.source || sourceSelect.value,
                    id: track.pic_id,
                    size: sizeParam
                });
            }
            
            if (picData && picData.url) {
                currentAlbumUrl = picData.url;
                if (debugConsole) debugConsole.success('ä¸“è¾‘å°é¢', `æˆåŠŸåŠ è½½ä¸“è¾‘å°é¢: ${picData.url}`);
                
                albumArt.src = picData.url;
                albumArt.style.display = 'block';
                albumArtPlaceholder.style.display = 'none';
                fullscreenAlbumArt.src = picData.url;
                
                // æ ¹æ®èƒŒæ™¯æ¨¡å¼æ›´æ–°èƒŒæ™¯
                if (currentBackgroundMode === 'extract') {
                    updateGradientFromAlbum(picData.url);
                } else {
                    if (typeof initPixiBackground !== 'undefined') {
                        initPixiBackground(picData.url);
                    }
                }
                
                // æ›´æ–°mediaSessionçš„artwork
                if ('mediaSession' in navigator && navigator.mediaSession.metadata) {
                    try {
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: navigator.mediaSession.metadata.title,
                            artist: navigator.mediaSession.metadata.artist,
                            album: navigator.mediaSession.metadata.album,
                            artwork: [
                                { src: picData.url, sizes: '256x256', type: 'image/jpeg' },
                                { src: picData.url, sizes: '384x384', type: 'image/jpeg' },
                                { src: picData.url, sizes: '512x512', type: 'image/jpeg' },
                                { src: picData.url, sizes: '768x768', type: 'image/jpeg' },
                                { src: picData.url, sizes: '1024x1024', type: 'image/jpeg' },
                                { src: picData.url, sizes: '1536x1536', type: 'image/jpeg' },
                                { src: picData.url, sizes: '2048x2048', type: 'image/jpeg' },
                                { src: picData.url, sizes: '3000x3000', type: 'image/jpeg' }
                            ]
                        });
                        if (debugConsole) debugConsole.info('åª’ä½“ä¼šè¯', 'ä¸“è¾‘å°é¢å·²æ›´æ–°åˆ°åª’ä½“ä¼šè¯');
                    } catch (error) {
                        if (debugConsole) debugConsole.error('åª’ä½“ä¼šè¯', `æ›´æ–°ä¸“è¾‘å°é¢åˆ°åª’ä½“ä¼šè¯å¤±è´¥: ${error.message}`);
                    }
                }
                
                albumArt.onerror = () => {
                    const errorMsg = `ä¸“è¾‘å°é¢å›¾ç‰‡åŠ è½½å¤±è´¥: ${picData.url}`;
                    if (debugConsole) debugConsole.error('ä¸“è¾‘å°é¢', errorMsg);
                    albumArt.style.display = 'none';
                    albumArtPlaceholder.style.display = 'flex';
                };
            } else {
                if (debugConsole) debugConsole.error('ä¸“è¾‘å°é¢', `æ— æ³•è·å–ä¸“è¾‘å°é¢æ•°æ®ï¼Œå›¾ç‰‡ID: ${track.pic_id}`);
            }
        }

        // ---------- æ­Œè¯è§£æ ----------
        function parseLRC(lrcText) {
            const lines = [];
            if (!lrcText) return lines;
            
            const lrcLines = lrcText.split('\n');
            
            lrcLines.forEach(line => {
                const timeMatch = line.match(/\[(\d+):(\d+)\.(\d+)\]/);
                if (timeMatch) {
                    const min = parseInt(timeMatch[1]);
                    const sec = parseInt(timeMatch[2]);
                    const ms = parseInt(timeMatch[3]) * 10;
                    let text = line.replace(/\[.*?\]/g, '').trim();

                    let words = [];
                    const wordMatch = text.matchAll(/\(([^)]+?)<(\d+:\d+:\d+)>\)/g);
                    let hasWordTiming = false;

                    for (const match of wordMatch) {
                        const wordText = match[1];
                        const wordTimeStr = match[2].split(':');
                        const wordTime = parseInt(wordTimeStr[0])*60 + parseInt(wordTimeStr[1]) + parseInt(wordTimeStr[2])/1000;
                        words.push({ text: wordText, time: wordTime });
                        hasWordTiming = true;
                    }

                    if (hasWordTiming) {
                         text = words.map(w => w.text).join('');
                    }

                    if (text) {
                        lines.push({
                            time: min * 60 + sec + ms/1000,
                            text: text,
                            words: hasWordTiming ? words : null
                        });
                    }
                }
            });
            return lines;
        }

        async function loadLyrics(track, api) {
            try {
                const lyricId = track.lyric_id || track.id;
                
                if (debugConsole) debugConsole.info('æ­Œè¯', `å¼€å§‹è¯·æ±‚æ­Œè¯æ•°æ®ï¼Œæ­Œè¯ID: ${lyricId}, API: ${api}`);
                
                let lyricData;
                if (api === 'tunehub') {
                    // TuneHub API - ç›´æ¥æ„å»ºURL
                    const apiConfig = API_CONFIG.tunehub;
                    const url = new URL(apiConfig.baseUrl);
                    url.searchParams.append('source', track.platform || track.source || sourceSelect.value);
                    url.searchParams.append('id', lyricId);
                    url.searchParams.append('type', 'lrc');
                    
                    const response = await fetch(url.toString());
                    if (response.ok) {
                        const text = await response.text();
                        lyricData = { lyric: text };
                    }
                } else {
                    // åŸAPI
                    lyricData = await apiRequest({
                        types: 'lyric',
                        source: track.platform || track.source || sourceSelect.value,
                        id: lyricId
                    });
                }
                
                mergedLyricsData = null;
                
                if (!lyricData || (!lyricData.lyric && !lyricData.tlyric)) {
                    if (debugConsole) debugConsole.warn('æ­Œè¯', `æœªæ‰¾åˆ°æ­Œè¯æ•°æ®ï¼Œæ­Œè¯ID: ${lyricId}`);
                    const noLyric = '<div class="loading">æš‚æ— æ­Œè¯</div>';
                    lyricsContent.innerHTML = noLyric;
                    fullscreenLyricsLines.innerHTML = noLyric;
                    return;
                }
                
                if (debugConsole) debugConsole.info('æ­Œè¯', `æˆåŠŸè·å–æ­Œè¯æ•°æ®ï¼ŒåŸå§‹æ­Œè¯é•¿åº¦: ${lyricData.lyric ? lyricData.lyric.length : 0}ï¼Œç¿»è¯‘æ­Œè¯é•¿åº¦: ${lyricData.tlyric ? lyricData.tlyric.length : 0}`);
                
                const originalLines = parseLRC(lyricData.lyric);
                const translationLines = parseLRC(lyricData.tlyric);
                
                // åˆå¹¶å¹¶æ’åºæ­Œè¯
                const combinedLines = originalLines.map(o => {
                    const t = translationLines.find(t => t.time === o.time);
                    return {
                        time: o.time,
                        original: o.text,
                        translation: t ? t.text : null,
                        words: o.words
                    };
                }).sort((a, b) => a.time - b.time);

                mergedLyricsData = combinedLines;
                if (debugConsole) debugConsole.success('æ­Œè¯', `æ­Œè¯è§£æå®Œæˆï¼Œå…± ${combinedLines.length} è¡Œæ­Œè¯`);
                displayMergedLyrics(combinedLines);
            } catch (error) {
                const errorMsg = `æ­Œè¯åŠ è½½å¤±è´¥: ${error.message}\næ­Œè¯ID: ${track.lyric_id || track.id}\né”™è¯¯å †æ ˆ: ${error.stack}`;
                if (debugConsole) debugConsole.error('æ­Œè¯', errorMsg);
            }
        }

        function displayMergedLyrics(lines) {
            try {
                lyricsContent.innerHTML = '';
                fullscreenLyricsLines.innerHTML = '';
                
                if (lines.length === 0) {
                    if (debugConsole) debugConsole.warn('æ­Œè¯', 'æ­Œè¯æ•°æ®ä¸ºç©ºï¼Œæ— æ­Œè¯å¯æ˜¾ç¤º');
                    const noLyric = '<div class="loading">æš‚æ— æ­Œè¯</div>';
                    lyricsContent.innerHTML = noLyric;
                    fullscreenLyricsLines.innerHTML = noLyric;
                    return;
                }

                const fragMini = document.createDocumentFragment();
                const fragFull = document.createDocumentFragment();
                
                lines.forEach(l => {
                    const createLineHtml = (text, isOriginal = true, isFullscreen = false) => {
                        if (l.words && isOriginal) {
                            return l.words.map(w => 
                                `<span class="word-highlight" data-word-time="${w.time}">${w.text}</span>`
                            ).join('');
                        }
                        return text;
                    };

                    // Mini Player Rendering
                    const div = document.createElement('div');
                    div.className = 'lyric-line';
                    div.dataset.time = l.time;
                    div.innerHTML = `
                        <span class="original-text">${createLineHtml(l.original, true, false)}</span>
                        ${l.translation ? `<span class="translation-text">${l.translation}</span>` : ''}
                    `;
                    div.onclick = () => {
                        audioPlayer.currentTime = l.time;
                        userScrolledLyrics = false; // ç‚¹å‡»æ­Œè¯åé‡ç½®æ»šåŠ¨çŠ¶æ€
                        if (debugConsole) debugConsole.info('æ­Œè¯', `ç‚¹å‡»æ­Œè¯è·³è½¬åˆ°: ${l.time} ç§’`);
                    };
                    fragMini.appendChild(div);
                    
                    // Fullscreen Player Rendering
                    const divFull = document.createElement('div');
                    divFull.className = 'fullscreen-lyric-line';
                    divFull.dataset.time = l.time;
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'fullscreen-line-wrapper';
                    
                    const original = document.createElement('span');
                    original.className = 'fullscreen-original-text';
                    original.innerHTML = createLineHtml(l.original, true, true);
                    wrapper.appendChild(original);

                    if (l.translation) {
                        const translation = document.createElement('span');
                        translation.className = 'fullscreen-translation-text';
                        translation.textContent = l.translation;
                        wrapper.appendChild(translation);
                    }

                    divFull.appendChild(wrapper);
                    divFull.onclick = () => {
                        audioPlayer.currentTime = l.time;
                        userScrolledLyrics = false;
                    };
                    fragFull.appendChild(divFull);
                });
                
                lyricsContent.appendChild(fragMini);
                fullscreenLyricsLines.appendChild(fragFull);
                
                if (debugConsole) debugConsole.success('æ­Œè¯æ¸²æŸ“', `æˆåŠŸæ¸²æŸ“ ${lines.length} è¡Œæ­Œè¯`);
            } catch (error) {
                const errorMsg = `æ­Œè¯æ¸²æŸ“å¤±è´¥: ${error.message}\né”™è¯¯å †æ ˆ: ${error.stack}`;
                if (debugConsole) debugConsole.error('æ­Œè¯æ¸²æŸ“', errorMsg);
            }
        }

        function highlightCurrentLyric(time) {
            if (!mergedLyricsData) return;
            
            let activeIdx = -1;
            for(let i=0; i<mergedLyricsData.length; i++) {
                if(mergedLyricsData[i].time <= time + 0.2) activeIdx = i;
                else break;
            }
            
            if (activeIdx === -1) return;
            
            // --- Sync Mini Player ---
            const miniLines = lyricsContent.querySelectorAll('.lyric-line');
            miniLines.forEach(l => l.classList.remove('active'));
            if(miniLines[activeIdx]) {
                miniLines[activeIdx].classList.add('active');
                // åªåœ¨ç”¨æˆ·æ²¡æœ‰æ»šåŠ¨æ—¶æ‰è‡ªåŠ¨æ»šåŠ¨
                if(!userScrolledLyrics) {
                    miniLines[activeIdx].scrollIntoView({behavior: 'smooth', block: 'center'});
                }
            }
            
            // --- Sync Fullscreen Player ---
            const fullLines = fullscreenLyricsLines.querySelectorAll('.fullscreen-lyric-line');
            fullLines.forEach(l => l.classList.remove('active'));
            if(fullLines[activeIdx]) {
                fullLines[activeIdx].classList.add('active');
                fullLines[activeIdx].scrollIntoView({behavior: 'smooth', block: 'center'});
            }
            
            // é€è¯é«˜äº®é€»è¾‘
            if (mergedLyricsData[activeIdx] && mergedLyricsData[activeIdx].words) {
                 const currentLineWords = (miniLines[activeIdx] || fullLines[activeIdx]).querySelectorAll('.word-highlight');
                 
                 currentLineWords.forEach(wordSpan => {
                     const wordTime = parseFloat(wordSpan.dataset.word-time);
                     if (wordTime <= time) {
                         wordSpan.style.color = '#ffcc00'; 
                     } else {
                         wordSpan.style.color = 'inherit'; 
                     }
                 });
            }
        }

        function formatTime(s) {
            if(isNaN(s) || s < 0) return '0:00';
            const m = Math.floor(s/60);
            const se = Math.floor(s%60);
            return `${m}:${se<10?'0':''}${se}`;
        }

        // --- Event Listeners ---
        
        searchBtn.onclick = () => {
            if (debugConsole) debugConsole.info('æœç´¢', `æ‰‹åŠ¨è§¦å‘æœç´¢: "${searchInput.value}" (API: ${apiSelect.value}, æº: ${sourceSelect.value})`);
            searchMusic(searchInput.value, sourceSelect.value);
        };
        
        searchInput.onkeypress = (e) => {
            if (e.key === 'Enter') {
                if (debugConsole) debugConsole.info('æœç´¢', `å›è½¦é”®è§¦å‘æœç´¢: "${searchInput.value}"`);
                searchBtn.click();
            }
        };
        
        // æ’­æ”¾æ§åˆ¶
        const togglePlay = () => {
            if(audioPlayer.paused) {
                if(audioPlayer.src) {
                    if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'ç‚¹å‡»æ’­æ”¾æŒ‰é’®ï¼Œå¼€å§‹æ’­æ”¾');
                    audioPlayer.play();
                } else {
                    if (debugConsole) debugConsole.warn('æ’­æ”¾æ§åˆ¶', 'ç‚¹å‡»æ’­æ”¾æŒ‰é’®ï¼Œä½†æ— éŸ³é¢‘æºå¯æ’­æ”¾');
                }
            } else {
                if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'ç‚¹å‡»æš‚åœæŒ‰é’®ï¼Œæš‚åœæ’­æ”¾');
                audioPlayer.pause();
            }
        };
        
        playBtn.onclick = togglePlay;
        fullscreenPlayBtn.onclick = togglePlay;
        
        audioPlayer.onplay = () => {
            playBtn.innerHTML = 'â¸';
            fullscreenPlayBtn.innerHTML = 'â¸';
            if (debugConsole) debugConsole.info('æ’­æ”¾çŠ¶æ€', 'éŸ³é¢‘å¼€å§‹æ’­æ”¾');
        };
        
        audioPlayer.onpause = () => {
            playBtn.innerHTML = 'â–¶';
            fullscreenPlayBtn.innerHTML = 'â–¶';
            if (debugConsole) debugConsole.info('æ’­æ”¾çŠ¶æ€', 'éŸ³é¢‘æš‚åœæ’­æ”¾');
        };
        
        prevBtn.onclick = fullscreenPrevBtn.onclick = () => {
            if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'ç‚¹å‡»ä¸Šä¸€æ›²æŒ‰é’®');
            if(currentTrack && searchResults.length) {
                const idx = searchResults.findIndex(t => t.id === currentTrack.id && t.api === currentTrack.api);
                const prevIdx = (idx - 1 + searchResults.length) % searchResults.length;
                const prev = searchResults[prevIdx];
                playTrack(prev);
            } else {
                if (debugConsole) debugConsole.warn('æ’­æ”¾æ§åˆ¶', 'æ— æ³•åˆ‡æ¢åˆ°ä¸Šä¸€æ›²ï¼šå½“å‰æ— æ­Œæ›²æˆ–æœç´¢ç»“æœ');
            }
        };
        
        nextBtn.onclick = fullscreenNextBtn.onclick = () => {
            if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'ç‚¹å‡»ä¸‹ä¸€æ›²æŒ‰é’®');
            if(currentTrack && searchResults.length) {
                const idx = searchResults.findIndex(t => t.id === currentTrack.id && t.api === currentTrack.api);
                const nextIdx = (idx + 1) % searchResults.length;
                const next = searchResults[nextIdx];
                playTrack(next);
            } else {
                if (debugConsole) debugConsole.warn('æ’­æ”¾æ§åˆ¶', 'æ— æ³•åˆ‡æ¢åˆ°ä¸‹ä¸€æ›²ï¼šå½“å‰æ— æ­Œæ›²æˆ–æœç´¢ç»“æœ');
            }
        };

        // UI Toggles
        fullscreenLyricsBtn.onclick = () => {
            if (debugConsole) debugConsole.info('ç•Œé¢', 'æ‰“å¼€å…¨å±æ­Œè¯æ¨¡å¼');
            fullscreenLyricsOverlay.classList.add('active');
        };
        
        closeFullscreenBtn.onclick = () => {
            if (debugConsole) debugConsole.info('ç•Œé¢', 'å…³é—­å…¨å±æ­Œè¯æ¨¡å¼');
            fullscreenLyricsOverlay.classList.remove('active');
        };
        
        // Progress Bars
        audioPlayer.ontimeupdate = () => {
            if(!audioPlayer.duration) return;
            const pct = (audioPlayer.currentTime/audioPlayer.duration)*100;
            progress.style.width = pct + '%';
            progressHandle.style.left = pct + '%';
            fullscreenProgress.style.width = pct + '%';
            currentTime.textContent = formatTime(audioPlayer.currentTime);
            highlightCurrentLyric(audioPlayer.currentTime);
        };
        
        audioPlayer.onloadedmetadata = () => {
            if (debugConsole) debugConsole.info('éŸ³é¢‘ä¿¡æ¯', `éŸ³é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆï¼Œæ—¶é•¿: ${formatTime(audioPlayer.duration)}`);
            duration.textContent = formatTime(audioPlayer.duration);
        };
        
        audioPlayer.onended = () => {
            if (debugConsole) debugConsole.info('æ’­æ”¾çŠ¶æ€', 'éŸ³é¢‘æ’­æ”¾ç»“æŸï¼Œè‡ªåŠ¨æ’­æ”¾ä¸‹ä¸€æ›²');
            nextBtn.click();
        };

        // Seek
        const seek = (e, bar) => {
            if(!audioPlayer.duration) return;
            const rect = bar.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : undefined);
            if (clientX === undefined) return;

            const p = Math.max(0, Math.min(1, (clientX - rect.left)/rect.width));
            const newTime = p * audioPlayer.duration;
            audioPlayer.currentTime = newTime;
            if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', `è·³è½¬åˆ°: ${formatTime(newTime)} (${p.toFixed(2) * 100}%)`);
        };

        // Mini player seek
        progressBar.onmousedown = (e) => { 
            isDragging = true; 
            if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'å¼€å§‹æ‹–åŠ¨è¿›åº¦æ¡');
            seek(e, progressBar); 
        };
        
        progressBar.ontouchstart = (e) => { 
            isDragging = true; 
            if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'è§¦æ‘¸å¼€å§‹æ‹–åŠ¨è¿›åº¦æ¡');
            seek(e, progressBar); 
        };

        document.addEventListener('mousemove', (e) => { 
            if (isDragging) {
                seek(e, progressBar);
            }
        });
        
        document.addEventListener('touchmove', (e) => { 
            if (isDragging) {
                seek(e, progressBar);
            }
        });
        
        document.addEventListener('mouseup', () => { 
            if (isDragging) {
                if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'ç»“æŸæ‹–åŠ¨è¿›åº¦æ¡');
                isDragging = false; 
            }
        });
        
        document.addEventListener('touchend', () => { 
            if (isDragging) {
                if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'è§¦æ‘¸ç»“æŸæ‹–åŠ¨è¿›åº¦æ¡');
                isDragging = false; 
            }
        });
        
        // Fullscreen seek
        fullscreenProgressBar.onclick = (e) => {
            if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'ç‚¹å‡»å…¨å±è¿›åº¦æ¡');
            seek(e, fullscreenProgressBar);
        };
        
        fullscreenProgressBar.ontouchstart = (e) => {
            if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'è§¦æ‘¸å…¨å±è¿›åº¦æ¡');
            seek(e, fullscreenProgressBar);
        };

        // Mesh Gradient Speed Control
        speedSlider.oninput = (e) => {
            ANIMATION_SPEED_MULTIPLIER = parseFloat(e.target.value);
            if (debugConsole) debugConsole.info('æ¸å˜èƒŒæ™¯', `æ¸å˜åŠ¨ç”»é€Ÿåº¦è°ƒæ•´ä¸º: ${ANIMATION_SPEED_MULTIPLIER.toFixed(2)}x`);
        };

        // ä¿®å¤æ­Œè¯æ»šåŠ¨ - ç§»é™¤è‡ªåŠ¨è¿”å›é€»è¾‘
        lyricsContainer.addEventListener('wheel', (e) => {
            userScrolledLyrics = true;
            if (debugConsole) debugConsole.info('æ­Œè¯æ»šåŠ¨', 'ç”¨æˆ·æ‰‹åŠ¨æ»šåŠ¨æ­Œè¯ï¼Œç¦ç”¨è‡ªåŠ¨æ»šåŠ¨');
        });
        
        lyricsContainer.addEventListener('touchstart', () => {
            userScrolledLyrics = true;
            if (debugConsole) debugConsole.info('æ­Œè¯æ»šåŠ¨', 'ç”¨æˆ·è§¦æ‘¸æ­Œè¯ï¼Œç¦ç”¨è‡ªåŠ¨æ»šåŠ¨');
        });

        // Resize
        window.onresize = () => {
            if (debugConsole) debugConsole.info('çª—å£', 'çª—å£å¤§å°æ”¹å˜ï¼Œé‡æ–°è°ƒæ•´Canvas');
            resizeCanvas();
        };
        
        // Init
        audioPlayer.volume = 0.7;
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æ‰€æœ‰ç»„ä»¶
        window.onload = () => {
            // åˆå§‹åŒ–è°ƒè¯•æ§åˆ¶å°
            initDebugConsole();
            
            // å¯åŠ¨æ¸å˜åŠ¨ç”»
            startGradientAnimation();
            
            if (debugConsole) debugConsole.info('ç³»ç»Ÿ', 'é¡µé¢åŠ è½½å®Œæˆï¼Œå‡†å¤‡è‡ªåŠ¨æœç´¢æ¼”ç¤º');
            
            // å»¶è¿Ÿæ‰§è¡Œè‡ªåŠ¨æœç´¢ï¼Œç¡®ä¿æ‰€æœ‰ç»„ä»¶å·²åˆå§‹åŒ–
            setTimeout(() => {
                if (debugConsole) debugConsole.info('æœç´¢', 'è‡ªåŠ¨æœç´¢æ¼”ç¤ºï¼šå‘¨æ°ä¼¦ (åŸAPI - é…·æˆ‘éŸ³ä¹)');
                searchMusic('å‘¨æ°ä¼¦', 'kuwo');
            }, 800);
        };

        // é”™è¯¯æ•è·
        window.onerror = function(message, source, lineno, colno, error) {
            const errorMsg = `å…¨å±€JavaScripté”™è¯¯: ${message}\næ¥æº: ${source}\nè¡Œå·: ${lineno}, åˆ—å·: ${colno}\né”™è¯¯å †æ ˆ: ${error ? error.stack : 'æ— å †æ ˆä¿¡æ¯'}`;
            if (debugConsole) debugConsole.error('JavaScripté”™è¯¯', errorMsg);
            return false;
        };

        // æœªå¤„ç†çš„Promiseé”™è¯¯
        window.addEventListener('unhandledrejection', function(event) {
            const errorMsg = `æœªå¤„ç†çš„Promiseæ‹’ç»: ${event.reason}\nPromise: ${event.promise}\né”™è¯¯å †æ ˆ: ${event.reason ? event.reason.stack : 'æ— å †æ ˆä¿¡æ¯'}`;
            if (debugConsole) debugConsole.error('Promiseé”™è¯¯', errorMsg);
        });

    </script>

    <!-- Load Pixi.js library from CDN for dynamic background. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.0/pixi.min.js"></script>
    <!-- Load Pixi filters (KawaseBlurFilter, TwistFilter, AdjustmentFilter) used for the swirling effect. -->
    <script src="https://cdn.jsdelivr.net/npm/pixi-filters@3.2.0/dist/pixi-filters.js"></script>
    <!-- Load our custom Pixi background script. Place this file in the same directory or adjust the path accordingly. -->
    <script src="pixiBackground.js"></script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"7939e04a4baf43c8b86a560f74aac60e","server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"5ccbff2f5b094d9889bac76ef086ce1a","server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"7939e04a4baf43c8b86a560f74aac60e","server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"5ccbff2f5b094d9889bac76ef086ce1a","server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>
</html>