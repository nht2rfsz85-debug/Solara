<!--
  ============================================================
  Lyrics Card Generator (Final Integrated Version)
  - Integrated Dynamic Background System + Dual Lyrics APIs
  - Merged from: lyrics-card.html + index_final_fixed.html
  - Generated: 2026-01-12
  ============================================================
-->
<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport"/>
<title>æ­Œè¯å¡ç‰‡ç”Ÿæˆå™¨ - æœ€ç»ˆå¢å¼ºç‰ˆ</title>
<style>
        /* åŸºç¡€æ ·å¼è®¾ç½® */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #f5f5f5;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display','SF Pro Text','Helvetica Neue', Arial, sans-serif;
        }
        
        /* æ§åˆ¶é¢æ¿æ ·å¼ */
        .control-panel {
            width: 100%;
            max-width: 800px;
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        textarea {
            height: 150px;
            resize: vertical;
        }
        
        button {
            padding: 10px 20px;
            background: #1DB954;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }
        
        button:hover {
            background: #17a34a;
        }

        /* å…¼å®¹ï¼šè„šæœ¬ä¸­ä½¿ç”¨çš„é€šç”¨éšè—ç±» */
        .hidden { display: none !important; }
        
        .btn-secondary {
            background: #666;
        }
        
        .btn-secondary:hover {
            background: #555;
        }

        /* ========== æ­Œè¯å¡ï¼šæœç´¢ UIï¼ˆç§»æ¤è‡ªè°ƒè¯•ç‰ˆæ’­æ”¾å™¨ï¼‰ ========== */
        .api-search-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .api-search-row input[type="text"] { flex: 1; min-width: 220px; }
        .api-search-row select { min-width: 160px; }
        .api-search-row button { margin-right: 0; }
        #resultsContainer {
            border: 1px solid #eee;
            border-radius: 8px;
            overflow: auto;
            max-height: 320px;
            background: #fafafa;
            padding: 4px;
        }
        #resultsContainer .loading {
            padding: 10px;
            color: #666;
        }
        .result-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
        }
        .result-item:hover { background: #f0f0f0; }
        .result-item.active { background: #e8f6ee; }
        .result-album { width: 44px; height: 44px; border-radius: 8px; object-fit: cover; flex: 0 0 auto; }
        .result-info { min-width: 0; }
        .result-title { font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .result-artist, .result-album-name { color: #666; font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .result-platform-info { display: flex; gap: 6px; align-items: center; margin-top: 2px; }
        .platform-badge { font-size: 11px; padding: 2px 6px; border-radius: 999px; background: #eee; color: #333; }

        /* é¢œè‰²ç®—æ³•åˆ‡æ¢æŒ‰é’®ï¼ˆæ­Œè¯å¡æ§åˆ¶é¢æ¿ç‰ˆï¼‰ */
        #algoToggleBtn { background: #222; }
        #algoToggleBtn:hover { background: #111; }

        /* å…¼å®¹ï¼šqualitySelect å¿…é¡»å­˜åœ¨ï¼Œä½†æ­Œè¯å¡ä¸æ’­æ”¾ï¼Œé»˜è®¤éšè— */
        #qualitySelect { display: none !important; }
        
        /* å¡ç‰‡å®¹å™¨æ ·å¼ */
        .preview-container {
            position: relative;
            max-width: 100%;
            overflow: auto;
            margin-bottom: 20px;
        }
        
        .card-container {
            width: 1200px;
            height: 2100px;
            background: #6CA6B0;
            border-radius: 60px;
            position: relative;
            overflow: hidden;
            transform-origin: top left;
        }
        
        /* å¡ç‰‡å…ƒç´ æ ·å¼ */
        .album-cover {
            width: 200px;
            height: 200px;
            position: absolute;
            top: 90px;
            left: 90px;
            object-fit: contain;
            border-radius: 10px;
        }
        
        .song-info {
            position: absolute;
            top: 90px;
            left: 320px;
            width: 800px;
            color: #000000;
        }
        
        .song-title {
            font-weight: 700;
            font-size: 60px;
            line-height: 70px;
        }
        
        .artist {
            font-weight: 400;
            font-size: 40px;
            line-height: 50px;
            margin-top: 10px;
            margin-left: 1em;
        }

        .album-name {
            font-weight: 400;
            font-size: 34px;
            line-height: 42px;
            margin-top: 6px;
            margin-left: 1em;
            opacity: 0.8;
        }
        
        .lyrics {
            position: absolute;
            top: 300px;
            left: 90px;
            width: 1020px;
            height: 1650px;
            color: #000000;
            font-weight: 400;
            font-size: 80px;
            line-height: 110px;
            white-space: pre-wrap;
            overflow: auto;
        }
        
        .spotify-logo {
            position: absolute;
            bottom: 90px;
            left: 90px;
            width: 200px;
            height: 65px;
            filter: brightness(0);
        }
        
        /* æ­Œè¯é€‰æ‹©å™¨æ ·å¼ */
        .lyrics-selector {
            display: none;
            margin-top: 15px;
        }
        
        .lyrics-selector.active {
            display: block;
        }
        
        .lyrics-line {
            padding: 5px;
            margin: 2px 0;
            cursor: pointer;
            border-radius: 3px;
        }
        
        .lyrics-line:hover {
            background-color: #f0f0f0;
        }
        
        .lyrics-line.selected {
            background-color: #e3f2fd;
        }
        
        .selection-controls {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .loader {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0,0,0,0.2);
            border-radius: 50%;
            border-top-color: #1DB954;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* å“åº”å¼å¸ƒå±€ */
        @media (max-width: 768px) {
            .control-panel {
                padding: 15px;
            }
            
            button {
                padding: 8px 15px;
                font-size: 14px;
            }
        }
    </style>
<style>
/* === å¤šèƒŒæ™¯ç³»ç»Ÿï¼ˆé›†æˆç‰ˆï¼‰CSS - è¿ç§»è‡ª index_final_fixed.html === */


    /* =========================================================
       å¤šèƒŒæ™¯ç³»ç»Ÿï¼ˆé›†æˆç‰ˆï¼‰
       æ–¹æ¡ˆAï¼šæŠ˜å å¼æ§åˆ¶é¢æ¿ï¼ˆä¸å ç”¨åŸæ§åˆ¶åŒºç©ºé—´ï¼‰
       ========================================================= */

    /* èƒŒæ™¯å®¿ä¸»å±‚ï¼šç”¨äºæŒ‚è½½ Pixi / Mesh çš„ç”»å¸ƒ */
    #bgHost {
        position: fixed;
        inset: 0;
        z-index: -1;
        pointer-events: none; /* å…³é”®ï¼šç¡®ä¿å–è‰²/ç‚¹å‡»/æ»šåŠ¨ç­‰äº¤äº’ä¸è¢«èƒŒæ™¯æ‹¦æˆª */
        overflow: hidden;
        /* PixièƒŒæ™¯åŸç‰ˆç”¨äºé¿å…åŠ è½½å‰é»‘å±çš„å¾„å‘æ¸å˜ï¼Œè¿™é‡Œä½œä¸ºç»Ÿä¸€å…œåº• */
        background: radial-gradient(circle at center, rgba(255,107,107,0.55) 0%, rgba(78,205,196,0.45) 30%, rgba(69,183,209,0.35) 60%, rgba(150,206,180,0.30) 100%);
    }
    #bgHost .bg-layer {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
    }
    #bgHost canvas {
        width: 100%;
        height: 100%;
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        z-index: 1;
        pointer-events: none;
    }

    /* ç¡®ä¿é»˜è®¤æ¸å˜èƒŒæ™¯ç”»å¸ƒä¸æ‹¦æˆªäº¤äº’ */
    #gradientCanvas { pointer-events: none; }

    /* èƒŒæ™¯æ§åˆ¶é¢æ¿ï¼šæµ®åŠ¨æŒ‰é’®ï¼ˆå·¦ä¸‹è§’ï¼‰ */
    #bgToggleBtn {
        position: fixed;
        left: calc(16px + env(safe-area-inset-left));
        bottom: calc(16px + env(safe-area-inset-bottom));
        z-index: 9999;

        width: 44px;
        height: 44px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.25);

        color: #fff;
        background: rgba(255,255,255,0.12);
        box-shadow: 0 10px 30px rgba(0,0,0,0.25);
        -webkit-backdrop-filter: blur(18px) saturate(180%);
        backdrop-filter: blur(18px) saturate(180%);
        cursor: pointer;
        user-select: none;
        transition: transform 0.15s ease, background 0.15s ease;
    }
    #bgToggleBtn:hover { transform: translateY(-1px); background: rgba(255,255,255,0.16); }
    #bgToggleBtn:active { transform: translateY(0px) scale(0.99); }

    /* èƒŒæ™¯é¢æ¿ä¸»ä½“ */
    #bgPanel {
        position: fixed;
        left: calc(16px + env(safe-area-inset-left));
        bottom: calc(68px + env(safe-area-inset-bottom));
        z-index: 9998;

        width: min(360px, calc(100vw - 32px));
        max-height: min(72vh, 640px);
        overflow: hidden;

        border-radius: 16px;
        border: 1px solid rgba(255,255,255,0.22);
        background: rgba(255,255,255,0.10);
        box-shadow: 0 16px 40px rgba(0,0,0,0.30);
        -webkit-backdrop-filter: blur(18px) saturate(180%);
        backdrop-filter: blur(18px) saturate(180%);

        display: none;
    }
    #bgPanel.show { display: block; }

    .bg-panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;

        padding: 12px 12px 10px 12px;
        border-bottom: 1px solid rgba(255,255,255,0.18);
        cursor: move; /* æ”¯æŒæ‹–æ‹½ */
        user-select: none;
    }

    .bg-panel-title {
        display: flex;
        align-items: center;
        gap: 8px;
        color: #fff;
        font-weight: 700;
        font-size: 14px;
    }

    .bg-badge {
        display: inline-flex;
        align-items: center;
        padding: 3px 8px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        color: #fff;
        background: rgba(0,0,0,0.25);
        border: 1px solid rgba(255,255,255,0.20);
    }

    .bg-panel-actions { display: flex; gap: 8px; }
    .bg-panel-actions button {
        width: 30px;
        height: 30px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.20);
        background: rgba(0,0,0,0.18);
        color: #fff;
        cursor: pointer;
        transition: background 0.15s ease;
    }
    .bg-panel-actions button:hover { background: rgba(0,0,0,0.28); }

    .bg-panel-body {
        padding: 12px;
        overflow: auto;
        max-height: calc(min(72vh, 640px) - 52px);
    }

    .bg-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
    }

    .bg-main-btn {
        padding: 10px 14px;
        border: none;
        border-radius: 12px;
        background: rgba(255,255,255,0.16);
        color: #fff;
        cursor: pointer;
        font-weight: 700;
        transition: background 0.15s ease, transform 0.15s ease;
    }
    .bg-main-btn:hover { background: rgba(255,255,255,0.22); transform: translateY(-1px); }
    .bg-main-btn:active { transform: translateY(0px) scale(0.99); }

    .bg-checkbox {
        display: flex;
        align-items: center;
        gap: 8px;
        color: rgba(255,255,255,0.95);
        font-size: 13px;
        user-select: none;
        cursor: pointer;
    }
    .bg-checkbox input { width: 18px; height: 18px; cursor: pointer; }

    .bg-sep {
        height: 1px;
        background: rgba(255,255,255,0.16);
        margin: 10px 0 12px 0;
    }

    .bg-hint {
        color: rgba(255,255,255,0.85);
        font-size: 12px;
        line-height: 1.45;
        padding: 10px;
        border-radius: 12px;
        border: 1px dashed rgba(255,255,255,0.18);
        background: rgba(0,0,0,0.10);
    }

    /* èƒŒæ™¯ä¸“ç”¨æ§åˆ¶åŒºï¼šå¤ç”¨åŸæ§ä»¶è¯­ä¹‰ï¼Œä½†ç»Ÿä¸€æˆâ€œæ¶²æ€ç»ç’ƒâ€é£æ ¼ */
    .bg-controls .control-group-title {
        color: rgba(255,255,255,0.95);
        font-weight: 800;
        font-size: 13px;
        margin: 8px 0 10px 0;
    }
    .bg-controls .bg-ctrl-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
    }
    .bg-controls label {
        color: rgba(255,255,255,0.92);
        font-size: 13px;
        user-select: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .bg-controls input[type="range"] { width: 160px; }
    .bg-controls input[type="text"] {
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.22);
        background: rgba(0,0,0,0.18);
        color: #fff;
        outline: none;
    }
    .bg-controls .bg-file-btn,
    .bg-controls button {
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.22);
        background: rgba(0,0,0,0.18);
        color: #fff;
        cursor: pointer;
        transition: background 0.15s ease;
    }
    .bg-controls .bg-file-btn:hover,
    .bg-controls button:hover { background: rgba(0,0,0,0.28); }
    .bg-controls .bg-file-name {
        color: rgba(255,255,255,0.75);
        font-size: 12px;
        word-break: break-all;
        line-height: 1.35;
    }
    .bg-controls .bg-subtle {
        color: rgba(255,255,255,0.75);
        font-size: 12px;
    }

    /* å°å±é€‚é…ï¼šé¢æ¿é åº•éƒ¨ã€å®½åº¦é“ºæ»¡ï¼Œé¿å…ä¸æ’­æ”¾å™¨æ§ä»¶é‡å  */
    @media (max-width: 680px) {
        #bgPanel {
            left: calc(12px + env(safe-area-inset-left));
            right: calc(12px + env(safe-area-inset-right));
            width: auto;
            bottom: calc(64px + env(safe-area-inset-bottom));
            max-height: 62vh;
        }
        #bgToggleBtn {
            left: calc(12px + env(safe-area-inset-left));
            bottom: calc(12px + env(safe-area-inset-bottom));
        }
        .bg-controls input[type="range"] { width: 100%; }
    }



/* =========================================================
   Lyrics Card - å¤šèƒŒæ™¯ç³»ç»Ÿé›†æˆè¦†ç›–æ ·å¼
   è¯´æ˜ï¼šä¿ç•™ index_final_fixed.html åŸCSSï¼ŒåŒæ—¶å°†å¸ƒå±€ç»‘å®šåˆ° #card å†…éƒ¨ã€‚
========================================================= */

/* èƒŒæ™¯æ¸²æŸ“å±‚ï¼šç»‘å®šåœ¨å¡ç‰‡å†…è€Œéå…¨å± */
#card { position: relative; }
#lyrics-card-bg-canvas{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  z-index:0;
  overflow:hidden;
  pointer-events:none;
}

#lyrics-card-bg-canvas #gradientCanvas{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  z-index:0;
}

#lyrics-card-bg-canvas #bgHost{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  z-index:1;
  pointer-events:none;
}

#lyrics-card-bg-canvas #bgThemeTint{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  z-index:2;
  pointer-events:none;
  background: var(--bg-theme-color, transparent);
  opacity: var(--bg-theme-strength, 0.0);
  mix-blend-mode: overlay;
}

/* === FIX: ensure background layers fully cover the card (preview + export) === */
#lyrics-card-bg-canvas,
#lyrics-card-bg-canvas #gradientCanvas,
#lyrics-card-bg-canvas #bgHost,
#lyrics-card-bg-canvas #bgThemeTint{
  inset: 0;
  width: 100%;
  height: 100%;
  border-radius: inherit;
}
#lyrics-card-bg-canvas{
  overflow: hidden;
}
#lyrics-card-bg-canvas #bgHost{
  overflow: hidden;
}
#lyrics-card-bg-canvas canvas,
#lyrics-card-bg-canvas img{
  border-radius: inherit;
}

/* === FIX: panel readability (works for both embedded and floating layouts) === */
#bgPanel, .bg-panel{
  color: rgba(255,255,255,0.92) !important;
}
#bgPanel{
  background: rgba(18,18,18,0.78) !important;
  border: 1px solid rgba(255,255,255,0.18) !important;
  box-shadow: 0 16px 40px rgba(0,0,0,0.40) !important;
}
.bg-panel-header{
  border-bottom: 1px solid rgba(255,255,255,0.12) !important;
}
.bg-panel-title, .bg-controls label, .bg-hint{
  color: rgba(255,255,255,0.90) !important;
}
.bg-controls input[type=range]{
  accent-color: #7fd0df;
}
.bg-controls input[type=text],
.bg-controls input[type=url],
.bg-controls select{
  background: rgba(255,255,255,0.10) !important;
  color: rgba(255,255,255,0.92) !important;
  border: 1px solid rgba(255,255,255,0.16) !important;
}
.bg-controls button{
  color: rgba(255,255,255,0.92) !important;
}


/* ç¡®ä¿å¡ç‰‡å†…å®¹åœ¨èƒŒæ™¯ä¹‹ä¸Š */
#card > *:not(#lyrics-card-bg-canvas){
  /* IMPORTANT: do NOT override positioning of absolutely-positioned elements */
  z-index: 5;
}

/* èƒŒæ™¯æ§åˆ¶é¢æ¿ï¼šåµŒå…¥æ§åˆ¶é¢æ¿å†…ï¼ˆå–æ¶ˆ fixed å®šä½ï¼‰ */
#bgToggleBtn{
  position: static !important;
  margin-top: 10px;
  width: 100%;
}

#bgPanel{
  position: static !important;
  left: auto !important;
  bottom: auto !important;
  width: 100% !important;
  max-width: none !important;
  transform: none !important;
  margin-top: 10px;
}

#bgPanel.show{
  display: block !important;
}

#bgPanel:not(.show){
  display: none !important;
}

.bg-panel{
  box-shadow: none !important;
}

/* è®©èƒŒæ™¯æ§åˆ¶é¢æ¿å†…å®¹æ›´è´´è¿‘æœ¬é¡µæ§ä»¶é£æ ¼ */
.bg-panel-header{
  border-radius: 8px 8px 0 0;
}

.bg-panel-body{
  border-radius: 0 0 8px 8px;
}

/* æ–‡æœ¬å¯è¯»æ€§ï¼šæ­Œè¯ç»ç’ƒé®ç½© + æ–‡æœ¬é˜´å½± */
#lyricsDisplay{
  background: rgba(var(--lyrics-glass-rgb, 0,0,0), var(--lyrics-glass-alpha, 0.0));
  border-radius: 28px;
  padding: 0px;
  box-shadow: 0 8px 30px rgba(0,0,0,0.12);
  text-shadow: 0 2px 10px rgba(0,0,0,0.35);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

#songTitleDisplay, #artistDisplay{
  text-shadow: 0 2px 10px rgba(0,0,0,0.35);
}

/* æ–‡æœ¬é¢œè‰²æ§ä»¶ */
.text-color-row{
  display:flex;
  gap:10px;
  align-items:center;
  flex-wrap:wrap;
}

.text-color-row select{
  flex:1;
  min-width: 220px;
}

.glass-row{
  margin-top: 10px;
}

.glass-row input[type="range"]{
  width: 100%;
}

.glass-row .range-labels{
  display:flex;
  justify-content:space-between;
  font-size: 12px;
  color:#666;
  margin-top: 4px;
}

.details-box{
  margin-top: 10px;
}

.details-box summary{
  cursor: pointer;
  color: #333;
  font-weight: 600;
}

.details-content{
  margin-top: 8px;
  display: grid;
  gap: 10px;
}

/* API é«˜çº§è®¾ç½®ï¼ˆé»˜è®¤ä¸å±•å¼€ï¼Œä¸å½±å“å¸ƒå±€ï¼‰ */
.api-results{
  margin-top: 10px;
  border: 1px dashed #ddd;
  border-radius: 8px;
  padding: 10px;
  max-height: 200px;
  overflow: auto;
  font-size: 13px;
}

/* å°å±ä¸‹æ§åˆ¶é¢æ¿æ›´èˆ’é€‚ */
@media (max-width: 1100px){
  #bgToggleBtn{ width: 100%; }
}
</style></head>
<body>
<!-- æ§åˆ¶é¢æ¿ -->
<div class="control-panel">
<h2 style="margin-bottom: 20px;">å¢å¼ºå‹æ­Œè¯å¡ç‰‡ç”Ÿæˆå™¨</h2>
<div class="form-group">
<label for="songTitle">æ­Œæ›²åç§°:</label>
<input id="songTitle" type="text" value="çƒŸèŠ±æ˜“å†·"/>
</div>
<div class="form-group">
<label for="artist">æ­Œæ‰‹åç§°:</label>
<input id="artist" type="text" value="å‘¨æ°ä¼¦"/>
</div>

<!-- æ–°å¢ï¼šä¸“è¾‘åï¼ˆç”¨äº API è”åŠ¨è‡ªåŠ¨å¡«å……ï¼‰ -->
<div class="form-group">
<label for="album">ä¸“è¾‘åç§°:</label>
<input id="album" type="text" value=""/>
</div>

<!-- æ–°å¢ï¼šæœç´¢ UIï¼ˆå®Œæ•´ç§»æ¤ï¼šGDStudio + TuneHub + å¹³å° + ç®—æ³•åˆ‡æ¢ + ç»“æœåˆ—è¡¨ï¼‰ -->
<div class="form-group" id="searchGroup">
<label>æœç´¢æ­Œæ›²ï¼ˆåŒ APIï¼‰ï¼š</label>
<div class="api-search-row">
<input id="searchInput" placeholder="æœç´¢æ­Œæ›²ã€æ­Œæ‰‹æˆ–ä¸“è¾‘..." type="text" value="å‘¨æ°ä¼¦"/>
<select id="apiSelect" title="é€‰æ‹©APIæ¥å£æº">
<option selected="" value="gdstudio">åŸAPI (GDStudio)</option>
<option value="tunehub">å¤‡ç”¨API (TuneHub)</option>
</select>
<button id="algoToggleBtn" title="åˆ‡æ¢ä¸“è¾‘å°é¢é¢œè‰²æå–ç®—æ³•" type="button">ç®—æ³•ï¼šåŸ(ä¸­ä½åˆ‡åˆ†)</button>
<select id="sourceSelect" title="é€‰æ‹©å¹³å° Source">
<option selected="" value="kuwo">é…·æˆ‘éŸ³ä¹</option>
<option value="joox">JOOXéŸ³ä¹</option>
<option value="netease">ç½‘æ˜“äº‘éŸ³ä¹</option>
<option value="qq">QQéŸ³ä¹ (ä»…TuneHub)</option>
<option value="aggregate">èšåˆæœç´¢ (ä»…TuneHub)</option>
</select>
<button id="searchBtn" type="button">æœç´¢</button>
</div>

<!-- å…¼å®¹ï¼šè°ƒè¯•ç‰ˆä¸­ç”¨äºéŸ³è´¨ï¼Œè¿™é‡Œä¸æ˜¾ç¤ºä½†å¿…é¡»å­˜åœ¨ä»¥æ»¡è¶³å®Œæ•´ç§»æ¤ -->
<select id="qualitySelect" class="quality-select" aria-hidden="true">
<option value="128">æ ‡å‡†å“è´¨ (128k)</option>
<option value="192">è‰¯å¥½å“è´¨ (192k)</option>
<option value="320">é«˜å“è´¨ (320k)</option>
<option value="740">æ— æŸå“è´¨ (740k)</option>
<option selected="" value="999">é«˜è§£æåº¦ (999k)</option>
</select>

<div id="resultsContainer"><div class="loading">ç‚¹å‡»â€œæœç´¢â€å¼€å§‹æŸ¥è¯¢æ­Œæ›²</div></div>
</div>
<div class="form-group">
<button id="fetchLyricsBtn">è‡ªåŠ¨è·å–æ­Œè¯</button>
<span id="fetchingIndicator" style="display: none;">
<span class="loader"></span>
<span>æ­£åœ¨æœç´¢æ­Œè¯...</span>
</span>
<span class="hidden" id="fetchIndicator" style="margin-left:10px; color:#666; font-size:14px;">&nbsp;</span>
</div>
<div class="form-group">
<label for="albumCoverUpload">ä¸Šä¼ ä¸“è¾‘å°é¢:</label>
<input accept="image/*" id="albumCoverUpload" type="file"/>
</div>
<div class="form-group">
<label for="albumCover">æˆ–ä½¿ç”¨å›¾ç‰‡ URL:</label>
<input id="albumCover" type="text" value="https://a1.mzstatic.com/r40/Music125/v4/53/2d/dd/532dddf0-87d7-b9eb-7d8b-4eb194c84252/asset.jpg"/>
<small style="display: block; margin-top: 5px; color: #666;">æ³¨æ„: ä¸Šä¼ æœ¬åœ°å›¾ç‰‡å°†ä¼˜å…ˆäºURL</small>
</div>
<!-- æ·»åŠ å¾½æ ‡ä¸Šä¼ å’ŒURLè¾“å…¥ -->
<div class="form-group">
<label for="logoUpload">ä¸Šä¼ å“ç‰Œæ ‡å¿—:</label>
<input accept="image/*" id="logoUpload" type="file"/>
</div>
<div class="form-group">
<label for="logoUrl">æˆ–ä½¿ç”¨æ ‡å¿— URL:</label>
<input id="logoUrl" type="text" value="" placeholder="è¾“å…¥Logoå›¾ç‰‡URLï¼ˆå¯é€‰ï¼‰"/>
<small style="display: block; margin-top: 5px; color: #666;">æ³¨æ„: ä¸Šä¼ æœ¬åœ°å›¾ç‰‡å°†ä¼˜å…ˆäºURL</small>
</div>
<div class="form-group">
<label for="lyricsInput">æ­Œè¯:</label>
<textarea id="lyricsInput">ç¹åå£°
éå…¥ç©ºé—¨
æŠ˜ç…äº†ä¸–äººæ¢¦åå†·
è¾—è½¬ä¸€ç”Ÿ
æƒ…å€ºåˆå‡ æœ¬å¦‚ä½ é»˜è®¤
ç”Ÿæ­»æ¯ç­‰æ¯ç­‰ä¸€åœˆ
åˆä¸€åœˆçš„
å¹´è½®æµ®å± å¡”
æ–­äº†å‡ å±‚
æ–­äº†è°çš„é­‚</textarea>
<div class="lyrics-selector" id="lyricsSelector">
<div class="selection-controls">
<button class="btn-secondary" id="selectAllBtn">å…¨é€‰</button>
<button class="btn-secondary" id="deselectAllBtn">å–æ¶ˆå…¨é€‰</button>
<label style="display:flex;align-items:center;gap:6px;margin-left:8px;font-size:12px;color:#555;user-select:none;">
  <input id="splitCnPuncChk" type="checkbox" checked />
  æ‹†åˆ†ä¸­æ–‡é•¿å¥ï¼ˆæŒ‰æ ‡ç‚¹ï¼‰
</label>
<label style="display:flex;align-items:center;gap:6px;margin-left:8px;font-size:12px;color:#555;user-select:none;">
  æœ€å¤šä¿ç•™
  <input id="maxLinesInput" type="number" min="1" max="60" value="10" style="width:64px;padding:6px 8px;border:1px solid #ddd;border-radius:8px;" />
  å¥
</label>
<button class="btn-secondary" id="autoPickBtn">è‡ªåŠ¨é€‰å–</button>
<button id="applySelectionBtn">åº”ç”¨é€‰æ‹©</button>
</div>
<div id="lyricsLines"></div>
</div>
<button id="formatLyricsBtn" style="margin-top: 10px;">ä¼˜åŒ–æ­Œè¯æ’ç‰ˆï¼ˆAppleé£ï¼‰</button>
</div>
<div class="form-group">
<label for="backgroundColor">èƒŒæ™¯é¢œè‰²:</label>
<input id="backgroundColor" type="color" value="#6CA6B0"/>
<div style="display: flex; align-items: center; margin-top: 5px;">
<button id="extractColorBtn" style="margin-right: 10px;" type="button">ä»å°é¢æå–é¢œè‰²</button>
<div id="extractedColors" style="display: flex;"></div>
</div>
</div>
<div class="form-group" id="dynamicBgGroup">
<label>åŠ¨æ€èƒŒæ™¯:</label>
<button id="bgToggleBtn" type="button">ğŸ¨ æ‰“å¼€/å…³é—­åŠ¨æ€èƒŒæ™¯æ§åˆ¶é¢æ¿</button>
<div class="bg-panel" id="bgPanel">
<div class="bg-panel-header" id="bgPanelHeader">
<div class="bg-panel-title">
        ğŸ¨ èƒŒæ™¯æ§åˆ¶ <span class="bg-badge" id="bgStatusBadge">é»˜è®¤</span>
</div>
<div class="bg-panel-actions">
<button class="bg-panel-action" id="bgPanelMinBtn" title="æŠ˜å " type="button">âˆ’</button>
<button class="bg-panel-action" id="bgPanelCloseBtn" title="å…³é—­" type="button">âœ•</button>
</div>
</div>
<div class="bg-panel-body">
<div class="bg-controls">
<div class="bg-ctrl-row" style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
<label for="bgModeSelect" style="min-width:72px;">æ¨¡å¼:</label>
<select id="bgModeSelect" style="flex:1;min-width:240px;">
<option value="default">é»˜è®¤ï¼ˆåŠ¨æ€æ¸å˜ï¼‰</option>
<option value="solid">çº¯è‰²</option>
<option value="pixi">Pixi åŠ¨æ€</option>
<option value="mesh">Mesh æ¸å˜</option>
</select>
</div>
<div class="bg-ctrl-row" style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
<button id="bgSwitchBtn" type="button">å¾ªç¯åˆ‡æ¢</button>
<label style="display:flex;align-items:center;gap:6px;">
<input checked="" id="bgFollowAlbum" type="checkbox"/>
            è·Ÿéšå°é¢
          </label>
</div>
<div id="bgControlsMount"></div>
</div>
</div>
</div>
</div>

<div class="form-group">
<label for="fontSizeRange">æ­Œè¯å­—ä½“å¤§å°:</label>
<input id="fontSizeRange" max="120" min="40" style="margin-bottom: 5px;" type="range" value="80"/>
<div style="display: flex; justify-content: space-between;">
<span>å°</span>
<span id="fontSizeValue">80px</span>
<span>å¤§</span>
</div>
</div>

<div class="form-group" id="textColorGroup">
<label>æ–‡æœ¬é¢œè‰²:</label>
<div class="text-color-row">
<select id="textColorMode">
<option value="auto">è‡ªåŠ¨ï¼ˆæ™ºèƒ½å¯¹æ¯”åº¦ï¼‰</option>
<option value="white">çº¯ç™½</option>
<option value="black">çº¯é»‘</option>
<option value="darkgray">æ·±ç°</option>
<option value="lightgray">æµ…ç°</option>
</select>
</div>
<div class="glass-row">
<label for="glassAlphaRange" style="margin-top:8px;">æ­Œè¯ç»ç’ƒé®ç½©å¼ºåº¦:</label>
<input id="glassAlphaRange" max="0.55" min="0" step="0.01" type="range" value="0.22"/>
<div class="range-labels">
<span>é€æ˜</span>
<span id="glassAlphaValue">22%</span>
<span>æ›´æ¸…æ™°</span>
</div>

<!-- å…¼å®¹ï¼šæ—§ç‰ˆæŒ‰é’®ï¼ˆè„šæœ¬ä»ç»‘å®šäº‹ä»¶ï¼‰ï¼Œé»˜è®¤ä¸å±•ç¤º -->
<div class="hidden" aria-hidden="true">
  <button id="textLightBtn" type="button">æµ…è‰²æ–‡å­—</button>
  <button id="textDarkBtn" type="button">æ·±è‰²æ–‡å­—</button>
</div>
</div>
</div>

<div class="form-group">
<label>æ ‡å¿—æ§åˆ¶:</label>
<button class="btn-secondary" id="toggleLogoBtn">å…³é—­æ ‡å¿—</button>
</div>
<div style="display: flex; justify-content: space-between;">
<div>
<button id="updateBtn">æ›´æ–°é¢„è§ˆ</button>
<button id="downloadBtn">ä¸‹è½½ PNG</button>
</div>
<div>
<button id="zoomOutBtn">ç¼©å°</button>
<button id="zoomInBtn">æ”¾å¤§</button>
</div>
</div>
</div>
<!-- é¢„è§ˆå®¹å™¨ -->
<div class="preview-container">
<div class="card-container" id="card">
<img alt="" crossorigin="anonymous" id="albumArt" src="https://a1.mzstatic.com/r40/Music125/v4/53/2d/dd/532dddf0-87d7-b9eb-7d8b-4eb194c84252/asset.jpg" style="display:none;"/><div aria-hidden="true" id="lyrics-card-bg-canvas">
<canvas id="gradientCanvas"></canvas>
<div id="bgHost"></div>
<div id="bgThemeTint"></div>
</div>

<img alt="ä¸“è¾‘å°é¢" class="album-cover" crossorigin="anonymous" id="albumCoverImg" src="https://a1.mzstatic.com/r40/Music125/v4/53/2d/dd/532dddf0-87d7-b9eb-7d8b-4eb194c84252/asset.jpg"/>
<div class="song-info">
<div class="song-title" id="songTitleDisplay">æ­¤ç”Ÿä¸æ¢</div>
<div class="artist" id="artistDisplay">é’é¸Ÿé£é±¼</div>
<div class="album-name" id="albumDisplay"></div>
</div>
<div class="lyrics" id="lyricsDisplay">
                æ™‚å…‰ç©¿ä¸æ–·æµè½‰åœ¨
                å¾å‰
                åˆ»éª¨çš„æˆ€é‡ ä¸æ˜¯é™é 
                å†æœ‰ä¸€è¬å¹´ æ·±æƒ…ä¹Ÿ
                ä¸è®Š
                æ„›åƒçƒˆç«èˆ¬è”“å»¶
                è¨˜æ†¶æ˜¯æ¢é•·ç·š ç›¤æ—‹
                åœ¨å¤©é‚Š
            </div>
<img alt="å“ç‰Œæ ‡å¿—" class="spotify-logo" crossorigin="anonymous" id="logo" 
     src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="/>
</div>
</div>
<script>
/* Patch: avoid Chrome Violation "Avoid using document.write()" from third-party libs (html2canvas)
   by overriding Document.prototype.write/open/close with a buffered implementation.
   This is safe for html2canvas' iframe cloning path (open -> write -> close). */
(function(){
  try {
    const nativeOpen = Document.prototype.open;
    const nativeClose = Document.prototype.close;
    if (!Document.prototype.__writePatched) {
      Document.prototype.__writePatched = true;
      Document.prototype.open = function(...args){
        try { this.___writeBuffer = ''; } catch(e) {}
        return nativeOpen.apply(this, args);
      };
      Document.prototype.write = function(...args){
        try {
          const s = args.join('');
          this.___writeBuffer = (this.___writeBuffer || '') + s;
        } catch(e) {}
      };
      Document.prototype.close = function(...args){
        try {
          if (typeof this.___writeBuffer === 'string' && this.___writeBuffer.length) {
            // Best-effort: set full document HTML at once (no incremental document.write).
            this.documentElement.innerHTML = this.___writeBuffer;
          }
        } catch(e) {}
        return nativeClose.apply(this, args);
      };
    }
  } catch(e) {}
})();
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script><script>// ========== æ€§èƒ½æŠ¤æ ï¼ˆä¸åˆ åŠŸèƒ½ï¼Œåªé™è´Ÿè½½ï¼‰ ==========
(function(){
  try {
    const ua = navigator.userAgent || '';
    const isMobile = /Android|iPhone|iPad|iPod/i.test(ua);
    const cores = Number(navigator.hardwareConcurrency || 0) || 0;
    const mem = Number(navigator.deviceMemory || 0) || 0;
    const lowEnd = isMobile && ((cores && cores <= 4) || (mem && mem <= 4));

    // é¢„è§ˆï¼šé™åˆ¶ DPRï¼Œé¿å… 1200x2100 åœ¨é«˜ DPR ä¸‹ç›´æ¥çˆ† GPU
    window.__LYRICS_PERF = {
      isMobile,
      lowEnd,
      maxPreviewDpr: isMobile ? 1.25 : 2,
      // å…è®¸å¯¼å‡ºæ›´é«˜ï¼Œä½†ä¹Ÿè¦é˜²æ­¢çˆ†ï¼ˆæŒ‰åƒç´ é¢ç§¯ï¼‰
      maxCanvasPixelsPreview: isMobile ? 1_800_000 : 4_000_000,
      maxCanvasPixelsExport: isMobile ? 5_000_000 : 12_000_000,
      targetFps: lowEnd ? 24 : (isMobile ? 30 : 60),
    };
  } catch(e){
    window.__LYRICS_PERF = { isMobile:false, lowEnd:false, maxPreviewDpr:2, maxCanvasPixelsPreview:4000000, maxCanvasPixelsExport:12000000, targetFps:60 };
  }
})();

// ========== åŠ¨æ€ç½‘æ ¼æ¸å˜ç³»ç»Ÿ ==========
        const canvas = document.getElementById('gradientCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true, alpha: false }); 
        
        let gradientPoints = [];
        let animationId = null;
        let lastTime = 0;
        let ANIMATION_SPEED_MULTIPLIER = 1.0; 
        
        // é»˜è®¤é…è‰²æ–¹æ¡ˆ
        const defaultPalette = [
            { r: 47, g: 72, b: 88 },    
            { r: 146, g: 60, b: 88 },   
            { r: 240, g: 99, b: 164 },  
            { r: 45, g: 52, b: 54 },    
            { r: 85, g: 52, b: 124 },   
            { r: 255, g: 159, b: 67 }   
        ];

        function resizeCanvas() {
        const host = document.getElementById('card');
        const baseDpr = Math.max(1, window.devicePixelRatio || 1);
        const exportScale = (window.__LYRICS_CARD_EXPORT_SCALE || 1);

        // card å¯èƒ½ transform: scale(...) è¿›è¡Œé¢„è§ˆç¼©æ”¾ï¼›è¿™é‡Œç”¨å®é™…ç¼©æ”¾ç³»æ•°é™ä½ç¦»å±åˆ†è¾¨ç‡ï¼Œé¿å…â€œå¡çˆ†â€
        let previewScale = 1;
        try {
            if (host) {
                const rect = host.getBoundingClientRect();
                const ow = host.offsetWidth || host.clientWidth || rect.width;
                if (ow > 0) previewScale = Math.max(0.05, Math.min(1, rect.width / ow));
            }
        } catch (_) {}

        let dpr = baseDpr * exportScale * previewScale;

        // PERF: cap preview DPR on mobile; export keeps quality but is still bounded by max pixel area
        const perf = (window.__LYRICS_PERF || {});
        const cssW0 = host ? Math.max(1, host.clientWidth) : Math.max(1, window.innerWidth);
        const cssH0 = host ? Math.max(1, host.clientHeight) : Math.max(1, window.innerHeight);
        const isExporting = (exportScale && exportScale !== 1);
        const maxDpr = isExporting ? Math.max(1.5, perf.maxPreviewDpr || 2) : (perf.maxPreviewDpr || 2);
        dpr = Math.min(dpr, maxDpr);
        const maxPixels = isExporting ? (perf.maxCanvasPixelsExport || 5000000) : (perf.maxCanvasPixelsPreview || 1800000);
        const wantedPixels = (cssW0 * dpr) * (cssH0 * dpr);
        if (wantedPixels > maxPixels) {
          const s = Math.sqrt(maxPixels / wantedPixels);
          dpr = Math.max(0.5, dpr * s);
        }

        const cssW = host ? Math.max(1, host.clientWidth) : Math.max(1, window.innerWidth);
        const cssH = host ? Math.max(1, host.clientHeight) : Math.max(1, window.innerHeight);

        const prevW = canvas.width || 1;
        const prevH = canvas.height || 1;

        // ä¿æŒ CSS å°ºå¯¸ç»‘å®šå¡ç‰‡ï¼ˆæœªç¼©æ”¾å¸ƒå±€ï¼‰ï¼Œåƒç´ å°ºå¯¸æŒ‰ dpr / å¯¼å‡ºç¼©æ”¾è°ƒæ•´
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';
        canvas.width = Math.max(1, Math.round(cssW * dpr));
        canvas.height = Math.max(1, Math.round(cssH * dpr));

        // ç¼©æ”¾ç°æœ‰æ§åˆ¶ç‚¹ï¼Œé¿å… resize æ—¶ç”»é¢è·³å˜ï¼ˆä¸»è¦ç”¨äº dpr/å¯¼å‡ºç¼©æ”¾å˜åŒ–ï¼‰
        try {
            if (Array.isArray(gradientPoints) && gradientPoints.length) {
                const sx = canvas.width / prevW;
                const sy = canvas.height / prevH;
                const sr = (sx + sy) * 0.5;

                for (const p of gradientPoints) {
                    if (!p) continue;

                    if (Number.isFinite(p.x)) p.x *= sx;
                    if (Number.isFinite(p.y)) p.y *= sy;
                    if (Number.isFinite(p.baseX)) p.baseX *= sx;
                    if (Number.isFinite(p.baseY)) p.baseY *= sy;
                    if (Number.isFinite(p.rangeX)) p.rangeX *= sx;
                    if (Number.isFinite(p.rangeY)) p.rangeY *= sy;
                    if (Number.isFinite(p.radiusBase)) p.radiusBase *= sr;
                }
            }
        } catch (_) {}
    }

        // åˆå§‹åŒ– 6x6 ç½‘æ ¼ç‚¹
        function initGradientPoints(colors = null) {
            gradientPoints = [];
            const cols = 6;
            const rows = 6;
            const width = canvas.width;
            const height = canvas.height;
            const cellW = width / cols;
            const cellH = height / rows;
            const palette = colors && colors.length > 0 ? colors : defaultPalette;

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const baseX = j * cellW + cellW / 2;
                    const baseY = i * cellH + cellH / 2;
                    
                    const colorIdx = (i * cols + j) % palette.length;
                    const initialColor = palette[colorIdx];

                    gradientPoints.push({
                        x: baseX,
                        y: baseY,
                        baseX: baseX,
                        baseY: baseY,
                        color: { ...initialColor },
                        targetColor: { ...initialColor },

                        rangeX: cellW * 1.5,
                        rangeY: cellH * 1.5,
                        phaseX: Math.random() * Math.PI * 2,
                        phaseY: Math.random() * Math.PI * 2,
                        speedX: (0.0001 + Math.random() * 0.0003) * (Math.random() > 0.5 ? 1 : -1),
                        speedY: (0.0001 + Math.random() * 0.0003) * (Math.random() > 0.5 ? 1 : -1),
                        
                        radiusBase: Math.max(width, height) * 0.35, 
                        radiusPhase: Math.random() * Math.PI * 2,
                        radiusSpeed: 0.0005 + Math.random() * 0.0005,
                        
                        phaseZ: Math.random() * Math.PI * 2,
                        speedZ: 0.001 + Math.random() * 0.0015
                    });
                }
            }
        }

        // ========== æ•°å€¼å®‰å…¨æ€§ï¼šé˜²æ­¢å–è‰²/åŠ¨ç”»è®¡ç®—å‡ºç° NaN/Infinity å¯¼è‡´ Canvas å´©æºƒ ==========
        function __safeNum(v, fallback = 0) {
            return Number.isFinite(v) ? v : fallback;
        }
        function __safe255(v) {
            // ä¸¥æ ¼ï¼šMath.floor + || 0ï¼Œç¡®ä¿ rgba() æ°¸è¿œæ˜¯åˆæ³•æ•´æ•°
            const n = Math.floor(v) || 0;
            return Math.max(0, Math.min(255, n));
        }

        // æ ¸å¿ƒæ¸²æŸ“å¾ªç¯
        function animate(time) {

            // PERF: throttle animation on mobile/low-end devices
            const perf = (window.__LYRICS_PERF || {});
            const fps = perf.targetFps || 60;
            const minInterval = 1000 / fps;
            if (!animate.__lastFrame) animate.__lastFrame = 0;
            if (time - animate.__lastFrame < minInterval) {
              animationId = requestAnimationFrame(animate);
              return;
            }
            animate.__lastFrame = time;

            if (window.__GRADIENT_PAUSED) { animationId = requestAnimationFrame(animate); return; }
            if (!lastTime) lastTime = time;
            let deltaTime = time - lastTime;
            deltaTime = Math.min(33.33, Math.max(0, deltaTime));
            lastTime = time;

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-over';

            gradientPoints.forEach(p => {
                const speed = ANIMATION_SPEED_MULTIPLIER;
                p.phaseX += p.speedX * deltaTime * speed;
                p.phaseY += p.speedY * deltaTime * speed;
                p.radiusPhase += p.radiusSpeed * deltaTime * speed;
                p.phaseZ += p.speedZ * deltaTime * speed;

                p.x = p.baseX + Math.sin(p.phaseX) * p.rangeX / 3 + Math.sin(p.phaseZ) * p.rangeX / 6;
                p.y = p.baseY + Math.cos(p.phaseY) * p.rangeY / 3 + Math.cos(p.phaseZ) * p.rangeY / 6;

                const ease = 0.015;
                p.color.r += (p.targetColor.r - p.color.r) * ease;
                p.color.g += (p.targetColor.g - p.color.g) * ease;
                p.color.b += (p.targetColor.b - p.color.b) * ease;

                const currentRadius = p.radiusBase + Math.sin(p.radiusPhase) * (p.radiusBase * 0.1);

                const px = __safeNum(p.x, 0);
                const py = __safeNum(p.y, 0);
                const pr = Math.max(0, __safeNum(currentRadius, 0));

                let g;
                try {
                    g = ctx.createRadialGradient(px, py, 0, px, py, pr);
                } catch (e) {
                    // æç«¯æƒ…å†µä¸‹ï¼ˆä¾‹å¦‚ pr ä¸º NaN/æ— æ•ˆï¼‰ï¼Œè·³è¿‡æ­¤ç‚¹
                    return;
                }

                const r = __safe255(p.color && p.color.r);
                const gVal = __safe255(p.color && p.color.g);
                const b = __safe255(p.color && p.color.b);

                try {
                    g.addColorStop(0, `rgba(${r}, ${gVal}, ${b}, 0.8)`);
                    g.addColorStop(0.3, `rgba(${r}, ${gVal}, ${b}, 0.5)`);
                    g.addColorStop(1, `rgba(${r}, ${gVal}, ${b}, 0)`);
                } catch (e) {
                    return;
                }

                ctx.fillStyle = g;
                
                ctx.beginPath();
                ctx.arc(px, py, pr, 0, Math.PI * 2);
                ctx.fill();
            });

            animationId = requestAnimationFrame(animate);
        }

        // ========== å®Œæ•´ç‰ˆé¢œè‰²é‡åŒ–ç®—æ³•ï¼ˆä¸­ä½åˆ‡åˆ†æ³• / K-meansï¼‰ ==========
        function extractMainColors(img) {
            try {
                if (debugConsole) debugConsole.log('é¢œè‰²æå–', 'å¼€å§‹æå–ä¸“è¾‘å°é¢ä¸»è¦é¢œè‰²...', 'info');
                
                // åˆ›å»ºCanvaså¤„ç†å›¾åƒ
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                
                // è®¾ç½®Canvaså°ºå¯¸ï¼ˆé€‚å½“ç¼©å°ä»¥æé«˜æ€§èƒ½ï¼‰
                const maxSize = 200;
                let width = img.width;
                let height = img.height;
                
                if (width > maxSize || height > maxSize) {
                    const scale = maxSize / Math.max(width, height);
                    width = Math.floor(width * scale);
                    height = Math.floor(height * scale);
                }
                
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);
                
                // è·å–å›¾åƒæ•°æ®
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                // æ”¶é›†æ‰€æœ‰åƒç´ é¢œè‰²
                const pixels = [];
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    // å¿½ç•¥å®Œå…¨é€æ˜æˆ–æ¥è¿‘é€æ˜çš„åƒç´ 
                    if (data[i + 3] < 50) continue;
                    
                    pixels.push({ r, g, b });
                }
                
                if (pixels.length === 0) {
                    if (debugConsole) debugConsole.warn('é¢œè‰²æå–', 'æœªæå–åˆ°æœ‰æ•ˆåƒç´ é¢œè‰²ï¼Œä½¿ç”¨é»˜è®¤é…è‰²æ–¹æ¡ˆ');
                    return defaultPalette;
                }
                
                if (debugConsole) debugConsole.log('é¢œè‰²æå–', `æˆåŠŸé‡‡é›† ${pixels.length} ä¸ªåƒç´ ç‚¹é¢œè‰²`, 'success');
                

                // æ ¹æ®é€‰æ‹©çš„ç®—æ³•æå–é¢œè‰²
                const colorCount = 12; // éœ€è¦æå–çš„é¢œè‰²æ•°é‡
                let colors = [];

                if (COLOR_EXTRACTION_ALGO === 'kmeans') {
                    // K-meansèšç±»æå–é¢œè‰²
                    colors = kMeansQuantize(pixels, colorCount, 10);
                    if (debugConsole) debugConsole.log('é¢œè‰²æå–', `K-means æå–åˆ° ${colors.length} ç§ä¸»è¦é¢œè‰²`, 'success');
                } else {
                    // åŸç®—æ³•ï¼šä¸­ä½åˆ‡åˆ†æ³•æå–é¢œè‰²
                    const buckets = medianCut(pixels, colorCount);

                    // è®¡ç®—æ¯ä¸ªbucketçš„å¹³å‡é¢œè‰²
                    colors = buckets.map(bucket => {
                        let r = 0, g = 0, b = 0;
                        const count = bucket.length;

                        for (let i = 0; i < count; i++) {
                            r += bucket[i].r;
                            g += bucket[i].g;
                            b += bucket[i].b;
                        }

                        return {
                            r: Math.round(r / count),
                            g: Math.round(g / count),
                            b: Math.round(b / count)
                        };
                    });

                    if (debugConsole) debugConsole.log('é¢œè‰²æå–', `ä¸­ä½åˆ‡åˆ†æ³•æˆåŠŸæå– ${colors.length} ç§ä¸»è¦é¢œè‰²`, 'success');
                }

                if (debugConsole) debugConsole.log('é¢œè‰²æå–', `æå–çš„é¢œè‰²: ${JSON.stringify(colors)}`, 'info');

                return colors;
            } catch (error) {
                if (debugConsole) debugConsole.error('é¢œè‰²æå–', `é¢œè‰²æå–è¿‡ç¨‹å‡ºç°å¼‚å¸¸: ${error.message}\nå †æ ˆ: ${error.stack}`);
                return defaultPalette;
            }
        }



// K-meansèšç±»æå–ä¸»è¦é¢œè‰²
function kMeansQuantize(pixels, k = 12, maxIter = 10) {
    // ä¸ºæ€§èƒ½æ§åˆ¶ï¼šæœ€å¤šé‡‡æ ·çº¦8000ä¸ªåƒç´ 
    const maxSamples = 8000;
    let samples = pixels;
    if (pixels.length > maxSamples) {
        const stride = Math.ceil(pixels.length / maxSamples);
        samples = [];
        for (let i = 0; i < pixels.length; i += stride) {
            samples.push(pixels[i]);
        }
    }

    // éšæœºåˆå§‹åŒ–èšç±»ä¸­å¿ƒ
    const centroids = [];
    for (let i = 0; i < k; i++) {
        const p = samples[Math.floor(Math.random() * samples.length)];
        centroids.push({ r: p.r, g: p.g, b: p.b });
    }

    const assignments = new Array(samples.length).fill(-1);
    let counts = new Array(k).fill(0);

    for (let iter = 0; iter < maxIter; iter++) {
        const sumR = new Array(k).fill(0);
        const sumG = new Array(k).fill(0);
        const sumB = new Array(k).fill(0);
        counts = new Array(k).fill(0);

        let changed = false;

        for (let i = 0; i < samples.length; i++) {
            const p = samples[i];
            let best = 0;
            let bestDist = Infinity;

            for (let c = 0; c < k; c++) {
                const dr = p.r - centroids[c].r;
                const dg = p.g - centroids[c].g;
                const db = p.b - centroids[c].b;
                const dist = dr * dr + dg * dg + db * db;
                if (dist < bestDist) {
                    bestDist = dist;
                    best = c;
                }
            }

            if (assignments[i] !== best) {
                changed = true;
                assignments[i] = best;
            }

            counts[best]++;
            sumR[best] += p.r;
            sumG[best] += p.g;
            sumB[best] += p.b;
        }

        // æ›´æ–°èšç±»ä¸­å¿ƒ
        for (let c = 0; c < k; c++) {
            if (counts[c] > 0) {
                centroids[c].r = sumR[c] / counts[c];
                centroids[c].g = sumG[c] / counts[c];
                centroids[c].b = sumB[c] / counts[c];
            } else {
                // ç©ºç°‡é‡æ–°éšæœºåˆå§‹åŒ–
                const p = samples[Math.floor(Math.random() * samples.length)];
                centroids[c] = { r: p.r, g: p.g, b: p.b };
            }
        }

        if (!changed) break;
    }

    // æŒ‰ç°‡å¤§å°æ’åºï¼ˆæ›´â€œä¸»è‰²â€ä¼˜å…ˆï¼‰
    const items = centroids.map((c, idx) => ({
        r: Math.round(c.r),
        g: Math.round(c.g),
        b: Math.round(c.b),
        count: counts[idx] || 0
    })).sort((a, b) => b.count - a.count);

    return items.map(({ r, g, b }) => ({ r, g, b }));
}

        // ä¸­ä½åˆ‡åˆ†æ³•å®ç°
        function medianCut(pixels, targetColors) {
            // åˆå§‹åŒ–ä¸€ä¸ªbucketåŒ…å«æ‰€æœ‰åƒç´ 
            let buckets = [pixels];
            
            // æŒç»­åˆ‡åˆ†ç›´åˆ°è¾¾åˆ°ç›®æ ‡é¢œè‰²æ•°é‡
            while (buckets.length < targetColors) {
                // æ‰¾åˆ°æœ€å¤§çš„bucketæ¥åˆ‡åˆ†
                let largestBucketIndex = 0;
                let largestBucketSize = 0;
                
                for (let i = 0; i < buckets.length; i++) {
                    if (buckets[i].length > largestBucketSize) {
                        largestBucketSize = buckets[i].length;
                        largestBucketIndex = i;
                    }
                }
                
                const bucketToSplit = buckets[largestBucketIndex];
                
                // å¦‚æœbucketå¤ªå°ï¼Œæ— æ³•ç»§ç»­åˆ‡åˆ†
                if (bucketToSplit.length < 2) {
                    break;
                }
                
                // æ‰¾åˆ°é¢œè‰²èŒƒå›´æœ€å¤§çš„é€šé“
                let rMin = 255, rMax = 0;
                let gMin = 255, gMax = 0;
                let bMin = 255, bMax = 0;
                
                for (let i = 0; i < bucketToSplit.length; i++) {
                    const pixel = bucketToSplit[i];
                    rMin = Math.min(rMin, pixel.r);
                    rMax = Math.max(rMax, pixel.r);
                    gMin = Math.min(gMin, pixel.g);
                    gMax = Math.max(gMax, pixel.g);
                    bMin = Math.min(bMin, pixel.b);
                    bMax = Math.max(bMax, pixel.b);
                }
                
                const rRange = rMax - rMin;
                const gRange = gMax - gMin;
                const bRange = bMax - bMin;
                
                // ç¡®å®šåˆ‡åˆ†é€šé“
                let splitChannel;
                if (rRange >= gRange && rRange >= bRange) {
                    splitChannel = 'r';
                } else if (gRange >= rRange && gRange >= bRange) {
                    splitChannel = 'g';
                } else {
                    splitChannel = 'b';
                }
                
                // æŒ‰é€‰å®šé€šé“æ’åº
                bucketToSplit.sort((a, b) => a[splitChannel] - b[splitChannel]);
                
                // æ‰¾åˆ°ä¸­ä½æ•°
                const medianIndex = Math.floor(bucketToSplit.length / 2);
                
                // åˆ‡åˆ†bucket
                const bucket1 = bucketToSplit.slice(0, medianIndex);
                const bucket2 = bucketToSplit.slice(medianIndex);
                
                // æ›¿æ¢åŸbucketä¸ºä¸¤ä¸ªæ–°bucket
                buckets.splice(largestBucketIndex, 1, bucket1, bucket2);
            }
            
            return buckets;
        }

        // ä»ä¸“è¾‘å°é¢æå–ä¸»è¦é¢œè‰²
        function updateGradientFromAlbum(imageUrl) {
            if (!imageUrl) {
                if (debugConsole) debugConsole.warn('æ¸å˜èƒŒæ™¯', 'æ— ä¸“è¾‘å°é¢URLï¼Œä½¿ç”¨é»˜è®¤é¢œè‰²');
                gradientPoints.forEach((p, i) => {
                    const newColor = defaultPalette[i % defaultPalette.length];
                    p.targetColor = { ...newColor };
                });
                return;
            }
            
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                try {
                    if (debugConsole) debugConsole.log('æ¸å˜èƒŒæ™¯', 'å¼€å§‹ä»ä¸“è¾‘å°é¢æå–é¢œè‰²...', 'info');
                    const colors = extractMainColors(img);
                    
                    // ç¡®ä¿æˆ‘ä»¬æœ‰è¶³å¤Ÿçš„é¢œè‰²
                    let extendedColors = [];
                    while (extendedColors.length < 36) {
                        extendedColors = extendedColors.concat(colors);
                    }
                    
                    // æ›´æ–°æ¸å˜ç‚¹çš„ç›®æ ‡é¢œè‰²
                    gradientPoints.forEach((p, i) => {
                        const newColor = extendedColors[i];
                        if (newColor) {
                            p.targetColor = { ...newColor };
                        }
                    });
                    
                    if (debugConsole) debugConsole.success('æ¸å˜èƒŒæ™¯', 'ä¸“è¾‘å°é¢é¢œè‰²æå–å®Œæˆï¼Œæ¸å˜èƒŒæ™¯å·²æ›´æ–°');
                } catch (error) {
                    if (debugConsole) debugConsole.error('æ¸å˜èƒŒæ™¯', `ä¸“è¾‘å°é¢é¢œè‰²æå–å¤±è´¥: ${error.message}`);
                }
            };
            
            img.onerror = (e) => {
                if (debugConsole) debugConsole.error('æ¸å˜èƒŒæ™¯', `ä¸“è¾‘å°é¢å›¾ç‰‡åŠ è½½å¤±è´¥: ${imageUrl}\né”™è¯¯ä¿¡æ¯: ${e.message}`);
                // åŠ è½½å¤±è´¥ä½¿ç”¨é»˜è®¤è‰²
                gradientPoints.forEach((p, i) => {
                    const newColor = defaultPalette[i % defaultPalette.length];
                    p.targetColor = { ...newColor };
                });
            };
            
            img.src = imageUrl;
        }

        function startGradientAnimation() {
            if (animationId) cancelAnimationFrame(animationId);
            resizeCanvas();
            initGradientPoints(); 
            animate(0);
            if (debugConsole) debugConsole.log('æ¸å˜èƒŒæ™¯', 'åŠ¨æ€æ¸å˜èƒŒæ™¯ç³»ç»Ÿå·²å¯åŠ¨', 'success');
        }

        </script><script>
/* =========================================================
   æ­Œè¯ API æ¨¡å—ï¼ˆè¿ç§»è‡ª index_final_fixed.htmlï¼‰
   åŒ…å«ï¼šAPI_CONFIG / checkRateLimit / tunehubRequest / gdstudioRequest / apiRequest / searchMusic
   è¯´æ˜ï¼šæœ¬é¡µç”¨äºâ€œæ­Œè¯å¡ç‰‡ç”Ÿæˆå™¨â€ï¼Œä¸åŒ…å«éŸ³é¢‘æ’­æ”¾ï¼›ç‚¹å‡»æœç´¢ç»“æœä¼šè§¦å‘ playTrack(å…¼å®¹å ä½)ã€‚
========================================================= */

/* DebugConsole å…¼å®¹å ä½ï¼ˆä¿ç•™ index ä»£ç ä¸­çš„è°ƒç”¨ï¼‰ */
window.debugConsole = window.debugConsole || {
  log: () => {}, info: () => {}, warn: () => {}, error: () => {}, api: () => {}, success: () => {}
};

// ========== æ­Œè¯å¡ç‰‡é¡µï¼šç§»æ¤æ’­æ”¾å™¨ UI å¼•ç”¨ï¼ˆå¿…é¡»å­˜åœ¨ï¼Œé¿å…æ‰“å¼€å³å´©æºƒï¼‰ ==========
// æ³¨æ„ï¼šæœ¬é¡µä¸æ’­æ”¾éŸ³é¢‘ï¼Œä½†ä¿ç•™å®Œæ•´å­—æ®µä¸é€»è¾‘ï¼ˆå¦‚ qualitySelectï¼‰ã€‚
let searchInput = document.getElementById('searchInput');
let apiSelect = document.getElementById('apiSelect');
let algoToggleBtn = document.getElementById('algoToggleBtn');
let sourceSelect = document.getElementById('sourceSelect');
let searchBtn = document.getElementById('searchBtn');
let resultsContainer = document.getElementById('resultsContainer');
let qualitySelect = document.getElementById('qualitySelect');

let searchResults = [];
let currentTrack = null;
let requestTimestamps = [];
let currentAlbumUrl = null;

const API_CONFIG = {
            gdstudio: {
                name: 'åŸAPI (GDStudio)',
                baseUrl: '/api.php',
                // åŸAPIéŸ³è´¨é€‰é¡¹
                qualities: [
                    { value: '128', label: 'æ ‡å‡†å“è´¨ (128k)' },
                    { value: '192', label: 'è‰¯å¥½å“è´¨ (192k)' },
                    { value: '320', label: 'é«˜å“è´¨ (320k)' },
                    { value: '740', label: 'æ— æŸå“è´¨ (740k)' },
                    { value: '999', label: 'é«˜è§£æåº¦ (999k)' }
                ]
            },
            tunehub: {
                name: 'å¤‡ç”¨API (TuneHub)',
                baseUrl: '/api.php',
                // TuneHub APIéŸ³è´¨é€‰é¡¹ - ä¸éŸ³ä¹ä¸‹è½½.htmlå®Œå…¨ä¸€è‡´
                qualities: [
                    { value: '128k', label: 'æ ‡å‡†å“è´¨ (128k)' },
                    { value: '320k', label: 'é«˜å“è´¨ (320k)' },
                    { value: 'flac', label: 'æ— æŸå“è´¨ (FLAC)' },
                    { value: 'flac24bit', label: 'é«˜è§£æåº¦ (24bit FLAC)' }
                ]
            }
        };

        // æ›´æ–°éŸ³ä¹æºé€‰æ‹©é€‰é¡¹
        function updateSourceOptions() {
            const api = apiSelect.value;
            const sourceOptions = sourceSelect.options;
            
            // é‡ç½®æ‰€æœ‰é€‰é¡¹
            for (let i = 0; i < sourceOptions.length; i++) {
                sourceOptions[i].disabled = false;
                sourceOptions[i].style.display = '';
            }
            
            if (api === 'tunehub') {
                // TuneHub APIæ”¯æŒçš„å¹³å°
                if (debugConsole) debugConsole.info('APIåˆ‡æ¢', 'åˆ‡æ¢åˆ°TuneHub APIï¼Œæ›´æ–°å¹³å°é€‰é¡¹');
                
                // å¯ç”¨TuneHubæ”¯æŒçš„é€‰é¡¹ï¼Œç¦ç”¨ä¸æ”¯æŒçš„
                for (let i = 0; i < sourceOptions.length; i++) {
                    const option = sourceOptions[i];
                    const value = option.value;
                    
                    // TuneHubæ”¯æŒçš„å¹³å°ï¼šnetease, kuwo, qq, aggregate
                    if (value === 'netease' || value === 'kuwo' || value === 'qq' || value === 'aggregate') {
                        option.disabled = false;
                        option.style.display = '';
                    } else {
                        option.disabled = true;
                        option.style.display = 'none';
                    }
                }
                
                // è®¾ç½®é»˜è®¤å€¼
                if (!['netease', 'kuwo', 'qq', 'aggregate'].includes(sourceSelect.value)) {
                    sourceSelect.value = 'netease';
                }
            } else {
                // åŸAPIæ”¯æŒçš„å¹³å°
                if (debugConsole) debugConsole.info('APIåˆ‡æ¢', 'åˆ‡æ¢åˆ°åŸAPIï¼Œæ¢å¤å¹³å°é€‰é¡¹');
                
                // æ¢å¤æ‰€æœ‰é€‰é¡¹
                for (let i = 0; i < sourceOptions.length; i++) {
                    const option = sourceOptions[i];
                    const value = option.value;
                    
                    // åŸAPIæ”¯æŒçš„å¹³å°ï¼škuwo, joox, netease
                    if (value === 'kuwo' || value === 'joox' || value === 'netease') {
                        option.disabled = false;
                        option.style.display = '';
                    } else {
                        option.disabled = true;
                        option.style.display = 'none';
                    }
                }
                
                // è®¾ç½®é»˜è®¤å€¼
                if (!['kuwo', 'joox', 'netease'].includes(sourceSelect.value)) {
                    sourceSelect.value = 'kuwo';
                }
            }
        }

        // æ›´æ–°éŸ³è´¨é€‰é¡¹
        function updateQualityOptions() {
            const api = apiSelect.value;
            const apiConfig = API_CONFIG[api];
    try { url.searchParams.set('api', api); } catch {}
            const qualitySelect = document.getElementById('qualitySelect');
            
            // æ¸…ç©ºç°æœ‰é€‰é¡¹
            qualitySelect.innerHTML = '';
            
            // æ·»åŠ æ–°é€‰é¡¹
            apiConfig.qualities.forEach(quality => {
                const option = document.createElement('option');
                option.value = quality.value;
                option.textContent = quality.label;
                qualitySelect.appendChild(option);
            });
            
            if (debugConsole) debugConsole.info('éŸ³è´¨é€‰é¡¹', `å·²æ›´æ–°ä¸º ${apiConfig.name} çš„éŸ³è´¨é€‰é¡¹`);
        }

        // APIé€‰æ‹©å™¨äº‹ä»¶
        apiSelect.addEventListener('change', () => {
            if (debugConsole) debugConsole.info('APIåˆ‡æ¢', `åˆ‡æ¢åˆ°: ${apiSelect.value} - ${API_CONFIG[apiSelect.value].name}`);
            updateSourceOptions();
            updateQualityOptions();
        });

        // åˆå§‹åŒ–æ—¶æ›´æ–°é€‰é¡¹
        updateSourceOptions();
        updateQualityOptions();

        // --- Event Listeners (æœç´¢éƒ¨åˆ†ï¼Œç§»æ¤è‡ªè°ƒè¯•ç‰ˆ index.html) ---
        if (searchBtn) {
            searchBtn.onclick = () => {
                const kw = (searchInput && searchInput.value) ? searchInput.value : '';
                try {
                    if (debugConsole) debugConsole.info('æœç´¢', `æ‰‹åŠ¨è§¦å‘æœç´¢: "${kw}" (API: ${apiSelect.value}, æº: ${sourceSelect.value})`);
                } catch (_) {}
                searchMusic(kw, sourceSelect.value);
            };
        }

        if (searchInput) {
            searchInput.onkeypress = (e) => {
                if (e.key === 'Enter') {
                    try {
                        if (debugConsole) debugConsole.info('æœç´¢', `å›è½¦é”®è§¦å‘æœç´¢: "${searchInput.value}"`);
                    } catch (_) {}
                    if (searchBtn) searchBtn.click();
                }
            };
        }


// ========== é¢œè‰²æå–ç®—æ³•åˆ‡æ¢ï¼ˆåŸï¼šä¸­ä½åˆ‡åˆ† / æ–°ï¼šK-meansï¼‰ ==========
// ========== å®‰å…¨å­˜å‚¨å°è£…ï¼ˆåº”å¯¹ Tracking Prevention / éšç§æ¨¡å¼ï¼‰ ==========
const StorageSafe = (() => {
    const mem = Object.create(null);
    let available = false;
    let warned = false;

    try {
        const k = '__lyrics_card_ls_test__';
        localStorage.setItem(k, '1');
        localStorage.removeItem(k);
        available = true;
    } catch (e) {
        available = false;
    }

    const warnOnce = () => {
        if (warned) return;
        warned = true;
        const msg = 'æµè§ˆå™¨é˜»æ­¢äº†æœ¬åœ°å­˜å‚¨è®¿é—®ï¼šè®¾ç½®å°†ä¸ä¼šæŒä¹…åŒ–ï¼ˆå¯æ­£å¸¸ä½¿ç”¨ï¼‰ã€‚';
        try { console.warn('[StorageSafe]', msg); } catch (_) {}
        try { if (typeof dcWarn === 'function') dcWarn('å­˜å‚¨', msg); } catch (_) {}
        // è½»æç¤ºï¼ˆä¸é˜»å¡ï¼‰
        try {
            const el = document.getElementById('status');
            if (el) {
                const old = el.textContent;
                el.textContent = msg;
                setTimeout(() => { try { el.textContent = old; } catch (_) {} }, 3000);
            }
        } catch (_) {}
    };

    const get = (key) => {
        try {
            if (available) return localStorage.getItem(key);
        } catch (e) {
            available = false;
            warnOnce();
        }
        return Object.prototype.hasOwnProperty.call(mem, key) ? mem[key] : null;
    };

    const set = (key, value) => {
        const v = value == null ? '' : String(value);
        try {
            if (available) { localStorage.setItem(key, v); return; }
        } catch (e) {
            available = false;
            warnOnce();
        }
        mem[key] = v;
    };

    const remove = (key) => {
        try {
            if (available) { localStorage.removeItem(key); return; }
        } catch (e) {
            available = false;
            warnOnce();
        }
        delete mem[key];
    };

    const clear = () => {
        try {
            if (available) { localStorage.clear(); return; }
        } catch (e) {
            available = false;
            warnOnce();
        }
        for (const k of Object.keys(mem)) delete mem[k];
    };

    const isAvailable = () => available;

    return { get, set, remove, clear, isAvailable, warnOnce };
})();

let COLOR_EXTRACTION_ALGO = StorageSafe.get('colorExtractionAlgo') || 'medianCut'; // 'medianCut' | 'kmeans' // 'medianCut' | 'kmeans'

function updateAlgoToggleButton() {
    if (!algoToggleBtn) return;
    algoToggleBtn.textContent = COLOR_EXTRACTION_ALGO === 'kmeans' ? 'ç®—æ³•ï¼šK-means' : 'ç®—æ³•ï¼šåŸ(ä¸­ä½åˆ‡åˆ†)';
}

if (algoToggleBtn) {
    updateAlgoToggleButton();
    algoToggleBtn.addEventListener('click', () => {
        COLOR_EXTRACTION_ALGO = (COLOR_EXTRACTION_ALGO === 'kmeans') ? 'medianCut' : 'kmeans';
        try { StorageSafe.set('colorExtractionAlgo', COLOR_EXTRACTION_ALGO); } catch (e) { /* storage blocked */ }
        updateAlgoToggleButton();
        if (debugConsole) debugConsole.info('é¢œè‰²æå–', `å·²åˆ‡æ¢é¢œè‰²æå–ç®—æ³•ä¸º: ${COLOR_EXTRACTION_ALGO === 'kmeans' ? 'K-means' : 'åŸ(ä¸­ä½åˆ‡åˆ†)'}`);

        // å¦‚æœå½“å‰å·²æœ‰ä¸“è¾‘å°é¢ï¼Œç«‹å³æŒ‰æ–°ç®—æ³•åˆ·æ–°èƒŒæ™¯
        if (currentAlbumUrl) {
            updateGradientFromAlbum(currentAlbumUrl);
        }
    });
}


        function checkRateLimit() {
            const now = Date.now();
            const fiveMinutesAgo = now - 5 * 60 * 1000;
            requestTimestamps = requestTimestamps.filter(timestamp => timestamp > fiveMinutesAgo);
            
            if (requestTimestamps.length >= 60) {
                const message = 'APIè¯·æ±‚é¢‘ç‡è¿‡é«˜ï¼Œå·²è¶…è¿‡é™åˆ¶ï¼ˆ5åˆ†é’Ÿå†…æœ€å¤š60æ¬¡è¯·æ±‚ï¼‰ã€‚è¯·ç­‰å¾…5åˆ†é’Ÿåå†è¯•ã€‚å½“å‰è¯·æ±‚æ¬¡æ•°ï¼š' + requestTimestamps.length;
                if (debugConsole) debugConsole.error('APIé™åˆ¶', message);
                return false;
            }
            
            requestTimestamps.push(now);
            if (debugConsole) debugConsole.info('APIè¯·æ±‚', `å½“å‰5åˆ†é’Ÿå†…APIè¯·æ±‚æ¬¡æ•°: ${requestTimestamps.length}/60`);
            return true;
        }

        // TuneHub APIè¯·æ±‚å‡½æ•° - å®Œå…¨æŒ‰ç…§éŸ³ä¹ä¸‹è½½.htmlçš„æ–¹å¼
        async function tunehubRequest(params) {
            try {
                const apiConfig = API_CONFIG.tunehub;
                const url = new URL(apiConfig.baseUrl);
                
                // ç›´æ¥ä½¿ç”¨å‚æ•°ï¼Œä¸è¿›è¡Œæ˜ å°„
                Object.keys(params).forEach(k => {
                    if (params[k] !== undefined && params[k] !== null) {
                        url.searchParams.append(k, params[k]);
                    }
                });
                
                const urlString = url.toString();
                if (debugConsole) debugConsole.api('TuneHub APIè¯·æ±‚', `å‘é€è¯·æ±‚: ${urlString}`);
                
                const response = await fetch(urlString);
                
                if (!response.ok) {
                    const errorMsg = `HTTPè¯·æ±‚å¤±è´¥: çŠ¶æ€ç  ${response.status} ${response.statusText}`;
                    if (debugConsole) debugConsole.error('TuneHub APIè¯·æ±‚', errorMsg);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // éŸ³é¢‘URLè¯·æ±‚è¿”å›æ–‡æœ¬
                if (params.type === 'url') {
                    const audioUrl = await response.text();
                    if (debugConsole) debugConsole.api('TuneHub APIè¯·æ±‚', `éŸ³é¢‘URLè·å–æˆåŠŸ: ${audioUrl.substring(0, 100)}...`);
                    return { url: audioUrl };
                }
                
                // å…¶ä»–è¯·æ±‚è¿”å›JSON
                const data = await response.json();
                if (debugConsole) debugConsole.api('TuneHub APIè¯·æ±‚', `è¯·æ±‚æˆåŠŸï¼Œè¿”å›æ•°æ®`);
                return data;
            } catch (error) {
                const errorMsg = `TuneHub APIè¯·æ±‚å¼‚å¸¸: ${error.message}\né”™è¯¯å †æ ˆ: ${error.stack}`;
                if (debugConsole) debugConsole.error('TuneHub APIè¯·æ±‚', errorMsg);
                return null;
            }
        }

        // åŸAPIè¯·æ±‚å‡½æ•°
        async function gdstudioRequest(params) {
            try {
                const apiConfig = API_CONFIG.gdstudio;
                const queryString = new URLSearchParams(params).toString();
                const url = `${apiConfig.baseUrl}?${queryString}`;
                
                if (debugConsole) debugConsole.api('åŸAPIè¯·æ±‚', `å‘é€è¯·æ±‚: ${url}`);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    const errorMsg = `HTTPè¯·æ±‚å¤±è´¥: çŠ¶æ€ç  ${response.status} ${response.statusText}`;
                    if (debugConsole) debugConsole.error('åŸAPIè¯·æ±‚', errorMsg);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                if (debugConsole) debugConsole.api('åŸAPIè¯·æ±‚', `è¯·æ±‚æˆåŠŸï¼Œè¿”å›æ•°æ®`);
                return data;
            } catch (error) {
                const errorMsg = `åŸAPIè¯·æ±‚å¼‚å¸¸: ${error.message}\né”™è¯¯å †æ ˆ: ${error.stack}`;
                if (debugConsole) debugConsole.error('åŸAPIè¯·æ±‚', errorMsg);
                return null;
            }
        }

        // ç»Ÿä¸€APIè¯·æ±‚å‡½æ•°
        async function apiRequest(params, apiType = null) {
            const api = apiType || apiSelect.value;
            
            if (!checkRateLimit()) {
                const errorMsg = 'APIè¯·æ±‚é¢‘ç‡é™åˆ¶ï¼š5åˆ†é’Ÿå†…æœ€å¤š60æ¬¡è¯·æ±‚ï¼Œå½“å‰å·²è¶…é™ã€‚';
                if (debugConsole) debugConsole.error('APIé™åˆ¶', errorMsg);
                return null;
            }
            
            if (api === 'gdstudio') {
                return await gdstudioRequest(params);
            } else if (api === 'tunehub') {
                // å°†åŸAPIå‚æ•°è½¬æ¢ä¸ºTuneHubå‚æ•°
                let tunehubParams = {};
                
                if (params.types === 'search') {
                    // å¤„ç†èšåˆæœç´¢
                    if (params.source === 'aggregate') {
                        tunehubParams = {
                            type: 'aggregateSearch',
                            keyword: params.name,
                            limit: params.count || 20
                        };
                    } else {
                        tunehubParams = {
                            source: params.source,
                            type: 'search',
                            keyword: params.name,
                            limit: params.count || 20,
                            page: params.pages || 1
                        };
                    }
                } else if (params.types === 'url') {
                    // ç›´æ¥ä½¿ç”¨éŸ³ä¹ä¸‹è½½.htmlä¸­çš„æ–¹å¼
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'url',
                        br: params.br // ç›´æ¥ä½¿ç”¨éŸ³è´¨å€¼ï¼Œä¸æ˜ å°„
                    };
                } else if (params.types === 'pic') {
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'pic'
                    };
                } else if (params.types === 'lyric') {
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'lrc'
                    };
                }
                
                return await tunehubRequest(tunehubParams);
            }
        }

        async function searchMusic(keyword, source = null) {
            if (!keyword.trim()) {
                const errorMsg = 'æœç´¢å¤±è´¥: æœç´¢å…³é”®è¯ä¸ºç©ºï¼Œè¯·è¾“å…¥æœ‰æ•ˆçš„æ­Œæ›²åã€æ­Œæ‰‹åæˆ–ä¸“è¾‘åè¿›è¡Œæœç´¢ã€‚';
                if (debugConsole) debugConsole.error('æœç´¢', errorMsg);
                
                const d = document.createElement('div');
                d.className = 'error';
                d.textContent = 'è¯·è¾“å…¥æœç´¢å…³é”®è¯';
                resultsContainer.prepend(d);
                setTimeout(() => d.remove(), 4000);
                return;
            }
            
            const api = apiSelect.value;
            const selectedSource = source || sourceSelect.value;
            
            if (debugConsole) debugConsole.info('æœç´¢', `å¼€å§‹æœç´¢: "${keyword}" (API: ${api}, æº: ${selectedSource})`);
            resultsContainer.innerHTML = '<div class="loading">æœç´¢ä¸­...</div>';
            
            let data;
            if (api === 'gdstudio') {
                // åŸAPIæœç´¢
                data = await apiRequest({
                    types: 'search',
                    source: selectedSource,
                    name: keyword,
                    count: 20,
                    pages: 1
                });
            } else if (api === 'tunehub') {
                // TuneHub APIæœç´¢
                data = await apiRequest({
                    types: 'search',
                    source: selectedSource,
                    name: keyword,
                    count: 20,
                    pages: 1
                });
            }
            
            if (data) {
                if (api === 'gdstudio' && Array.isArray(data) && data.length > 0) {
                    // åŸAPIæœç´¢ç»“æœ - æ·»åŠ å¹³å°ä¿¡æ¯
                    searchResults = data.map(track => ({
                        ...track,
                        platform: selectedSource,
                        api: 'gdstudio'
                    }));
                    if (debugConsole) debugConsole.success('æœç´¢', `æœç´¢æˆåŠŸï¼Œæ‰¾åˆ° ${data.length} ä¸ªç»“æœ`);
                    displaySearchResults(searchResults, api);
                } else if (api === 'tunehub' && data.code === 200 && data.data) {
                    // TuneHubè¿”å›çš„æ•°æ®æ ¼å¼
                    let tracks = [];
                    
                    if (selectedSource === 'aggregate') {
                        // èšåˆæœç´¢è¿”å›çš„æ•°æ®æ ¼å¼
                        if (data.data.results && Array.isArray(data.data.results)) {
                            tracks = data.data.results.map(item => ({
                                id: item.id,
                                name: item.name,
                                artist: item.artist || 'æœªçŸ¥è‰ºæœ¯å®¶',
                                album: item.album || 'æœªçŸ¥ä¸“è¾‘',
                                pic_id: item.id,
                                pic_url: item.pic,
                                lyric_id: item.id,
                                source: item.platform,
                                platform: item.platform,
                                api: 'tunehub'
                            }));
                        }
                    } else {
                        // æ™®é€šæœç´¢è¿”å›çš„æ•°æ®æ ¼å¼
                        if (data.data.results && Array.isArray(data.data.results)) {
                            tracks = data.data.results.map(item => ({
                                id: item.id,
                                name: item.name,
                                artist: item.artist || 'æœªçŸ¥è‰ºæœ¯å®¶',
                                album: item.album || 'æœªçŸ¥ä¸“è¾‘',
                                pic_id: item.id,
                                pic_url: item.pic,
                                lyric_id: item.id,
                                source: selectedSource,
                                platform: selectedSource,
                                api: 'tunehub'
                            }));
                        }
                    }
                    
                    if (tracks.length > 0) {
                        searchResults = tracks;
                        if (debugConsole) debugConsole.success('æœç´¢', `æœç´¢æˆåŠŸï¼Œæ‰¾åˆ° ${tracks.length} ä¸ªç»“æœ`);
                        displaySearchResults(tracks, api);
                    } else {
                        if (debugConsole) debugConsole.warn('æœç´¢', `æœªæ‰¾åˆ°ç›¸å…³ç»“æœï¼Œå…³é”®è¯: "${keyword}"ï¼ŒAPI: ${api}ï¼Œæº: ${selectedSource}`);
                        resultsContainer.innerHTML = '<div class="loading">æœªæ‰¾åˆ°ç»“æœ</div>';
                    }
                } else {
                    if (debugConsole) debugConsole.warn('æœç´¢', `æœªæ‰¾åˆ°ç›¸å…³ç»“æœï¼Œå…³é”®è¯: "${keyword}"ï¼ŒAPI: ${api}ï¼Œæº: ${selectedSource}`);
                    resultsContainer.innerHTML = '<div class="loading">æœªæ‰¾åˆ°ç»“æœ</div>';
                }
            } else {
                if (debugConsole) debugConsole.warn('æœç´¢', `APIè¿”å›ç©ºæ•°æ®ï¼Œå…³é”®è¯: "${keyword}"ï¼ŒAPI: ${api}ï¼Œæº: ${selectedSource}`);
                resultsContainer.innerHTML = '<div class="loading">æœªæ‰¾åˆ°ç»“æœ</div>';
            }
        }

function displaySearchResults(results, api) {
            resultsContainer.innerHTML = '';
            
            if (results.length === 0) {
                resultsContainer.innerHTML = '<div class="loading">æœªæ‰¾åˆ°ç»“æœ</div>';
                return;
            }
            
            results.forEach((track) => {
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                if (currentTrack && currentTrack.id === track.id && currentTrack.api === track.api) {
                    resultItem.classList.add('active');
                }
                
                // æ ¹æ®APIæ„å»ºä¸“è¾‘å°é¢URL
                let albumArtUrl;
                if (api === 'gdstudio') {
                    albumArtUrl = track.pic_id ? 
                        `/api.php?types=pic&source=${track.source}&id=${track.pic_id}&size=150` : 
                        'https://placehold.co/50x50/333333/ffffff?text=â™ª';
                } else if (api === 'tunehub') {
                    // TuneHub: ä¼˜å…ˆä½¿ç”¨pic_urlï¼Œå¦‚æœæ²¡æœ‰åˆ™ç”¨idæ„å»º
                    if (track.pic_url) {
                        albumArtUrl = track.pic_url;
                    } else if (track.pic_id) {
                        albumArtUrl = `/api.php?type=pic&source=${track.source}&id=${track.pic_id}`;
                    } else {
                        albumArtUrl = 'https://placehold.co/50x50/333333/ffffff?text=â™ª';
                    }
                }

                // è·å–å¹³å°æ˜¾ç¤ºåç§°
                let platformName = '';
                let platformClass = '';
                if (track.platform) {
                    platformName = track.platform.toUpperCase();
                    platformClass = track.platform;
                }

                resultItem.innerHTML = `
                    <img src="${albumArtUrl}" class="result-album" onerror="this.src='https://placehold.co/50x50/333333/ffffff?text=â™ª'">
                    <div class="result-info">
                        <div class="result-title">${track.name || 'æœªçŸ¥æ­Œæ›²'}</div>
                        <div class="result-artist">${track.artist || 'æœªçŸ¥è‰ºæœ¯å®¶'}</div>
                        <div class="result-album-name">${track.album || 'æœªçŸ¥ä¸“è¾‘'}</div>
                        <div class="result-platform-info">
                            <span class="platform-badge ${platformClass}">${platformName}</span>
                            <span class="api-select-label">${track.api === 'tunehub' ? 'å¤‡ç”¨API' : 'åŸAPI'}</span>
                        </div>
                    </div>
                `;
                
                resultItem.__trackData = track;

                // Fix: iOS è§¦æ§/é¼ æ ‡äº‹ä»¶åŒç»‘å®šï¼ˆé¿å… click å»¶è¿Ÿ/ä¸¢å¤±ï¼ŒåŒæ—¶é˜²æ­¢ touch åé‡å¤è§¦å‘ clickï¼‰
                let __riLastTouch = 0;
                const __onSelect = (evt) => {
                    try { markUserGesture(); } catch (_) {}
                    try { unlockIOSAudioOnce('select-track'); } catch (_) {}

                    if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', `ç‚¹å‡»æ’­æ”¾æ­Œæ›²: ${track.name} - ${track.artist} (API: ${track.api || api}, å¹³å°: ${track.platform})`);
                    playTrack(track);
                    document.querySelectorAll('.result-item').forEach(item => item.classList.remove('active'));
                    resultItem.classList.add('active');
                };

                resultItem.addEventListener('touchstart', () => { try { markUserGesture(); } catch (_) {} }, { passive: true });
                resultItem.addEventListener('touchend', (e) => {
                    __riLastTouch = Date.now();
                    try { if (e && e.cancelable) e.preventDefault(); } catch (_) {}
                    __onSelect(e);
                }, { passive: false });

                resultItem.addEventListener('mousedown', () => { try { markUserGesture(); } catch (_) {} }, { passive: true });
                resultItem.addEventListener('mouseup', () => { try { markUserGesture(); } catch (_) {} }, { passive: true });

                resultItem.addEventListener('click', (e) => {
                    // iOS: touchend åé€šå¸¸è¿˜ä¼šè§¦å‘ä¸€æ¬¡ clickï¼Œè¿™é‡ŒæŠ‘åˆ¶é‡å¤
                    if (Date.now() - __riLastTouch < 800) {
                        try { e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation(); } catch (_) {}
                        return;
                    }
                    __onSelect(e);
                });
                
                resultsContainer.appendChild(resultItem);
            });
            
            if (debugConsole) debugConsole.success('æœç´¢ç»“æœ', `æˆåŠŸæ¸²æŸ“ ${results.length} ä¸ªæœç´¢ç»“æœ`);
        }

/* å…¼å®¹ï¼šindex çš„æœç´¢ç»“æœç‚¹å‡»ä¼šè°ƒç”¨ playTrackï¼Œè¿™é‡Œæä¾›å¡ç‰‡é¡µå ä½å®ç° */
async function playTrack(track) {
  if (typeof window.__lyricsCardApplyTrack === 'function') {
    return window.__lyricsCardApplyTrack(track);
  }
  console.warn('playTrack called, but __lyricsCardApplyTrack is not wired.', track);
}
</script><script>/* =========================================================
   å¤šèƒŒæ™¯ç³»ç»Ÿï¼ˆé›†æˆç‰ˆï¼‰- å…³é”®è¯´æ˜
   1) æœ¬è„šæœ¬åœ¨ä¸æ”¹åŠ¨åŸæ’­æ”¾å™¨æ ¸å¿ƒé€»è¾‘çš„å‰æä¸‹ï¼Œæ–°å¢ï¼š
      - Pixi åŠ¨æ€èƒŒæ™¯ï¼ˆçº¯ WebGLï¼Œæ— å¤–éƒ¨åº“ï¼‰
      - Mesh æ¸å˜èƒŒæ™¯ï¼ˆçº¯ WebGLï¼Œæ— å¤–éƒ¨åº“ï¼‰
      - èƒŒæ™¯ç®¡ç†å™¨ + èµ„æºé‡Šæ”¾ + æŠ˜å å¼æ§åˆ¶é¢æ¿
   2) èƒŒæ™¯æ›´æ–°ç­–ç•¥ï¼š
      - é»˜è®¤è·Ÿéšä¸“è¾‘å°é¢ï¼ˆMutationObserver ç›‘å¬ #albumArt.src å˜åŒ–ï¼‰
      - è‹¥ç”¨æˆ·åœ¨èƒŒæ™¯æ§åˆ¶é¢æ¿ä¸­æ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶/URLï¼Œå°†è‡ªåŠ¨å…³é—­â€œè·Ÿéšä¸“è¾‘å°é¢â€
   ========================================================= */

(() => {
    // 1. åˆå§‹åŒ–æ—¥å¿—ï¼ˆæŒ‰éœ€æ±‚å¿…é¡»åŒ…å«ï¼‰
    console.log("=== éŸ³ä¹æ’­æ”¾å™¨èƒŒæ™¯ç³»ç»Ÿå¯åŠ¨ ===");
    console.log("æ—¶é—´:", new Date().toISOString());
    console.log("å¯ç”¨åŠŸèƒ½:", ["å–è‰²å™¨", "æ’­æ”¾æ§åˆ¶", "KMeans", "APIè”åŠ¨"]);

    // 3. é”™è¯¯ç›‘æ§ï¼ˆæŒ‰éœ€æ±‚å¿…é¡»åŒ…å«ï¼‰
    window.addEventListener('error', (e) => {
        // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.error ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
        try { console.error("[å…¨å±€é”™è¯¯]", {
            æ¶ˆæ¯: e.message,
            æ–‡ä»¶: e.filename,
            è¡Œå·: e.lineno,
            åˆ—å·: e.colno,
            æ—¶é—´: new Date().toLocaleTimeString()
        }); } catch (e) { try { console.log("[å…¨å±€é”™è¯¯]", {
            æ¶ˆæ¯: e.message,
            æ–‡ä»¶: e.filename,
            è¡Œå·: e.lineno,
            åˆ—å·: e.colno,
            æ—¶é—´: new Date().toLocaleTimeString()
        }); } catch (_) {} }
    });

    window.addEventListener('unhandledrejection', (event) => {
        // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.error ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
        try { console.error("[æœªå¤„ç†Promiseæ‹’ç»]", {
            åŸå› : event.reason,
            æ—¶é—´: new Date().toLocaleTimeString()
        }); } catch (e) { try { console.log("[æœªå¤„ç†Promiseæ‹’ç»]", {
            åŸå› : event.reason,
            æ—¶é—´: new Date().toLocaleTimeString()
        }); } catch (_) {} }
    });

    // 4. çŠ¶æ€æŠ¥å‘Šå‡½æ•°ï¼ˆæŒ‰éœ€æ±‚å¿…é¡»æä¾›ï¼‰
    window.reportPlayerStatus = function() {
        const bgType = window.__bgManager ? window.__bgManager.getCurrentType() : 'æœªçŸ¥';
        const hasAlbumArt = !!document.getElementById('albumArt')?.src;
        const audio = document.getElementById('audioPlayer');
        const audioReady = !!audio;
        const hasKMeans = typeof window.kMeansQuantize === 'function' || typeof kMeansQuantize === 'function';
        const hasApi = typeof window.apiRequest === 'function' || typeof apiRequest === 'function';

        console.table({
            "åŠŸèƒ½æ¨¡å—": ["èƒŒæ™¯ç³»ç»Ÿ", "å–è‰²å™¨", "éŸ³é¢‘æ’­æ”¾", "APIè¿æ¥", "KMeansç®—æ³•"],
            "è¿è¡ŒçŠ¶æ€": [
                bgType ? `âœ“æ­£å¸¸ï¼ˆ${bgType}ï¼‰` : "âœ—å¼‚å¸¸",
                hasAlbumArt ? "âœ“æ­£å¸¸" : "âš æœªåŠ è½½å°é¢",
                audioReady ? "âœ“æ­£å¸¸" : "âœ—ç¼ºå°‘audioå…ƒç´ ",
                hasApi ? "âœ“æ­£å¸¸" : "âš æœªæ£€æµ‹åˆ°apiRequestï¼ˆå¯èƒ½åœ¨é—­åŒ…å†…ï¼‰",
                hasKMeans ? "âœ“æ­£å¸¸" : "âš æœªæ£€æµ‹åˆ°kMeansQuantizeï¼ˆå¯èƒ½åœ¨é—­åŒ…å†…ï¼‰"
            ],
            "æœ€åæ£€æµ‹": [new Date().toLocaleTimeString()]
        });
    };

    // =========================================================
    // å°å·¥å…·ï¼šå®‰å…¨æ—¥å¿—ï¼ˆåŒæ—¶è¾“å‡ºåˆ°æ§åˆ¶å°ä¸åŸè°ƒè¯•æ§åˆ¶å°ï¼‰
    // =========================================================
    function dcInfo(tag, msg) {
        try {
            // æ³¨æ„ï¼šåŸæ–‡ä»¶ä¸­ debugConsole æ˜¯ global lexicalï¼ˆletï¼‰ï¼Œè¿™é‡Œç›´æ¥è®¿é—®
            if (typeof debugConsole !== 'undefined' && debugConsole && typeof debugConsole.info === 'function') {
                debugConsole.info(tag, msg);
            }
        } catch (_) {}
    }
    function dcWarn(tag, msg) {
        try {
            if (typeof debugConsole !== 'undefined' && debugConsole && typeof debugConsole.warn === 'function') {
                debugConsole.warn(tag, msg);
            }
        } catch (_) {}
    }
    function dcError(tag, msg) {
        try {
            if (typeof debugConsole !== 'undefined' && debugConsole && typeof debugConsole.error === 'function') {
                debugConsole.error(tag, msg);
            }
        } catch (_) {}
    }

    // =========================================================
    // é»˜è®¤èƒŒæ™¯å°è£…ï¼ˆå¤ç”¨åŸæ’­æ”¾å™¨æ¸å˜èƒŒæ™¯ï¼‰
    // =========================================================
    class DefaultBackgroundSystem {
        constructor() {
            this.type = 'default';
            this.canvas = null;
        }

        init() {
            console.log("[é»˜è®¤èƒŒæ™¯] åˆå§‹åŒ–/æ¢å¤...");
            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'é»˜è®¤èƒŒæ™¯ï¼šåˆå§‹åŒ–/æ¢å¤');
            this.canvas = document.getElementById('gradientCanvas');
            if (this.canvas) this.canvas.style.display = 'block';
            const host = document.getElementById('bgHost');
            if (host) host.style.display = 'none';

            // åŸæ–‡ä»¶å‡½æ•°ï¼šstartGradientAnimation()
            try {
                if (typeof startGradientAnimation === 'function') startGradientAnimation();
            } catch (e) {
                console.warn("[é»˜è®¤èƒŒæ™¯] å¯åŠ¨å¤±è´¥:", e);
            }
            return '';
        }

        destroy() {
            console.log("[é»˜è®¤èƒŒæ™¯] åœæ­¢åŠ¨ç”»...");
            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'é»˜è®¤èƒŒæ™¯ï¼šåœæ­¢åŠ¨ç”»');
            try {
                if (typeof animationId !== 'undefined' && animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            } catch (e) {
                console.warn("[é»˜è®¤èƒŒæ™¯] åœæ­¢å¤±è´¥:", e);
            }
            if (this.canvas) this.canvas.style.display = 'none';
        }

        async updateFromAlbum(url) {
            // é»˜è®¤èƒŒæ™¯ç”±åŸæ’­æ”¾å™¨ä»£ç è‡ªå·±è°ƒç”¨ updateGradientFromAlbumï¼Œè¿™é‡Œä»…è¡¥å¼ºï¼ˆä¸é‡å¤ä¹Ÿä¸å½±å“ï¼‰
            try {
                if (typeof updateGradientFromAlbum === 'function' && url) {
                    updateGradientFromAlbum(url);
                }
            } catch (e) {
                console.warn("[é»˜è®¤èƒŒæ™¯] updateFromAlbum å¼‚å¸¸:", e);
            }
        }

        getControlsHTML() {
            return '';
        }

        bindControls() {}
    }

    // =========================================================
    // === PixièƒŒæ™¯å®Œæ•´å°è£… ===
    // ï¼ˆä»¥ä¸‹æ ¸å¿ƒæ¸²æŸ“é€»è¾‘å®Œæ•´å¤åˆ¶è‡ª pixi-dynamic-background 2.htmlï¼Œ
    //  ä»…å¯¹ resize/RAF å¢åŠ å¯é‡Šæ”¾èƒ½åŠ›ï¼Œå¹¶åŠ å…¥ destroy() åšèµ„æºæ¸…ç†ï¼‰
    // =========================================================
    class PixiBackgroundSystem {
        constructor() {
            // åŒ…å«pixi-dynamic-background 2.htmlçš„æ‰€æœ‰å˜é‡å’Œå‡½æ•°ï¼ˆå®Œæ•´å¤åˆ¶ï¼‰
            // ============================================
            // é…ç½® - ä¿®æ”¹è¿™é‡Œå¯ä»¥æ›´æ¢é»˜è®¤å›¾ç‰‡
            // ============================================
            this.DEFAULT_IMAGE_URL = 'https://imge.kugou.com/stdmusic/orig/20150718/20150718214459760936.jpg';
            // ============================================

            // =============== WebGL åŠ¨æ€èƒŒæ™¯æ¸²æŸ“å™¨ ===============
            // å®Œå…¨ä¸ä¾èµ–å¤–éƒ¨åº“ï¼Œçº¯WebGLå®ç° - ç›´æ¥ä»html-music-mainé¡¹ç›®æŠ„è¿‡æ¥çš„é€»è¾‘

            const vertexShaderSource = `
                attribute vec2 a_position;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                    v_texCoord = a_texCoord;
                }
            `;

            // Kawaseæ¨¡ç³Š - ä»pixi-filtersçš„KawaseBlurFilteræŠ„è¿‡æ¥
            const kawaseBlurFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                uniform vec2 u_resolution;
                uniform float u_offset;

                void main() {
                    vec2 texelSize = 1.0 / u_resolution;
                    vec2 uv = v_texCoord;

                    vec4 color = texture2D(u_texture, uv) * 0.2;
                    color += texture2D(u_texture, uv + vec2(-u_offset - 0.5, -u_offset - 0.5) * texelSize) * 0.2;
                    color += texture2D(u_texture, uv + vec2( u_offset + 0.5, -u_offset - 0.5) * texelSize) * 0.2;
                    color += texture2D(u_texture, uv + vec2(-u_offset - 0.5,  u_offset + 0.5) * texelSize) * 0.2;
                    color += texture2D(u_texture, uv + vec2( u_offset + 0.5,  u_offset + 0.5) * texelSize) * 0.2;

                    gl_FragColor = color;
                }
            `;

            // æ‰­æ›²æ•ˆæœ - ä»pixi-filtersçš„TwistFilteræŠ„è¿‡æ¥
            const twistFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                uniform vec2 u_center;
                uniform float u_radius;
                uniform float u_angle;
                uniform vec2 u_resolution;

                void main() {
                    vec2 coord = v_texCoord - u_center;

                    float aspect = u_resolution.x / u_resolution.y;
                    coord.x *= aspect;

                    float dist = length(coord);

                    if (dist < u_radius) {
                        float percent = (u_radius - dist) / u_radius;
                        float theta = percent * percent * u_angle;
                        float s = sin(theta);
                        float c = cos(theta);
                        coord = vec2(
                            coord.x * c - coord.y * s,
                            coord.x * s + coord.y * c
                        );
                    }

                    coord.x /= aspect;
                    vec2 uv = coord + u_center;

                    gl_FragColor = texture2D(u_texture, uv);
                }
            `;

            // é¥±å’Œåº¦è°ƒæ•´ - ä»pixi-filtersçš„AdjustmentFilteræŠ„è¿‡æ¥
            const saturationFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                uniform float u_saturation;

                void main() {
                    vec4 color = texture2D(u_texture, v_texCoord);
                    float gray = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
                    color.rgb = mix(vec3(gray), color.rgb, u_saturation);
                    gl_FragColor = color;
                }
            `;

            // åˆæˆç€è‰²å™¨ - å°†å¤šä¸ªç²¾çµå åŠ æ¸²æŸ“
            const compositeFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                uniform vec2 u_position;
                uniform float u_rotation;
                uniform float u_scale;
                uniform vec2 u_resolution;

                void main() {
                    vec2 uv = v_texCoord;
                    vec2 center = u_position;
                    vec2 coord = uv - center;

                    float aspect = u_resolution.x / u_resolution.y;
                    coord.x *= aspect;

                    float s = sin(u_rotation);
                    float c = cos(u_rotation);
                    coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);
                    coord /= u_scale;
                    coord.x /= aspect;

                    uv = coord + vec2(0.5);

                    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                        gl_FragColor = vec4(0.0);
                    } else {
                        gl_FragColor = texture2D(u_texture, uv);
                    }
                }
            `;

            const copyFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                void main() {
                    gl_FragColor = texture2D(u_texture, v_texCoord);
                }
            `;

            // ä»LyricsScene.tsæŠ„è¿‡æ¥çš„ç²¾çµé…ç½®
            const self = this;
            this.LyricsScene = class LyricsScene {
                constructor(container) {
                    this.container = container;
                    this.paused = false;
                    this._destroyed = false;
                    this._rafId = null;
                    this._onResize = null;

                    // ç²¾çµé…ç½® - ç›´æ¥ä»LyricsScene.tsæŠ„è¿‡æ¥
                    this.sprites = [
                        { x: 0.5, y: 0.5, rotation: 0, scale: 1.25, rotSpeed: 0.003 },
                        { x: 0.4, y: 0.4, rotation: 0, scale: 0.8, rotSpeed: -0.008 },
                        { x: 0.5, y: 0.5, rotation: 0, scale: 0.5, rotSpeed: -0.006, orbit: true, orbitRadius: 0.25, orbitMult: 0.75 },
                        { x: 0.5, y: 0.5, rotation: 0, scale: 0.25, rotSpeed: 0.004, orbit: true, orbitRadius: 0.25, orbitOffset: 0.05, orbitMult: 0.75 }
                    ];

                    // æ»¤é•œè®¾ç½® - ç›´æ¥ä»LyricsScene.tsæŠ„è¿‡æ¥çš„bluré…ç½®
                    this.filters = {
                        twist: true,
                        blur: [false, false, false, false, false],
                        saturation: true
                    };
                    // KawaseBlurFilterçš„é…ç½®ï¼š[blur, quality]
                    // new KawaseBlurFilter(5, 1), new KawaseBlurFilter(10, 1), new KawaseBlurFilter(20, 2), new KawaseBlurFilter(40, 2), new KawaseBlurFilter(80, 2)
                    this.blurConfigs = [
                        { blur: 5, quality: 1 },
                        { blur: 10, quality: 1 },
                        { blur: 20, quality: 2 },
                        { blur: 40, quality: 2 },
                        { blur: 80, quality: 2 }
                    ];

                    this.initWebGL();
                    this.createShaders();
                    this.createBuffers();
                    this.createFramebuffers();

                    // â˜… ä¸ºäº†å¯é”€æ¯ï¼Œä¿å­˜ resize handlerï¼ˆåŸæ–‡ä»¶ä¸ºåŒ¿åå‡½æ•°ï¼Œè¿™é‡Œåªåšç­‰ä»·å¢å¼ºï¼‰
                    this._onResize = () => { if (this._resizeRaf) cancelAnimationFrame(this._resizeRaf); this._resizeRaf = requestAnimationFrame(() => this.resize()); };
                    window.addEventListener('resize', this._onResize);
                    this.animate();
                }

                initWebGL() {
                    this.canvas = document.createElement('canvas');
                    // ç»‘å®šå°ºå¯¸åˆ°å®¹å™¨ï¼ˆå¡ç‰‡èƒŒæ™¯å±‚ï¼‰ï¼Œå¹¶è€ƒè™‘ dpr ä¸å¯¼å‡ºç¼©æ”¾
                    const cssW = this.container.clientWidth;
                    const cssH = this.container.clientHeight;
                    const baseDpr = Math.max(1, window.devicePixelRatio || 1);
                    const exportScale = (window.__LYRICS_CARD_EXPORT_SCALE || 1);
                    const perf = (window.__LYRICS_PERF || {});
                    let dpr = baseDpr * exportScale;
                    // PERF: cap DPR & pixel area to prevent mobile GPU crash
                    const maxDpr = (exportScale && exportScale !== 1) ? Math.max(1.5, (perf.maxPreviewDpr || 2)) : (perf.maxPreviewDpr || 2);
                    dpr = Math.min(dpr, maxDpr);

                    this.canvas.style.width = '100%';
                    this.canvas.style.height = '100%';
                    this.canvas.width = Math.max(1, Math.round(cssW * dpr));
                    this.canvas.height = Math.max(1, Math.round(cssH * dpr));
                    this.container.appendChild(this.canvas);

                    this.gl = this.canvas.getContext('webgl', { 
                        alpha: true,
                        premultipliedAlpha: false,
                        preserveDrawingBuffer: true,
                        powerPreference: 'low-power'
                    });

                    if (!this.gl) throw new Error('WebGL not supported');

                    this.gl.enable(this.gl.BLEND);
                    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                }

                createShader(type, source) {
                    const gl = this.gl;
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.error ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
                        try { console.error('Shader error:', gl.getShaderInfoLog(shader)); } catch (e) { try { console.log('Shader error:', gl.getShaderInfoLog(shader)); } catch (_) {} }
                        return null;
                    }
                    // è®°å½• shader ä¾¿äº destroy
                    if (!this._shaders) this._shaders = [];
                    this._shaders.push(shader);
                    return shader;
                }

                createProgram(vertexSource, fragmentSource) {
                    const gl = this.gl;
                    const program = gl.createProgram();
                    const vs = this.createShader(gl.VERTEX_SHADER, vertexSource);
                    const fs = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);
                    gl.attachShader(program, vs);
                    gl.attachShader(program, fs);
                    gl.linkProgram(program);
                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                        // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.error ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
                        try { console.error('Program error:', gl.getProgramInfoLog(program)); } catch (e) { try { console.log('Program error:', gl.getProgramInfoLog(program)); } catch (_) {} }
                        return null;
                    }
                    if (!this._programs) this._programs = [];
                    this._programs.push(program);
                    return program;
                }

                createShaders() {
                    this.copyProgram = this.createProgram(vertexShaderSource, copyFragmentShader);
                    this.compositeProgram = this.createProgram(vertexShaderSource, compositeFragmentShader);
                    this.twistProgram = this.createProgram(vertexShaderSource, twistFragmentShader);
                    this.blurProgram = this.createProgram(vertexShaderSource, kawaseBlurFragmentShader);
                    this.saturationProgram = this.createProgram(vertexShaderSource, saturationFragmentShader);
                }

                createBuffers() {
                    const gl = this.gl;
                    const positions = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
                    const texCoords = new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]);

                    this.positionBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

                    this.texCoordBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
                }

                createFramebuffers() {
                    const gl = this.gl;
                    const w = this.canvas.width;
                    const h = this.canvas.height;

                    if (this.framebuffers) {
                        this.framebuffers.forEach(fb => gl.deleteFramebuffer(fb));
                        this.fbTextures.forEach(tex => gl.deleteTexture(tex));
                    }

                    this.framebuffers = [];
                    this.fbTextures = [];

                    for (let i = 0; i < 3; i++) {
                        const fb = gl.createFramebuffer();
                        const tex = gl.createTexture();

                        gl.bindTexture(gl.TEXTURE_2D, tex);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);

                        this.framebuffers.push(fb);
                        this.fbTextures.push(tex);
                    }
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }

                setupProgram(program) {
                    const gl = this.gl;
                    gl.useProgram(program);

                    const posLoc = gl.getAttribLocation(program, 'a_position');
                    const texLoc = gl.getAttribLocation(program, 'a_texCoord');

                    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                    gl.enableVertexAttribArray(texLoc);
                    gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
                }

                async loadImage(source) {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        img.onload = () => { this.uploadTexture(img); resolve(); };
                        img.onerror = () => { this.createFallbackTexture(); resolve(); };

                        if (source instanceof File) {
                            const reader = new FileReader();
                            reader.onload = (e) => { img.src = e.target.result; };
                            reader.readAsDataURL(source);
                        } else {
                            img.src = source;
                        }
                    });
                }

                createFallbackTexture() {
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = 512;
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 360);
                    gradient.addColorStop(0, '#ff6b6b');
                    gradient.addColorStop(0.3, '#4ecdc4');
                    gradient.addColorStop(0.6, '#45b7d1');
                    gradient.addColorStop(1, '#96ceb4');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 512, 512);
                    this.uploadTexture(canvas);
                }

                uploadTexture(source) {
                    const gl = this.gl;
                    if (this.imageTexture) gl.deleteTexture(this.imageTexture);

                    this.imageTexture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, this.imageTexture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                }

                renderSprites() {
                    const gl = this.gl;
                    const w = this.canvas.width, h = this.canvas.height;

                    // å°†æ¸²æŸ“åˆ° framebufferï¼Œå¹¶å°†æ¸…å±é¢œè‰²è®¾ç½®ä¸ºå®Œå…¨é€æ˜ï¼Œé¿å…å‡ºç°é»‘è‰²èƒŒæ™¯
                    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[0]);
                    gl.viewport(0, 0, w, h);
                    // ä½¿ç”¨é€æ˜çš„æ¸…é™¤è‰²ï¼Œä»¥ä¾¿é€šè¿‡æ··åˆçœ‹åˆ°ä¸‹æ–¹èƒŒæ™¯
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);

                    if (!this.imageTexture) return;

                    this.setupProgram(this.compositeProgram);
                    gl.uniform2f(gl.getUniformLocation(this.compositeProgram, 'u_resolution'), w, h);

                    // æ ¹æ®ç”»å¸ƒçš„å®½é«˜æ¯”è°ƒæ•´ç²¾çµçš„ç¼©æ”¾ï¼Œç¡®ä¿åœ¨ä»»ä½•å±å¹•å°ºå¯¸ä¸‹æ²¡æœ‰é»‘è¾¹
                    const aspectRatio = Math.max(w, h) / Math.min(w, h);
                    const baseScales = [1.25, 0.8, 0.5, 0.25];
                    for (let idx = 0; idx < this.sprites.length; idx++) {
                        const sprite = this.sprites[idx];
                        sprite.scale = baseScales[idx] * aspectRatio;
                        gl.bindTexture(gl.TEXTURE_2D, this.imageTexture);
                        gl.uniform2f(gl.getUniformLocation(this.compositeProgram, 'u_position'), sprite.x, sprite.y);
                        gl.uniform1f(gl.getUniformLocation(this.compositeProgram, 'u_rotation'), sprite.rotation);
                        gl.uniform1f(gl.getUniformLocation(this.compositeProgram, 'u_scale'), sprite.scale);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                }

                applyTwist(inputIdx, outputFb) {
                    const gl = this.gl;
                    const w = this.canvas.width, h = this.canvas.height;

                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFb);
                    gl.viewport(0, 0, w, h);

                    this.setupProgram(this.twistProgram);
                    gl.bindTexture(gl.TEXTURE_2D, this.fbTextures[inputIdx]);

                    // TwistFilteré…ç½® - ä»LyricsScene.tsæŠ„è¿‡æ¥: angle: -3.25, radius: 900
                    gl.uniform2f(gl.getUniformLocation(this.twistProgram, 'u_center'), 0.5, 0.5);
                    gl.uniform1f(gl.getUniformLocation(this.twistProgram, 'u_radius'), 900.0 / Math.min(w, h));
                    gl.uniform1f(gl.getUniformLocation(this.twistProgram, 'u_angle'), -3.25);
                    gl.uniform2f(gl.getUniformLocation(this.twistProgram, 'u_resolution'), w, h);

                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }

                // Kawaseæ¨¡ç³Šéœ€è¦å¤šæ¬¡è¿­ä»£
                applyKawaseBlur(inputIdx, outputFb, blurConfig) {
                    const gl = this.gl;
                    const w = this.canvas.width, h = this.canvas.height;

                    let currentInput = inputIdx;
                    let currentOutputFb = outputFb;
                    let currentOutputIdx = outputFb === this.framebuffers[1] ? 1 : 2;

                    // æ ¹æ®qualityè¿›è¡Œå¤šæ¬¡è¿­ä»£
                    const kernels = this.getKawaseKernels(blurConfig.blur, blurConfig.quality);

                    for (let i = 0; i < kernels.length; i++) {
                        gl.bindFramebuffer(gl.FRAMEBUFFER, currentOutputFb);
                        gl.viewport(0, 0, w, h);

                        this.setupProgram(this.blurProgram);
                        gl.bindTexture(gl.TEXTURE_2D, this.fbTextures[currentInput]);
                        gl.uniform2f(gl.getUniformLocation(this.blurProgram, 'u_resolution'), w, h);
                        gl.uniform1f(gl.getUniformLocation(this.blurProgram, 'u_offset'), kernels[i]);

                        gl.drawArrays(gl.TRIANGLES, 0, 6);

                        // äº¤æ¢ç¼“å†²åŒº
                        if (i < kernels.length - 1) {
                            currentInput = currentOutputIdx;
                            currentOutputIdx = currentOutputIdx === 1 ? 2 : 1;
                            currentOutputFb = this.framebuffers[currentOutputIdx];
                        }
                    }

                    return currentOutputIdx;
                }

                // ä»pixi-filtersçš„KawaseBlurFilteræŠ„è¿‡æ¥çš„kernelè®¡ç®—
                getKawaseKernels(blur, quality) {
                    const kernels = [];
                    if (blur > 0) {
                        let k = blur;
                        const q = quality;
                        for (let i = 0; i < q; i++) {
                            kernels.push(k);
                            k *= 0.5;
                        }
                    }
                    return kernels.length > 0 ? kernels : [0];
                }

                applySaturation(inputIdx, outputFb) {
                    const gl = this.gl;

                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFb);
                    gl.viewport(0, 0, this.canvas.width, this.canvas.height);

                    this.setupProgram(this.saturationProgram);
                    gl.bindTexture(gl.TEXTURE_2D, this.fbTextures[inputIdx]);
                    // AdjustmentFilteré…ç½® - ä»LyricsScene.tsæŠ„è¿‡æ¥: saturation: 2.75
                    gl.uniform1f(gl.getUniformLocation(this.saturationProgram, 'u_saturation'), 2.75);

                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }

                copyToScreen(inputIdx) {
                    const gl = this.gl;
                    // æ¸…ç©ºé»˜è®¤å¸§ç¼“å†²åŒºï¼Œä½¿ç”¨é€æ˜èƒŒæ™¯ï¼Œè¿™æ ·å¦‚æœå†…å®¹æ²¡æœ‰å®Œå…¨è¦†ç›–åˆ™æ˜¾ç¤ºåé¢çš„æ¸å˜èƒŒæ™¯
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);

                    this.setupProgram(this.copyProgram);
                    gl.bindTexture(gl.TEXTURE_2D, this.fbTextures[inputIdx]);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }

                render() {
                    this.renderSprites();

                    let currentIdx = 0;
                    // nextFbIdx å§‹ç»ˆæŒ‡å‘ä¸ currentIdx ä¸åŒçš„ ping-pong ç¼“å†²ï¼Œé¿å… WebGL feedback loop
                    let nextFbIdx = 1;
                    const pickNextFb = () => (currentIdx === 1 ? 2 : 1);

                    // æ‰­æ›²
                    if (this.filters.twist) {
                        this.applyTwist(currentIdx, this.framebuffers[nextFbIdx]);
                        currentIdx = nextFbIdx;
                        nextFbIdx = pickNextFb();
                    }

                    // æ¨¡ç³Šå±‚
                    for (let i = 0; i < 5; i++) {
                        if (this.filters.blur[i]) {
                            const outputIdx = this.applyKawaseBlur(currentIdx, this.framebuffers[nextFbIdx], this.blurConfigs[i]);
                            currentIdx = outputIdx;
                            nextFbIdx = pickNextFb();
                        }
                    }

                    // é¥±å’Œåº¦
                    if (this.filters.saturation) {
                        this.applySaturation(currentIdx, this.framebuffers[nextFbIdx]);
                        currentIdx = nextFbIdx;
                        nextFbIdx = pickNextFb();
                    }

                    this.copyToScreen(currentIdx);
                }

                // ç²¾çµåŠ¨ç”» - ç›´æ¥ä»LyricsScene.tsçš„tickeræŠ„è¿‡æ¥
                updateSprites(deltaMS) {
                    const n = deltaMS / 33.333333;
                    // sprite 0
                    this.sprites[0].rotation += 0.003 * n;

                    // sprite 1
                    this.sprites[1].rotation -= 0.008 * n;

                    // sprite 2 - åœ†å‘¨è¿åŠ¨
                    this.sprites[2].rotation -= 0.006 * n;
                    this.sprites[2].x = 0.5 + 0.25 * Math.cos(this.sprites[2].rotation * 0.75);
                    this.sprites[2].y = 0.5 + 0.25 * Math.sin(this.sprites[2].rotation * 0.75);

                    // sprite 3 - åœ†å‘¨è¿åŠ¨å¸¦åç§»
                    this.sprites[3].rotation += 0.004 * n;
                    this.sprites[3].x = 0.5 + 0.05 + 0.25 * Math.cos(this.sprites[3].rotation * 0.75);
                    this.sprites[3].y = 0.5 + 0.05 + 0.25 * Math.sin(this.sprites[3].rotation * 0.75);
                }

                animate() {
                    if (this._destroyed) return;

                    if (this.paused || document.hidden) { this._rafId = null; return; }

                    
                        const now = performance.now();

                        // PERF: cap FPS on mobile/low-end
                        const perf = (window.__LYRICS_PERF || {});
                        const fps = perf.targetFps || 60;
                        const minInterval = 1000 / fps;
                        if (!this._lastRenderTime) this._lastRenderTime = 0;
                        if (now - this._lastRenderTime < minInterval) {
                          this._rafId = requestAnimationFrame(() => this.animate());
                          return;
                        }
                        this._lastRenderTime = now;

                        let delta = this.lastTime ? now - this.lastTime : 16.67;
                        delta = Math.min(33.33, Math.max(0, delta));
                        this.lastTime = now;

                        this.updateSprites(delta);
                        this.render();

                    // â˜… ä¸ºäº†å¯é”€æ¯ï¼Œä¿å­˜ RAF id
                    this._rafId = requestAnimationFrame(() => this.animate());
                }

                updateFilters(options = {}) {
                    try {
                        if (options && typeof options === 'object') {
                            if (typeof options.twist !== 'undefined') this.filters.twist = !!options.twist;
                            if (typeof options.sat !== 'undefined') this.filters.saturation = !!options.sat;
                            if (Array.isArray(options.blur)) {
                                // ä¿æŒä¸º 5 æ®µæ¨¡ç³Šçš„å¸ƒå°”æ•°ç»„
                                const b = options.blur.map(v => !!v);
                                while (b.length < 5) b.push(false);
                                this.filters.blur = b.slice(0, 5);
                            }
                        }
                    } catch (e) {
                        console.warn('[PixièƒŒæ™¯] updateFilters å¼‚å¸¸:', e);
                    }
                }

                resize() {
                    const cssW = this.container.clientWidth;
                    const cssH = this.container.clientHeight;
                    const baseDpr = Math.max(1, window.devicePixelRatio || 1);
                    const exportScale = (window.__LYRICS_CARD_EXPORT_SCALE || 1);

                    // card å¯èƒ½é€šè¿‡ transform: scale(...) ç¼©æ”¾é¢„è§ˆï¼›ç”¨å®é™…ç¼©æ”¾ç³»æ•°é™ä½ç¦»å±åˆ†è¾¨ç‡ï¼Œé¿å… GPU è¿‡è½½
                    let previewScale = 1;
                    try {
                        const cardEl = document.getElementById('card');
                        if (cardEl) {
                            const rect = cardEl.getBoundingClientRect();
                            const ow = cardEl.offsetWidth || cardEl.clientWidth || rect.width;
                            if (ow > 0) previewScale = Math.max(0.05, Math.min(1, rect.width / ow));
                        }
                    } catch (_) {}

                    let dpr = baseDpr * exportScale * previewScale;

                    const perf = (window.__LYRICS_PERF || {});
                    const isExporting = (exportScale && exportScale !== 1);
                    const maxDpr = isExporting ? Math.max(1.5, (perf.maxPreviewDpr || 2)) : (perf.maxPreviewDpr || 2);
                    dpr = Math.min(dpr, maxDpr);
                    const maxPixels = isExporting ? (perf.maxCanvasPixelsExport || 5000000) : (perf.maxCanvasPixelsPreview || 1800000);
                    const wantedPixels = (cssW * dpr) * (cssH * dpr);
                    if (wantedPixels > maxPixels) {
                      const s = Math.sqrt(maxPixels / wantedPixels);
                      dpr = Math.max(0.5, dpr * s);
                    }

                    this.canvas.style.width = '100%';
                    this.canvas.style.height = '100%';
                    this.canvas.width = Math.max(1, Math.round(cssW * dpr));
                    this.canvas.height = Math.max(1, Math.round(cssH * dpr));
                    this.createFramebuffers();
                }

                pause() { this.paused = true; }
                resume() { this.paused = false; this.lastTime = null; }

                // â˜… æ–°å¢ï¼šå®Œæ•´æ¸…ç†æ‰€æœ‰èµ„æº
                destroy() {
                    this._destroyed = true;

                    try {
                        if (this._rafId) cancelAnimationFrame(this._rafId);
                    } catch (_) {}

                    try {
                        if (this._onResize) window.removeEventListener('resize', this._onResize);
                    } catch (_) {}

                    const gl = this.gl;
                    if (!gl) return;

                    try {
                        if (this.imageTexture) gl.deleteTexture(this.imageTexture);
                    } catch (_) {}

                    try {
                        if (this.fbTextures) this.fbTextures.forEach(tex => { try { gl.deleteTexture(tex); } catch(_){} });
                        if (this.framebuffers) this.framebuffers.forEach(fb => { try { gl.deleteFramebuffer(fb); } catch(_){} });
                    } catch (_) {}

                    try { if (this.positionBuffer) gl.deleteBuffer(this.positionBuffer); } catch (_) {}
                    try { if (this.texCoordBuffer) gl.deleteBuffer(this.texCoordBuffer); } catch (_) {}

                    try {
                        if (this._programs) this._programs.forEach(p => { try { gl.deleteProgram(p); } catch(_){} });
                        if (this._shaders) this._shaders.forEach(s => { try { gl.deleteShader(s); } catch(_){} });
                    } catch (_) {}

                    try {
                        const ext = gl.getExtension('WEBGL_lose_context');
                        if (ext && ext.loseContext) ext.loseContext();
                    } catch (_) {}

                    try {
                        if (this.canvas && this.canvas.parentNode) this.canvas.parentNode.removeChild(this.canvas);
                    } catch (_) {}

                    this.gl = null;
                }
            };

            // è¿è¡Œæ€å˜é‡
            this.scene = null;
            this.layerEl = null;
            this._controlsAbort = null;
            this._isPlaying = true;
            this._lastImageSource = null;
        }

        async init(container) { 
            console.log("[PixièƒŒæ™¯] åˆå§‹åŒ–å¼€å§‹...");
            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'PixièƒŒæ™¯ï¼šåˆå§‹åŒ–å¼€å§‹...');
            const host = document.getElementById('bgHost');
            if (host) host.style.display = 'block';

            // åˆ›å»ºå›¾å±‚
            this.layerEl = document.createElement('div');
            this.layerEl.className = 'bg-layer';
            this.layerEl.style.position = 'absolute';
            this.layerEl.style.inset = '0';
            container.appendChild(this.layerEl);

            // åˆå§‹åŒ–åœºæ™¯
            this.scene = new this.LyricsScene(this.layerEl);

            // åˆæ¬¡åŠ è½½ï¼šè‹¥å·²æœ‰ä¸“è¾‘å°é¢åˆ™ç”¨ä¹‹ï¼Œå¦åˆ™ç”¨é»˜è®¤
            const firstUrl = window.__bgManager?.lastAlbumUrl || this.DEFAULT_IMAGE_URL;
            this._lastImageSource = firstUrl;
            await this.scene.loadImage(firstUrl);

            return this.getControlsHTML();
        }
        // å¯¼å‡ºç”¨ï¼šæ¸²æŸ“ä¸€å¸§ï¼ˆç”¨äºæˆªå›¾å‰å¼ºåˆ¶åˆ·æ–°ï¼‰
        renderOnce() {
            try {
                if (this.scene) {
                    // ä¸æ¨è¿›æ—¶é—´ï¼Œåªåˆ·æ–°ä¸€æ¬¡æ¸²æŸ“è¾“å‡º
                    if (typeof this.scene.updateSprites === 'function') this.scene.updateSprites(0);
                    if (typeof this.scene.render === 'function') this.scene.render();
                }
            } catch (_) {}
        }
        // å¯¼å‡ºç”¨ï¼šè·å–å½“å‰ç”»é¢å¿«ç…§ï¼ˆå°½é‡ä½¿ç”¨ WebGL readPixelsï¼Œé¿å… toDataURL è¯»ä¸åˆ°æˆ–åˆ†è¾¨ç‡ä¸åŒ¹é…ï¼‰
        snapshot() {
            try {
                if (this.scene) {
                    // ç¡®ä¿è¾“å‡ºæ˜¯æœ€æ–°ä¸€å¸§
                    try { this.renderOnce(); } catch (_) {}
                    const c = this.scene.canvas;
                    const gl = this.scene.gl;
                    if (c && gl) {
                        const w = c.width || 0;
                        const h = c.height || 0;
                        if (w > 0 && h > 0) {
                            // è¯»å–é»˜è®¤å¸§ç¼“å†²ï¼ˆå±å¹•è¾“å‡ºï¼‰åƒç´ 
                            try { gl.bindFramebuffer(gl.FRAMEBUFFER, null); } catch (_) {}
                            try { gl.finish && gl.finish(); } catch (_) {}

                            const pixels = new Uint8Array(w * h * 4);
                            gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

                            const oc = document.createElement('canvas');
                            oc.width = w;
                            oc.height = h;
                            const ctx = oc.getContext('2d', { willReadFrequently: true, alpha: true });
                            if (!ctx) return null;

                            const imgData = ctx.createImageData(w, h);
                            // WebGL åƒç´ åŸç‚¹åœ¨å·¦ä¸‹ï¼Œéœ€è¦ä¸Šä¸‹ç¿»è½¬
                            for (let y = 0; y < h; y++) {
                                const srcRow = (h - 1 - y) * w * 4;
                                const dstRow = y * w * 4;
                                imgData.data.set(pixels.subarray(srcRow, srcRow + w * 4), dstRow);
                            }
                            ctx.putImageData(imgData, 0, 0);
                            return oc.toDataURL('image/png');
                        }
                    }
                    // å…œåº•ï¼šç›´æ¥å¯¼å‡º canvasï¼ˆä»…å½“ preserveDrawingBuffer å¯è¯»æ—¶æœ‰æ•ˆï¼‰
                    try { return c ? c.toDataURL('image/png') : null; } catch (_) { return null; }
                }
            } catch (_) {}
            return null;
        }

        pause() {
            this._isPlaying = false;
            try { if (this.scene && typeof this.scene.pause === 'function') this.scene.pause(); } catch (_) {}
        }

        resume() {
            this._isPlaying = true;
            try { if (this.scene && typeof this.scene.resume === 'function') this.scene.resume(); } catch (_) {}
        }


        destroy() { 
            console.log("[PixièƒŒæ™¯] æ¸…ç†èµ„æº...");
            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'PixièƒŒæ™¯ï¼šæ¸…ç†èµ„æº...');
            try { if (this._controlsAbort) this._controlsAbort.abort(); } catch (_) {}

            try { if (this.scene && typeof this.scene.destroy === 'function') this.scene.destroy(); } catch (e) {
                console.warn("[PixièƒŒæ™¯] scene.destroy å¤±è´¥:", e);
            }
            this.scene = null;

            try {
                if (this.layerEl && this.layerEl.parentNode) this.layerEl.parentNode.removeChild(this.layerEl);
            } catch (_) {}
            this.layerEl = null;

            this._isPlaying = true;
        }

        getControlsHTML() {
            // ç”Ÿæˆè¿™ä¸ªèƒŒæ™¯ä¸“ç”¨çš„æ§åˆ¶é¢æ¿HTMLï¼ˆåŒ…å«åŸå§‹æ–‡ä»¶ä¸­çš„æ‰€æœ‰æ§åˆ¶é€‰é¡¹ï¼‰
            return `
                <div class="control-group-title">Pixi åŠ¨æ€èƒŒæ™¯</div>

                <div class="bg-ctrl-row">
                    <label class="bg-file-btn" title="é€‰æ‹©æœ¬åœ°å›¾ç‰‡æ–‡ä»¶">
                        é€‰æ‹©æ–‡ä»¶
                        <input type="file" id="fileInput" accept="image/*" style="display:none">
                    </label>
                    <button id="stopBtn" title="æš‚åœ/æ’­æ”¾èƒŒæ™¯åŠ¨ç”»">æš‚åœ</button>
                </div>

                <div class="bg-file-name" id="fileName">é»˜è®¤å›¾ç‰‡</div>

                <div class="bg-ctrl-row" style="width:100%">
                    <input type="text" id="urlInput" placeholder="è¾“å…¥å›¾ç‰‡URL..." />
                    <button id="loadUrlBtn" title="åŠ è½½URLå›¾ç‰‡">åŠ è½½URLå›¾ç‰‡</button>
                </div>

                <div class="bg-sep"></div>

                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="twistEffect" checked> æ‰­æ›²æ•ˆæœ</label>
                </div>

                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blurEffect"> æ¨¡ç³Š</label>
                </div>

                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur1"> æ¨¡ç³Šå±‚1ï¼ˆ5åƒç´ ï¼‰</label>
                </div>
                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur2"> æ¨¡ç³Šå±‚2ï¼ˆ10åƒç´ ï¼‰</label>
                </div>
                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur3"> æ¨¡ç³Šå±‚3ï¼ˆ20åƒç´ ï¼‰</label>
                </div>
                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur4"> æ¨¡ç³Šå±‚4ï¼ˆ40åƒç´ ï¼‰</label>
                </div>
                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur5"> æ¨¡ç³Šå±‚5ï¼ˆ80åƒç´ ï¼‰</label>
                </div>

                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="saturation" checked> é¥±å’Œåº¦</label>
                </div>

                <div class="bg-hint" style="margin-top:10px;">
                    æç¤ºï¼šæ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶/URL åï¼Œå°†è‡ªåŠ¨å…³é—­â€œè·Ÿéšä¸“è¾‘å°é¢â€ï¼Œä»¥ä¿ç•™ä½ çš„è‡ªå®šä¹‰å›¾ç‰‡ã€‚
                </div>
            `;
        }

        bindControls(rootEl, { onUserOverride } = {}) {
            if (!rootEl) return;
            if (!this.scene) return;

            // ä½¿ç”¨ AbortController ä¾¿äº destroy æ—¶ä¸€é”®å¸è½½äº‹ä»¶
            this._controlsAbort = new AbortController();
            const sig = { signal: this._controlsAbort.signal };

            const $ = (id) => rootEl.querySelector(`#${id}`);

            const fileInput = $('fileInput');
            const fileName = $('fileName');
            const urlInput = $('urlInput');
            const loadUrlBtn = $('loadUrlBtn');
            const stopBtn = $('stopBtn');

            const twistEffect = $('twistEffect');
            const blurEffect = $('blurEffect');
            const blurIds = ['blur1','blur2','blur3','blur4','blur5'];
            const saturation = $('saturation');

            const updateFilters = () => {
                try {
                    if (this.scene && typeof this.scene.updateFilters === 'function') {
                        this.scene.updateFilters({
                            twist: !!twistEffect?.checked,
                            blur: blurIds.map(id => !!$(id)?.checked),
                            sat: !!saturation?.checked,
                        });
                    }
                } catch (e) {
                    console.warn("[PixièƒŒæ™¯] updateFilters å¼‚å¸¸:", e);
                }
            };

            if (fileInput) fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    if (fileName) fileName.textContent = file.name;
                    this._lastImageSource = file;
                    try { await this.scene.loadImage(file); } catch (err) {}
                    if (typeof onUserOverride === 'function') onUserOverride();
                }
            }, sig);

            if (loadUrlBtn) loadUrlBtn.addEventListener('click', async () => {
                const url = (urlInput?.value || '').trim();
                if (url) {
                    if (fileName) fileName.textContent = url.split('/').pop();
                    this._lastImageSource = url;
                    try { await this.scene.loadImage(url); } catch (err) {}
                    if (typeof onUserOverride === 'function') onUserOverride();
                }
            }, sig);

            // æš‚åœ/æ’­æ”¾
            if (stopBtn) stopBtn.addEventListener('click', () => {
                this._isPlaying = !this._isPlaying;
                try {
                    if (this._isPlaying) {
                        this.scene.resume();
                        stopBtn.textContent = 'æš‚åœ';
                    } else {
                        this.scene.pause();
                        stopBtn.textContent = 'æ’­æ”¾';
                    }
                } catch (e) {}
            }, sig);

            // æ»¤é•œç›‘å¬
            if (twistEffect) twistEffect.addEventListener('change', updateFilters, sig);
            if (blurEffect) blurEffect.addEventListener('change', (e) => {
                blurIds.forEach(id => { const el = $(id); if (el) el.checked = e.target.checked; });
                updateFilters();
            }, sig);
            blurIds.concat(['saturation']).forEach(id => {
                const el = $(id);
                if (el) el.addEventListener('change', updateFilters, sig);
            });

            updateFilters();
        }

        async updateFromAlbum(url) {
            if (!this.scene || !url) return;
            this._lastImageSource = url;
            try { await this.scene.loadImage(url); } catch (e) {}
            // å°½é‡åŒæ­¥æ˜¾ç¤º
            const fileNameEl = document.getElementById('fileName');
            if (fileNameEl) fileNameEl.textContent = `[ä¸“è¾‘å°é¢] ${url.split('/').pop()}`;
        }
    }

    // =========================================================
    // === MeshèƒŒæ™¯å®Œæ•´å°è£… ===
    // ï¼ˆä»¥ä¸‹æ ¸å¿ƒæ¸²æŸ“é€»è¾‘å®Œæ•´å¤åˆ¶è‡ª mesh-gradient-background-fixed.htmlï¼Œ
    //  ä»…å¯¹ resize/RAF å¢åŠ å¯é‡Šæ”¾èƒ½åŠ›ï¼Œå¹¶åŠ å…¥ destroy() åšèµ„æºæ¸…ç†ï¼‰
    // =========================================================
    
    // =========================================================
    // === MeshèƒŒæ™¯å®Œæ•´å°è£… ===
    // ï¼ˆä»¥ä¸‹æ ¸å¿ƒæ¸²æŸ“é€»è¾‘å®Œæ•´å¤åˆ¶è‡ª mesh-gradient-background-fixed.htmlï¼Œ
    //  ä»…å¯¹ resize/RAF å¢åŠ å¯é‡Šæ”¾èƒ½åŠ›ï¼Œå¹¶åŠ å…¥ destroy() åšèµ„æºæ¸…ç†ï¼‰
    // =========================================================
    class MeshBackgroundSystem {
        constructor() {
            // åŒ…å«mesh-gradient-background-fixed.htmlçš„æ‰€æœ‰ä»£ç ï¼ˆå®Œæ•´å¤åˆ¶ï¼‰
                        // ============================================
                // é…ç½®
                // ============================================
                const DEFAULT_IMAGE_URL = 'https://imge.kugou.com/stdmusic/orig/20150718/20150718214459760936.jpg';

                // ============================================
                // æ•°å­¦åº“ - å‘é‡å’ŒçŸ©é˜µ (ä» gl-matrix ç®€åŒ–ç§»æ¤)
                // ============================================
                class Vec2 {
                    constructor(x = 0, y = 0) { this.x = x; this.y = y; }
                    static create() { return new Vec2(); }
                    static fromValues(x, y) { return new Vec2(x, y); }
                    copy(v) { this.x = v.x; this.y = v.y; return this; }
                    set(x, y) { this.x = x; this.y = y; return this; }
                    get 0() { return this.x; }
                    set 0(v) { this.x = v; }
                    get 1() { return this.y; }
                    set 1(v) { this.y = v; }
                }

                class Vec3 {
                    constructor(r = 0, g = 0, b = 0) { this.r = r; this.g = g; this.b = b; }
                    static create() { return new Vec3(); }
                    static fromValues(r, g, b) { return new Vec3(r, g, b); }
                    get x() { return this.r; }
                    set x(v) { this.r = v; }
                    get y() { return this.g; }
                    set y(v) { this.g = v; }
                    get z() { return this.b; }
                    set z(v) { this.b = v; }
                }

                class Vec4 {
                    constructor() { this.data = new Float32Array(4); }
                    static create() { return new Vec4(); }
                    get 0() { return this.data[0]; }
                    set 0(v) { this.data[0] = v; }
                    get 1() { return this.data[1]; }
                    set 1(v) { this.data[1] = v; }
                    get 2() { return this.data[2]; }
                    set 2(v) { this.data[2] = v; }
                    get 3() { return this.data[3]; }
                    set 3(v) { this.data[3] = v; }
                    copy(v) { for(let i=0;i<4;i++) this.data[i] = v.data[i]; return this; }
                    dot(v) { return this.data[0]*v.data[0] + this.data[1]*v.data[1] + this.data[2]*v.data[2] + this.data[3]*v.data[3]; }
                    static transformMat4(out, a, m) {
                        const x=a.data[0], y=a.data[1], z=a.data[2], w=a.data[3];
                        out.data[0] = m.data[0]*x + m.data[4]*y + m.data[8]*z + m.data[12]*w;
                        out.data[1] = m.data[1]*x + m.data[5]*y + m.data[9]*z + m.data[13]*w;
                        out.data[2] = m.data[2]*x + m.data[6]*y + m.data[10]*z + m.data[14]*w;
                        out.data[3] = m.data[3]*x + m.data[7]*y + m.data[11]*z + m.data[15]*w;
                        return out;
                    }
                }

                class Mat4 {
                    constructor() { this.data = new Float32Array(16); }
                    static create() { return new Mat4(); }
                    static fromValues(...args) { const m = new Mat4(); for(let i=0;i<16;i++) m.data[i] = args[i] || 0; return m; }
                    static clone(m) { const n = new Mat4(); for(let i=0;i<16;i++) n.data[i] = m.data[i]; return n; }
                    copy(m) { for(let i=0;i<16;i++) this.data[i] = m.data[i]; return this; }
                    fill(v) { for(let i=0;i<16;i++) this.data[i] = v; return this; }
                    transpose() {
                        const d = this.data;
                        const t = (i,j) => { const tmp = d[i*4+j]; d[i*4+j] = d[j*4+i]; d[j*4+i] = tmp; };
                        t(0,1); t(0,2); t(0,3); t(1,2); t(1,3); t(2,3);
                        return this;
                    }
                    static mul(out, a, b) {
                        // æŒ‰ gl-matrix(mat4.multiply) çš„åˆ—ä¸»åºè§„åˆ™å®ç°
                        const outd = out.data, ad = a.data, bd = b.data;

                        const a00 = ad[0],  a01 = ad[1],  a02 = ad[2],  a03 = ad[3];
                        const a10 = ad[4],  a11 = ad[5],  a12 = ad[6],  a13 = ad[7];
                        const a20 = ad[8],  a21 = ad[9],  a22 = ad[10], a23 = ad[11];
                        const a30 = ad[12], a31 = ad[13], a32 = ad[14], a33 = ad[15];

                        const b00 = bd[0],  b01 = bd[1],  b02 = bd[2],  b03 = bd[3];
                        const b10 = bd[4],  b11 = bd[5],  b12 = bd[6],  b13 = bd[7];
                        const b20 = bd[8],  b21 = bd[9],  b22 = bd[10], b23 = bd[11];
                        const b30 = bd[12], b31 = bd[13], b32 = bd[14], b33 = bd[15];

                        outd[0]  = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
                        outd[1]  = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
                        outd[2]  = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
                        outd[3]  = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;

                        outd[4]  = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
                        outd[5]  = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
                        outd[6]  = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
                        outd[7]  = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;

                        outd[8]  = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
                        outd[9]  = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
                        outd[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
                        outd[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;

                        outd[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
                        outd[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
                        outd[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
                        outd[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;

                        return out;
                    }
                }

                // ============================================
                // å›¾åƒå¤„ç†å‡½æ•° (ä» applemusic-like-lyrics å®Œæ•´å¤åˆ¶)
                // ============================================
                function blurImage(imageData, radius, quality) {
                    const pixels = imageData.data;
                    const width = imageData.width;
                    const height = imageData.height;
                    let rsum, gsum, bsum, asum, x, y, i, p, p1, p2, yp, yi, yw;
                    const wm = width - 1, hm = height - 1;
                    const rad1x = radius + 1, divx = radius + rad1x;
                    const rad1y = radius + 1, divy = radius + rad1y;
                    const div2 = 1 / (divx * divy);
                    const r = [], g = [], b = [], a = [], vmin = [], vmax = [];

                    while (quality-- > 0) {
                        yw = yi = 0;
                        for (y = 0; y < height; y++) {
                            rsum = pixels[yw] * rad1x; gsum = pixels[yw + 1] * rad1x;
                            bsum = pixels[yw + 2] * rad1x; asum = pixels[yw + 3] * rad1x;
                            for (i = 1; i <= radius; i++) {
                                p = yw + ((i > wm ? wm : i) << 2);
                                rsum += pixels[p++]; gsum += pixels[p++]; bsum += pixels[p++]; asum += pixels[p];
                            }
                            for (x = 0; x < width; x++) {
                                r[yi] = rsum; g[yi] = gsum; b[yi] = bsum; a[yi] = asum;
                                if (y === 0) { vmin[x] = Math.min(x + rad1x, wm) << 2; vmax[x] = Math.max(x - radius, 0) << 2; }
                                p1 = yw + vmin[x]; p2 = yw + vmax[x];
                                rsum += pixels[p1++] - pixels[p2++]; gsum += pixels[p1++] - pixels[p2++];
                                bsum += pixels[p1++] - pixels[p2++]; asum += pixels[p1] - pixels[p2];
                                yi++;
                            }
                            yw += width << 2;
                        }
                        for (x = 0; x < width; x++) {
                            yp = x;
                            rsum = r[yp] * rad1y; gsum = g[yp] * rad1y; bsum = b[yp] * rad1y; asum = a[yp] * rad1y;
                            for (i = 1; i <= radius; i++) { yp += i > hm ? 0 : width; rsum += r[yp]; gsum += g[yp]; bsum += b[yp]; asum += a[yp]; }
                            yi = x << 2;
                            for (y = 0; y < height; y++) {
                                pixels[yi] = (rsum * div2 + 0.5) | 0; pixels[yi + 1] = (gsum * div2 + 0.5) | 0;
                                pixels[yi + 2] = (bsum * div2 + 0.5) | 0; pixels[yi + 3] = (asum * div2 + 0.5) | 0;
                                if (x === 0) { vmin[y] = Math.min(y + rad1y, hm) * width; vmax[y] = Math.max(y - radius, 0) * width; }
                                p1 = x + vmin[y]; p2 = x + vmax[y];
                                rsum += r[p1] - r[p2]; gsum += g[p1] - g[p2]; bsum += b[p1] - b[p2]; asum += a[p1] - a[p2];
                                yi += width << 2;
                            }
                        }
                    }
                }

                function saturateImage(imageData, saturation) {
                    const pixels = imageData.data;
                    for (let i = 0; i < pixels.length; i += 4) {
                        const r = pixels[i], g = pixels[i + 1], b = pixels[i + 2];
                        const gray = r * 0.3 + g * 0.59 + b * 0.11;
                        pixels[i] = gray * (1 - saturation) + r * saturation;
                        pixels[i + 1] = gray * (1 - saturation) + g * saturation;
                        pixels[i + 2] = gray * (1 - saturation) + b * saturation;
                    }
                }

                function brightnessImage(imageData, brightness) {
                    const pixels = imageData.data;
                    for (let i = 0; i < pixels.length; i += 4) {
                        pixels[i] *= brightness; pixels[i + 1] *= brightness; pixels[i + 2] *= brightness;
                    }
                }

                function contrastImage(imageData, contrast) {
                    const pixels = imageData.data;
                    for (let i = 0; i < pixels.length; i += 4) {
                        pixels[i] = (pixels[i] - 128) * contrast + 128;
                        pixels[i + 1] = (pixels[i + 1] - 128) * contrast + 128;
                        pixels[i + 2] = (pixels[i + 2] - 128) * contrast + 128;
                    }
                }

                // ============================================
                // Bicubic Hermite Patch è´å¡å°”æ›²é¢æ ¸å¿ƒå®ç°
                // (ä» applemusic-like-lyrics å®Œæ•´ç§»æ¤)
                // ============================================
    
                // Hermite åŸºå‡½æ•°çŸ©é˜µ
                const H = Mat4.fromValues(2, -2, 1, 1, -3, 3, -2, -1, 0, 0, 1, 0, 1, 0, 0, 0);
                const H_T = Mat4.clone(H); H_T.transpose();

                // æ§åˆ¶ç‚¹ç±»
                class ControlPoint {
                    constructor() {
                        this.color = Vec3.fromValues(1, 1, 1);
                        this.location = Vec2.fromValues(0, 0);
                        this.uTangent = Vec2.fromValues(0, 0);
                        this.vTangent = Vec2.fromValues(0, 0);
                        this._uRot = 0; this._vRot = 0;
                        this._uScale = 1; this._vScale = 1;
                    }
                    get uRot() { return this._uRot; }
                    set uRot(value) { this._uRot = value; this.updateUTangent(); }
                    get vRot() { return this._vRot; }
                    set vRot(value) { this._vRot = value; this.updateVTangent(); }
                    get uScale() { return this._uScale; }
                    set uScale(value) { this._uScale = value; this.updateUTangent(); }
                    get vScale() { return this._vScale; }
                    set vScale(value) { this._vScale = value; this.updateVTangent(); }
                    updateUTangent() { this.uTangent.x = Math.cos(this._uRot) * this._uScale; this.uTangent.y = Math.sin(this._uRot) * this._uScale; }
                    updateVTangent() { this.vTangent.x = -Math.sin(this._vRot) * this._vScale; this.vTangent.y = Math.cos(this._vRot) * this._vScale; }
                }

                // æ›²é¢ç‚¹è®¡ç®— - æ ¸å¿ƒè´å¡å°”ç®—æ³•
                const spUx = Vec4.create(), spUy = Vec4.create(), spV = Vec4.create();
                const spxAcc = Mat4.create(), spyAcc = Mat4.create();
    
                function surfacePoint(u, v, X, Y, output = Vec2.create()) {
                    spUx[0] = u ** 3; spUx[1] = u ** 2; spUx[2] = u; spUx[3] = 1;
                    spUy.copy(spUx);
                    spV[0] = v ** 3; spV[1] = v ** 2; spV[2] = v; spV[3] = 1;

                    spxAcc.copy(X).transpose();
                    Mat4.mul(spxAcc, spxAcc, H);
                    Mat4.mul(spxAcc, H_T, spxAcc);
                    Vec4.transformMat4(spUx, spUx, spxAcc);
                    const x = spV.dot(spUx);

                    spyAcc.copy(Y).transpose();
                    Mat4.mul(spyAcc, spyAcc, H);
                    Mat4.mul(spyAcc, H_T, spyAcc);
                    Vec4.transformMat4(spUy, spUy, spyAcc);
                    const y = spV.dot(spUy);

                    output.x = x; output.y = y;
                    return output;
                }

                // ç½‘æ ¼ç³»æ•°çŸ©é˜µ
                function meshCoefficients(p00, p01, p10, p11, axis, output = Mat4.create()) {
                    const l = p => p.location[axis];
                    const u = p => p.uTangent[axis];
                    const v = p => p.vTangent[axis];

                    output.data[0] = l(p00); output.data[1] = l(p01); output.data[2] = v(p00); output.data[3] = v(p01);
                    output.data[4] = l(p10); output.data[5] = l(p11); output.data[6] = v(p10); output.data[7] = v(p11);
                    output.data[8] = u(p00); output.data[9] = u(p01); output.data[10] = 0; output.data[11] = 0;
                    output.data[12] = u(p10); output.data[13] = u(p11); output.data[14] = 0; output.data[15] = 0;
                    return output;
                }

                // é¢œè‰²ç³»æ•°çŸ©é˜µ
                function colorCoefficients(p00, p01, p10, p11, axis, output = Mat4.create()) {
                    const c = p => p.color[axis];
                    output.fill(0);
                    output.data[0] = c(p00); output.data[1] = c(p01);
                    output.data[4] = c(p10); output.data[5] = c(p11);
                    return output;
                }

                const cpUx = Vec4.create(), cpUy = Vec4.create(), cpUz = Vec4.create(), cpV = Vec4.create();
                const cprAcc = Mat4.create(), cpgAcc = Mat4.create(), cpbAcc = Mat4.create();
                const cpResult = Vec3.create();
    
                function colorPoint(u, v, R, G, B) {
                    cpUx[0] = u ** 3; cpUx[1] = u ** 2; cpUx[2] = u; cpUx[3] = 1;
                    cpUy.copy(cpUx); cpUz.copy(cpUx);
                    cpV[0] = v ** 3; cpV[1] = v ** 2; cpV[2] = v; cpV[3] = 1;

                    cprAcc.copy(R).transpose(); Mat4.mul(cprAcc, cprAcc, H); Mat4.mul(cprAcc, H_T, cprAcc);
                    Vec4.transformMat4(cpUx, cpUx, cprAcc); cpResult.r = cpV.dot(cpUx);

                    cpgAcc.copy(G).transpose(); Mat4.mul(cpgAcc, cpgAcc, H); Mat4.mul(cpgAcc, H_T, cpgAcc);
                    Vec4.transformMat4(cpUy, cpUy, cpgAcc); cpResult.g = cpV.dot(cpUy);

                    cpbAcc.copy(B).transpose(); Mat4.mul(cpbAcc, cpbAcc, H); Mat4.mul(cpbAcc, H_T, cpbAcc);
                    Vec4.transformMat4(cpUz, cpUz, cpbAcc); cpResult.b = cpV.dot(cpUz);

                    return cpResult;
                }

                // 2D Map æ•°æ®ç»“æ„
                class Map2D {
                    constructor(width, height) { this._width = width; this._height = height; this._data = new Array(width * height).fill(null); }
                    resize(width, height) { this._width = width; this._height = height; this._data = new Array(width * height).fill(null); }
                    set(x, y, value) { this._data[x + y * this._width] = value; }
                    get(x, y) { return this._data[x + y * this._width]; }
                    get width() { return this._width; }
                    get height() { return this._height; }
                }

                // ============================================
                // Bicubic Hermite Patch Mesh ç±»
                // ============================================
                class BHPMesh {
                    constructor() {
                        this._subDivisions = 15;
                        this._controlPoints = new Map2D(3, 3);
                        this.vertexData = null;
                        this.indexData = null;
                        this.vertexWidth = 0;
                        this.vertexHeight = 0;
                        this.tempX = Mat4.create(); this.tempY = Mat4.create();
                        this.tempR = Mat4.create(); this.tempG = Mat4.create(); this.tempB = Mat4.create();
                        this.tmpV2 = Vec2.create();
                        this.resizeControlPoints(3, 3);
                    }

                    resetSubdivision(subDivisions) {
                        this._subDivisions = subDivisions;
                        this.vertexWidth = (this._controlPoints.width - 1) * subDivisions;
                        this.vertexHeight = (this._controlPoints.height - 1) * subDivisions;
                        const vertexCount = this.vertexWidth * this.vertexHeight;
                        this.vertexData = new Float32Array(vertexCount * 7); // pos(2) + color(3) + uv(2)
                        this.indexData = new Uint16Array((this.vertexWidth - 1) * (this.vertexHeight - 1) * 6);
            
                        // ç”Ÿæˆç´¢å¼•
                        let idx = 0;
                        for (let y = 0; y < this.vertexHeight - 1; y++) {
                            for (let x = 0; x < this.vertexWidth - 1; x++) {
                                const i = y * this.vertexWidth + x;
                                this.indexData[idx++] = i;
                                this.indexData[idx++] = i + 1;
                                this.indexData[idx++] = i + this.vertexWidth;
                                this.indexData[idx++] = i + 1;
                                this.indexData[idx++] = i + this.vertexWidth + 1;
                                this.indexData[idx++] = i + this.vertexWidth;
                            }
                        }
                    }

                    resizeControlPoints(width, height) {
                        if (width < 2 || height < 2) throw new Error("Control points must be at least 2x2");
                        this._controlPoints.resize(width, height);
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                const point = new ControlPoint();
                                point.location.x = (x / (width - 1)) * 2 - 1;
                                point.location.y = (y / (height - 1)) * 2 - 1;
                                point.uTangent.x = 2 / (width - 1);
                                point.vTangent.y = 2 / (height - 1);
                                this._controlPoints.set(x, y, point);
                            }
                        }
                        this.resetSubdivision(this._subDivisions);
                    }

                    getControlPoint(x, y) { return this._controlPoints.get(x, y); }

                    setVertexData(vx, vy, px, py, pr, pg, pb, uvX, uvY) {
                        const idx = (vx + vy * this.vertexWidth) * 7;
                        this.vertexData[idx] = px; this.vertexData[idx + 1] = py;
                        this.vertexData[idx + 2] = pr; this.vertexData[idx + 3] = pg; this.vertexData[idx + 4] = pb;
                        this.vertexData[idx + 5] = uvX; this.vertexData[idx + 6] = uvY;
                    }

                    // æ ¸å¿ƒï¼šæ›´æ–°ç½‘æ ¼é¡¶ç‚¹æ•°æ®
                    updateMesh() {
                        const subDivM1 = this._subDivisions - 1;
                        const tW = subDivM1 * (this._controlPoints.height - 1);
                        const tH = subDivM1 * (this._controlPoints.width - 1);
                        const cpW = this._controlPoints.width;
                        const cpH = this._controlPoints.height;
                        const subDiv = this._subDivisions;
                        const invSubDivM1 = 1 / subDivM1;
                        const invTH = 1 / tH;
                        const invTW = 1 / tW;

                        for (let x = 0; x < cpW - 1; x++) {
                            for (let y = 0; y < cpH - 1; y++) {
                                const p00 = this._controlPoints.get(x, y);
                                const p01 = this._controlPoints.get(x, y + 1);
                                const p10 = this._controlPoints.get(x + 1, y);
                                const p11 = this._controlPoints.get(x + 1, y + 1);

                                meshCoefficients(p00, p01, p10, p11, 'x', this.tempX);
                                meshCoefficients(p00, p01, p10, p11, 'y', this.tempY);
                                colorCoefficients(p00, p01, p10, p11, 'r', this.tempR);
                                colorCoefficients(p00, p01, p10, p11, 'g', this.tempG);
                                colorCoefficients(p00, p01, p10, p11, 'b', this.tempB);

                                const sX = x / (cpW - 1);
                                const sY = y / (cpH - 1);
                                const baseVx = y * subDiv;
                                const baseVy = x * subDiv;

                                for (let u = 0; u < subDiv; u++) {
                                    const uNorm = u * invSubDivM1;
                                    const vxOffset = baseVx + u;

                                    for (let v = 0; v < subDiv; v++) {
                                        const vNorm = v * invSubDivM1;
                                        const vy = baseVy + v;

                                        const pos = surfacePoint(uNorm, vNorm, this.tempX, this.tempY, this.tmpV2);
                                        const col = colorPoint(uNorm, vNorm, this.tempR, this.tempG, this.tempB);
                                        const uvX = sX + v * invTH;
                                        const uvY = 1 - sY - u * invTW;

                                        this.setVertexData(vxOffset, vy, pos.x, pos.y, col.r, col.g, col.b, uvX, uvY);
                                    }
                                }
                            }
                        }
                    }
                }

                // ============================================
                // ç½‘æ ¼é¢„è®¾ (ä»é¡¹ç›®å®Œæ•´å¤åˆ¶)
                // ============================================
                const CONTROL_POINT_PRESETS = [
                    { width: 4, height: 4, conf: [
                        {cx:0,cy:0,x:-1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:0,x:-0.33,y:-1,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:0,x:0.33,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:0,x:1,y:-1,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:1,x:-1,y:-0.04,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:1,x:-0.24,y:-0.22,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:1,x:0.33,y:-0.005,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:1,x:0.99,y:-0.34,ur:8,vr:0,up:0.566,vp:1.792},
                        {cx:0,cy:2,x:-1,y:0.33,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:2,x:-0.34,y:0,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:2,x:0.33,y:0.2,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:2,x:1,y:0.08,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:3,x:-1,y:1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:3,x:-0.33,y:1,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:3,x:0.33,y:1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:3,x:1,y:1,ur:0,vr:0,up:1,vp:1},
                    ]},
                    { width: 5, height: 5, conf: [
                        {cx:0,cy:0,x:-1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:0,x:-0.5,y:-1,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:0,x:0,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:0,x:0.5,y:-1,ur:0,vr:0,up:1,vp:1},
                        {cx:4,cy:0,x:1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:0,cy:1,x:-1,y:-0.5,ur:0,vr:0,up:1,vp:1},
                        {cx:1,cy:1,x:-0.5,y:-0.5,ur:0,vr:0,up:1,vp:1}, {cx:2,cy:1,x:-0.005,y:-0.61,ur:0,vr:0,up:1,vp:1},
                        {cx:3,cy:1,x:0.59,y:-0.4,ur:0,vr:0,up:1,vp:1}, {cx:4,cy:1,x:1,y:-0.5,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:2,x:-1,y:0,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:2,x:-0.42,y:-0.12,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:2,x:-0.1,y:-0.02,ur:0,vr:-47,up:0.629,vp:0.849}, {cx:3,cy:2,x:0.4,y:-0.06,ur:0,vr:0,up:1,vp:1},
                        {cx:4,cy:2,x:1,y:0,ur:0,vr:0,up:1,vp:1}, {cx:0,cy:3,x:-1,y:0.5,ur:0,vr:0,up:1,vp:1},
                        {cx:1,cy:3,x:0.07,y:0.52,ur:-31,vr:-45,up:1,vp:1}, {cx:2,cy:3,x:0.21,y:0.29,ur:6,vr:-56,up:0.566,vp:1.321},
                        {cx:3,cy:3,x:0.5,y:0.5,ur:0,vr:0,up:1,vp:1}, {cx:4,cy:3,x:1,y:0.5,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:4,x:-1,y:1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:4,x:-0.31,y:1,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:4,x:0.26,y:1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:4,x:0.5,y:1,ur:0,vr:0,up:1,vp:1},
                        {cx:4,cy:4,x:1,y:1,ur:0,vr:0,up:1,vp:1},
                    ]},
                    { width: 5, height: 5, conf: [
                        {cx:0,cy:0,x:-1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:0,x:-0.45,y:-1,ur:0,vr:55,up:1,vp:2.075},
                        {cx:2,cy:0,x:0.2,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:0,x:0.46,y:-1,ur:0,vr:-25,up:1,vp:1},
                        {cx:4,cy:0,x:1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:0,cy:1,x:-1,y:-0.25,ur:-16,vr:0,up:2.327,vp:0.943},
                        {cx:1,cy:1,x:-0.56,y:-0.66,ur:47,vr:0,up:2.358,vp:0.377}, {cx:2,cy:1,x:0.23,y:-0.52,ur:-66,vr:-25,up:1.855,vp:1.164},
                        {cx:3,cy:1,x:0.69,y:-0.38,ur:0,vr:0,up:1,vp:1}, {cx:4,cy:1,x:1,y:-0.67,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:2,x:-1,y:0.04,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:2,x:-0.49,y:0.01,ur:90,vr:23,up:1,vp:1.981},
                        {cx:2,cy:2,x:0.02,y:-0.14,ur:0,vr:42,up:1,vp:1}, {cx:3,cy:2,x:0.48,y:0.06,ur:-30,vr:0,up:1.95,vp:0.44},
                        {cx:4,cy:2,x:1,y:0.25,ur:0,vr:0,up:1,vp:1}, {cx:0,cy:3,x:-1,y:0.7,ur:-68,vr:0,up:1,vp:0.786},
                        {cx:1,cy:3,x:-0.69,y:0.59,ur:-68,vr:0,up:1,vp:1}, {cx:2,cy:3,x:0.18,y:0.39,ur:61,vr:0,up:1,vp:1},
                        {cx:3,cy:3,x:0.61,y:0.46,ur:-47,vr:-59,up:0.849,vp:1.73}, {cx:4,cy:3,x:1,y:0.62,ur:-33,vr:0,up:0.377,vp:1.604},
                        {cx:0,cy:4,x:-1,y:1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:4,x:-0.5,y:1,ur:0,vr:-73,up:1,vp:1},
                        {cx:2,cy:4,x:-0.33,y:1,ur:0,vr:-24,up:0.314,vp:2.704}, {cx:3,cy:4,x:0.5,y:1,ur:0,vr:0,up:1,vp:1},
                        {cx:4,cy:4,x:1,y:1,ur:0,vr:0,up:1,vp:1},
                    ]}
                ];

                function generateRandomPreset(w, h) {
                    const conf = [];
                    for (let y = 0; y < h; y++) {
                        for (let x = 0; x < w; x++) {
                            const baseX = (x / (w - 1)) * 2 - 1;
                            const baseY = (y / (h - 1)) * 2 - 1;
                            const isEdge = x === 0 || x === w - 1 || y === 0 || y === h - 1;
                            conf.push({
                                cx: x, cy: y,
                                x: isEdge ? baseX : baseX + (Math.random() - 0.5) * 0.6,
                                y: isEdge ? baseY : baseY + (Math.random() - 0.5) * 0.6,
                                ur: isEdge ? 0 : (Math.random() - 0.5) * 120,
                                vr: isEdge ? 0 : (Math.random() - 0.5) * 120,
                                up: 0.3 + Math.random() * 1.7,
                                vp: 0.3 + Math.random() * 1.7
                            });
                        }
                    }
                    return { width: w, height: h, conf };
                }

                // ============================================
                // WebGL æ¸²æŸ“å™¨
                // ============================================
                const vertexShaderSource = `
                    precision highp float;

                    attribute vec2 a_pos;
                    attribute vec3 a_color;
                    attribute vec2 a_uv;

                    varying vec3 v_color;
                    varying vec2 v_uv;

                    uniform float u_aspect;

                    void main() {
                        v_color = a_color;
                        v_uv = a_uv;

                        vec2 pos = a_pos;
                        if (u_aspect > 1.0) {
                            pos.y *= u_aspect;
                        } else {
                            pos.x /= u_aspect;
                        }

                        gl_Position = vec4(pos, 0.0, 1.0);
                    }
                `;


                const fragmentShaderSource = `
                    precision highp float;

                    varying vec3 v_color;
                    varying vec2 v_uv;

                    uniform sampler2D u_texture;
                    uniform float u_time;
                    uniform float u_alpha;
                    uniform float u_volume;

                    const float INV_255 = 1.0 / 255.0;
                    const float GRADIENT_NOISE_A = 52.9829189;
                    const vec2 GRADIENT_NOISE_B = vec2(0.06711056, 0.00583715);

                    float gradientNoise(vec2 uv) {
                        return fract(GRADIENT_NOISE_A * fract(dot(uv, GRADIENT_NOISE_B)));
                    }

                    vec2 rot(vec2 v, float angle) {
                        float s = sin(angle);
                        float c = cos(angle);
                        return vec2(c * v.x - s * v.y, s * v.x + c * v.y);
                    }

                    void main() {
                        // Dithering. NOTE: This may look weird in some videos, so comment it out in your projects if you don't like it.
                        float dither = INV_255 * gradientNoise(gl_FragCoord.xy) - 0.5 * INV_255;

                        float timeVolume = u_time + u_volume;

                        vec2 centeredUV = v_uv - vec2(0.2);
                        vec2 rotatedUV = rot(centeredUV, timeVolume * 2.0);
                        vec2 finalUV = rotatedUV + vec2(0.5);

                        vec4 result = texture2D(u_texture, finalUV);
                        result.rgb *= v_color * u_alpha;
                        result.a *= u_alpha;
                        result.rgb += vec3(dither);

                        float dist = distance(v_uv, vec2(0.5));
                        float vignette = smoothstep(0.8, 0.3, dist);
                        result.rgb *= 0.6 + vignette * 0.4;

                        gl_FragColor = result;
                    }
                `;


                class MeshGradientRenderer {
                    constructor(canvas) {
                        this.canvas = canvas;
                        this.gl = canvas.getContext('webgl', { alpha: true, premultipliedAlpha: false, preserveDrawingBuffer: true, powerPreference: 'low-power' });
                        if (!this.gl) throw new Error('WebGL not supported');
            
                        this.paused = false;
                        this.time = 0;
                        this.speed = 1;
                        this.subdivisions = 15;
                        this.imageSettings = { contrast: 0.4, saturation: 3.0, brightness: 0.75, blur: 2 };
                        this.mesh = new BHPMesh();
                        this.preset = CONTROL_POINT_PRESETS[0];
            
                        // â˜… é›†æˆå¢å¼ºï¼šå¯é”€æ¯æ ‡è®°/RAF/resize-handler
                        this._destroyed = false;
                        this._rafId = null;
                        this._onResize = null;

                        this.init();
                        this.resize();
                        this.animate();
            
                        this._onResize = () => { if (this._resizeRaf) cancelAnimationFrame(this._resizeRaf); this._resizeRaf = requestAnimationFrame(() => this.resize()); };
                        window.addEventListener('resize', this._onResize);
                    }
        
                    init() {
                        const gl = this.gl;
            
                        const vs = gl.createShader(gl.VERTEX_SHADER);
                        gl.shaderSource(vs, vertexShaderSource);
                        gl.compileShader(vs);
            
                        const fs = gl.createShader(gl.FRAGMENT_SHADER);
                        gl.shaderSource(fs, fragmentShaderSource);
                        gl.compileShader(fs);

                        // â˜… é›†æˆå¢å¼ºï¼šä¿å­˜ shader å¼•ç”¨ï¼Œä¾¿äº destroy æ—¶é‡Šæ”¾
                        this._vs = vs;
                        this._fs = fs;
            
                        this.program = gl.createProgram();
                        gl.attachShader(this.program, vs);
                        gl.attachShader(this.program, fs);
                        gl.linkProgram(this.program);
            
                        this.posAttr = gl.getAttribLocation(this.program, 'a_pos');
                        this.colorAttr = gl.getAttribLocation(this.program, 'a_color');
                        this.uvAttr = gl.getAttribLocation(this.program, 'a_uv');
                        this.timeUniform = gl.getUniformLocation(this.program, 'u_time');
                        this.alphaUniform = gl.getUniformLocation(this.program, 'u_alpha');
                        this.textureUniform = gl.getUniformLocation(this.program, 'u_texture');
            
            
                        this.aspectUniform = gl.getUniformLocation(this.program, 'u_aspect');
                        this.volumeUniform = gl.getUniformLocation(this.program, 'u_volume');
            this.vertexBuffer = gl.createBuffer();
                        this.indexBuffer = gl.createBuffer();
            
                        gl.enable(gl.BLEND);
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                        gl.enable(gl.DEPTH_TEST);
                        gl.depthFunc(gl.ALWAYS);
            
                        this.applyPreset(this.preset);
                    }
        
                    applyPreset(preset) {
                        this.preset = preset;
                        this.mesh.resizeControlPoints(preset.width, preset.height);
                        const uPower = 2 / (preset.width - 1);
                        const vPower = 2 / (preset.height - 1);
            
                        for (const cp of preset.conf) {
                            const p = this.mesh.getControlPoint(cp.cx, cp.cy);
                            p.location.x = cp.x;
                            p.location.y = cp.y;
                            p.uRot = (cp.ur * Math.PI) / 180;
                            p.vRot = (cp.vr * Math.PI) / 180;
                            p.uScale = uPower * cp.up;
                            p.vScale = vPower * cp.vp;
                        }
            
                        this.mesh.resetSubdivision(this.subdivisions);
                        this.mesh.updateMesh();
                        this.uploadMesh();
                    }
        
                    uploadMesh() {
                        const gl = this.gl;
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, this.mesh.vertexData, gl.DYNAMIC_DRAW);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.mesh.indexData, gl.STATIC_DRAW);
                    }
        
                    async loadImage(source) {
                        return new Promise((resolve) => {
                            const img = new Image();
                            img.crossOrigin = 'anonymous';
                            img.onload = () => { this.processImage(img); resolve(); };
                            img.onerror = () => { this.createFallbackTexture(); resolve(); };
                
                            if (source instanceof File) {
                                const reader = new FileReader();
                                reader.onload = (e) => { img.src = e.target.result; };
                                reader.readAsDataURL(source);
                            } else {
                                img.src = source;
                            }
                        });
                    }
        
                    processImage(img) {
                        const size = 32;
                        const canvas = document.createElement('canvas');
                        canvas.width = size; canvas.height = size;
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });
                        ctx.drawImage(img, 0, 0, size, size);
                        const imageData = ctx.getImageData(0, 0, size, size);
            
                        contrastImage(imageData, this.imageSettings.contrast);
                        saturateImage(imageData, this.imageSettings.saturation);
                        contrastImage(imageData, 1.7);
                        brightnessImage(imageData, this.imageSettings.brightness);
                        if (this.imageSettings.blur > 0) blurImage(imageData, this.imageSettings.blur, 4);
            
                        ctx.putImageData(imageData, 0, 0);
                        this.uploadTexture(canvas);
                    }
        
                    createFallbackTexture() {
                        const canvas = document.createElement('canvas');
                        canvas.width = 32; canvas.height = 32;
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });
                        const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 22.5);
                        gradient.addColorStop(0, '#ff6b6b');
                        gradient.addColorStop(0.5, '#4ecdc4');
                        gradient.addColorStop(1, '#45b7d1');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, 32, 32);
                        this.uploadTexture(canvas);
                    }
        
                    uploadTexture(canvas) {
                        const gl = this.gl;
                        if (this.texture) gl.deleteTexture(this.texture);
                        this.texture = gl.createTexture();
                        gl.bindTexture(gl.TEXTURE_2D, this.texture);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
                    }
        
                    resize() {
                        // è·å–å¡ç‰‡å®¹å™¨ä½œä¸ºå‚è€ƒå°ºå¯¸
                        const card = document.getElementById('card');
                        if (!card) {
                            // å¤‡ç”¨ï¼šä½¿ç”¨layerElçš„å°ºå¯¸
                            const rect = this.layerEl ? this.layerEl.getBoundingClientRect() : null;
                            if (!rect) return;

                            const cssW = Math.max(1, rect.width);
                            const cssH = Math.max(1, rect.height);
                            const baseDpr = Math.max(1, window.devicePixelRatio || 1);
                            const exportScale = (window.__LYRICS_CARD_EXPORT_SCALE || 1);
let previewScale = 1;
                            try {
                                const c = document.getElementById('card');
                                if (c) {
                                    const rect2 = c.getBoundingClientRect();
                                    const ow2 = c.offsetWidth || c.clientWidth || rect2.width;
                                    if (ow2 > 0) previewScale = Math.max(0.05, Math.min(1, rect2.width / ow2));
                                }
                            } catch (_) {}

                            let dpr = baseDpr * exportScale * previewScale;
                            const perf = (window.__LYRICS_PERF || {});
                            const isExporting = (exportScale && exportScale !== 1);
                            const maxDpr = isExporting ? Math.max(1.5, (perf.maxPreviewDpr || 2)) : (perf.maxPreviewDpr || 2);
                            dpr = Math.min(dpr, maxDpr);
                            const maxPixels = isExporting ? (perf.maxCanvasPixelsExport || 5000000) : (perf.maxCanvasPixelsPreview || 1800000);
                            const wantedPixels = (cssW * dpr) * (cssH * dpr);
                            if (wantedPixels > maxPixels) {
                              const s = Math.sqrt(maxPixels / wantedPixels);
                              dpr = Math.max(0.5, dpr * s);
                            }

                            this.canvas.width = Math.max(1, Math.round(cssW * dpr));
                            this.canvas.height = Math.max(1, Math.round(cssH * dpr));
                            this.canvas.style.width = cssW + 'px';
                            this.canvas.style.height = cssH + 'px';
                        } else {
                            // ä½¿ç”¨å¡ç‰‡çš„å®é™…CSSåƒç´ å°ºå¯¸
                            const computedStyle = window.getComputedStyle(card);
                            const cssW = parseFloat(computedStyle.width) || 1200;
                            const cssH = parseFloat(computedStyle.height) || 2100;

                            const baseDpr = Math.max(1, window.devicePixelRatio || 1);
                            const exportScale = (window.__LYRICS_CARD_EXPORT_SCALE || 1);
let previewScale = 1;
                            try {
                                const c = document.getElementById('card');
                                if (c) {
                                    const rect2 = c.getBoundingClientRect();
                                    const ow2 = c.offsetWidth || c.clientWidth || rect2.width;
                                    if (ow2 > 0) previewScale = Math.max(0.05, Math.min(1, rect2.width / ow2));
                                }
                            } catch (_) {}

                            let dpr = baseDpr * exportScale * previewScale;
                            const perf = (window.__LYRICS_PERF || {});
                            const isExporting = (exportScale && exportScale !== 1);
                            const maxDpr = isExporting ? Math.max(1.5, (perf.maxPreviewDpr || 2)) : (perf.maxPreviewDpr || 2);
                            dpr = Math.min(dpr, maxDpr);
                            const maxPixels = isExporting ? (perf.maxCanvasPixelsExport || 5000000) : (perf.maxCanvasPixelsPreview || 1800000);
                            const wantedPixels = (cssW * dpr) * (cssH * dpr);
                            if (wantedPixels > maxPixels) {
                              const s = Math.sqrt(maxPixels / wantedPixels);
                              dpr = Math.max(0.5, dpr * s);
                            }

                            this.canvas.width = Math.max(1, Math.round(cssW * dpr));
                            this.canvas.height = Math.max(1, Math.round(cssH * dpr));
                            this.canvas.style.width = cssW + 'px';
                            this.canvas.style.height = cssH + 'px';
                        }

                        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    }
        
                    render() {
                        const gl = this.gl;
                        gl.clearColor(0, 0, 0, 0);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        if (!this.texture) return;
            
                        gl.useProgram(this.program);
                        gl.uniform1f(this.timeUniform, this.time / 10000);
                        gl.uniform1f(this.alphaUniform, 1.0);
                        gl.uniform1f(this.aspectUniform, this.canvas.width / this.canvas.height);
                        gl.uniform1f(this.volumeUniform, 0.0);
            
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, this.texture);
                        gl.uniform1i(this.textureUniform, 0);
            
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            
                        const stride = 7 * 4;
                        gl.enableVertexAttribArray(this.posAttr);
                        gl.vertexAttribPointer(this.posAttr, 2, gl.FLOAT, false, stride, 0);
                        gl.enableVertexAttribArray(this.colorAttr);
                        gl.vertexAttribPointer(this.colorAttr, 3, gl.FLOAT, false, stride, 8);
                        gl.enableVertexAttribArray(this.uvAttr);
                        gl.vertexAttribPointer(this.uvAttr, 2, gl.FLOAT, false, stride, 20);
            
                        gl.drawElements(gl.TRIANGLES, this.mesh.indexData.length, gl.UNSIGNED_SHORT, 0);
                    }
        
                    animate() {
                        if (this._destroyed) return;
                        if (this.paused || document.hidden) { this._rafId = null; return; }

                        const now = performance.now();
                        // PERF: cap FPS on mobile/low-end
                        const perf = (window.__LYRICS_PERF || {});
                        const fps = perf.targetFps || 60;
                        const minInterval = 1000 / fps;
                        if (!this._lastRenderTime) this._lastRenderTime = 0;
                        if (now - this._lastRenderTime < minInterval) {
                          this._rafId = requestAnimationFrame(() => this.animate());
                          return;
                        }
                        this._lastRenderTime = now;

                        let dt = this._lastTime ? (now - this._lastTime) : 16.67;
                        this._lastTime = now;
                        dt = Math.min(33.33, Math.max(0, dt)); // é™åˆ¶ deltaTimeï¼Œé¿å…å¡é¡¿ç´¯ç§¯

                        this.time += dt * this.speed;
                        this.render();
                        this._rafId = requestAnimationFrame(() => this.animate());
                    }
        
                    pause() { this.paused = true; }
                    resume() { this.paused = false; }
        
                    randomizePreset() {
                        const w = 4 + Math.floor(Math.random() * 3);
                        const h = 4 + Math.floor(Math.random() * 3);
                        this.applyPreset(generateRandomPreset(w, h));
                    }
        
                    setSubdivisions(value) {
                        this.subdivisions = value;
                        this.mesh.resetSubdivision(value);
                        this.mesh.updateMesh();
                        this.uploadMesh();
                    }

                    // â˜… é›†æˆå¢å¼ºï¼šå®Œæ•´æ¸…ç†èµ„æºï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
                    destroy() {
                        this._destroyed = true;

                        try { if (this._rafId) cancelAnimationFrame(this._rafId); } catch (_) {}
                        try { if (this._onResize) window.removeEventListener('resize', this._onResize); } catch (_) {}

                        const gl = this.gl;
                        if (!gl) return;

                        try { if (this.texture) gl.deleteTexture(this.texture); } catch (_) {}
                        try { if (this.vertexBuffer) gl.deleteBuffer(this.vertexBuffer); } catch (_) {}
                        try { if (this.indexBuffer) gl.deleteBuffer(this.indexBuffer); } catch (_) {}

                        try { if (this.program) gl.deleteProgram(this.program); } catch (_) {}
                        try { if (this._vs) gl.deleteShader(this._vs); } catch (_) {}
                        try { if (this._fs) gl.deleteShader(this._fs); } catch (_) {}

                        try {
                            const ext = gl.getExtension('WEBGL_lose_context');
                            if (ext && ext.loseContext) ext.loseContext();
                        } catch (_) {}

                        this.gl = null;
                    }
                }

                // ============================================
                // åˆå§‹åŒ–
                // ============================================
                let renderer = null;
                let lastImageSource = null;

                async function init() {
                    const canvas = document.getElementById('canvas');
                    renderer = new MeshGradientRenderer(canvas);
                    renderer.createFallbackTexture();
        
                    try {
                        lastImageSource = DEFAULT_IMAGE_URL;
                        await renderer.loadImage(DEFAULT_IMAGE_URL);
                        document.getElementById('fileName').textContent = DEFAULT_IMAGE_URL.split('/').pop();
                    } catch (e) {
                        console.log('Using fallback');
                    }
        
                    bindControls();
                }

                function bindControls() {
                    document.getElementById('fileInput').addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            document.getElementById('fileName').textContent = file.name;
                            lastImageSource = file;
                            await renderer.loadImage(file);
                        }
                    });
        
                    document.getElementById('loadUrlBtn').addEventListener('click', async () => {
                        const url = document.getElementById('urlInput').value.trim();
                        if (url) {
                            document.getElementById('fileName').textContent = url.split('/').pop();
                            lastImageSource = url;
                            await renderer.loadImage(url);
                        }
                    });
        
                    let isPaused = false;
                    document.getElementById('pauseBtn').addEventListener('click', () => {
                        isPaused = !isPaused;
                        if (isPaused) { renderer.pause(); document.getElementById('pauseBtn').textContent = 'æ’­æ”¾'; }
                        else { renderer.resume(); document.getElementById('pauseBtn').textContent = 'æš‚åœ'; }
                    });
        
                    const reloadImage = async () => { if (lastImageSource) await renderer.loadImage(lastImageSource); };
        
                    document.getElementById('contrast').addEventListener('input', async (e) => {
                        renderer.imageSettings.contrast = e.target.value / 100;
                        await reloadImage();
                    });
                    document.getElementById('saturation').addEventListener('input', async (e) => {
                        renderer.imageSettings.saturation = e.target.value / 100;
                        await reloadImage();
                    });
                    document.getElementById('brightness').addEventListener('input', async (e) => {
                        renderer.imageSettings.brightness = e.target.value / 100;
                        await reloadImage();
                    });
                    document.getElementById('blur').addEventListener('input', async (e) => {
                        renderer.imageSettings.blur = parseInt(e.target.value);
                        await reloadImage();
                    });
                    document.getElementById('speed').addEventListener('input', (e) => {
                        renderer.speed = e.target.value / 100;
                    });
                    document.getElementById('subdivisions').addEventListener('input', (e) => {
                        renderer.setSubdivisions(parseInt(e.target.value));
                    });
                    document.getElementById('randomPreset').addEventListener('click', () => {
                        renderer.randomizePreset();
                    });
                }

                // window.addEventListener('DOMContentLoaded', init);  // å·²ç”±é›†æˆç‰ˆèƒŒæ™¯ç®¡ç†å™¨æ¥ç®¡åˆå§‹åŒ–

            // è¿è¡Œæ€å˜é‡ï¼ˆå¤–å±‚å°è£…ä½¿ç”¨ï¼‰
            this.renderer = null;
            this.canvas = null;
            this.layerEl = null;
            this.lastImageSource = null;
            this._controlsAbort = null;

            // ä»åŸè„šæœ¬ä¸­æŠ½å–çš„æ ¸å¿ƒç±»ï¼šMeshGradientRenderer
            // ï¼ˆæ³¨æ„ï¼šMeshGradientRenderer åœ¨ä¸Šé¢çš„åŸè„šæœ¬ä¸­ä»¥ class å½¢å¼å®šä¹‰ï¼‰
            this._MeshGradientRenderer = (typeof MeshGradientRenderer !== 'undefined') ? MeshGradientRenderer : null;

            // å…œåº•ï¼šå¦‚æœåŸè„šæœ¬ DEFAULT_IMAGE_URL å­˜åœ¨ï¼Œåˆ™åŒæ­¥
            try {
                if (typeof DEFAULT_IMAGE_URL !== 'undefined') this.DEFAULT_IMAGE_URL = DEFAULT_IMAGE_URL;
            } catch (_) {}
        }

        async init(container) {
            console.log("[MeshèƒŒæ™¯] åˆå§‹åŒ–å¼€å§‹...");
            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'MeshèƒŒæ™¯ï¼šåˆå§‹åŒ–å¼€å§‹...');
            const host = document.getElementById('bgHost');
            if (host) host.style.display = 'block';

            // åˆ›å»ºå›¾å±‚ä¸ canvas
            this.layerEl = document.createElement('div');
            this.layerEl.className = 'bg-layer';
            this.layerEl.style.position = 'absolute';
            this.layerEl.style.inset = '0';

            this.canvas = document.createElement('canvas');
            // ä¸ºäº†å°½é‡è´´è¿‘åŸæ–‡ä»¶ï¼Œè¿™é‡Œä¿ç•™ id="canvas"
            this.canvas.id = 'canvas';
            this.canvas.style.width = '100%';
            this.canvas.style.height = '100%';
            this.layerEl.appendChild(this.canvas);

            container.appendChild(this.layerEl);

            if (!this._MeshGradientRenderer) throw new Error('MeshGradientRenderer æœªå°±ç»ª');

            this.renderer = new this._MeshGradientRenderer(this.canvas);
            // åŸæ–‡ä»¶åˆå§‹åŒ–é€»è¾‘
            try { this.renderer.createFallbackTexture(); } catch (_) {}

            const firstUrl = window.__bgManager?.lastAlbumUrl || this.DEFAULT_IMAGE_URL;
            this.lastImageSource = firstUrl;
            try { await this.renderer.loadImage(firstUrl); } catch (e) {}

            return this.getControlsHTML();
        }

        destroy() {
            console.log("[MeshèƒŒæ™¯] æ¸…ç†èµ„æº...");
            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'MeshèƒŒæ™¯ï¼šæ¸…ç†èµ„æº...');
            try { if (this._controlsAbort) this._controlsAbort.abort(); } catch (_) {}

            try { if (this.renderer && typeof this.renderer.destroy === 'function') this.renderer.destroy(); } catch (e) {
                console.warn("[MeshèƒŒæ™¯] renderer.destroy å¤±è´¥:", e);
            }
            this.renderer = null;

            try {
                if (this.layerEl && this.layerEl.parentNode) this.layerEl.parentNode.removeChild(this.layerEl);
            } catch (_) {}
            this.layerEl = null;
            this.canvas = null;
            this.lastImageSource = null;
        }

        getControlsHTML() {
            // åŸå§‹æ§åˆ¶é¡¹å®Œæ•´ä¿ç•™ï¼šæ–‡ä»¶/URLã€æš‚åœã€å¯¹æ¯”åº¦/é¥±å’Œåº¦/äº®åº¦/æ¨¡ç³Š/é€Ÿåº¦/ç»†åˆ†/éšæœºé¢„è®¾
            return `
                <div class="control-group-title">Mesh æ¸å˜èƒŒæ™¯</div>

                <div class="bg-ctrl-row">
                    <label class="bg-file-btn">
                        é€‰æ‹©æ–‡ä»¶
                        <input type="file" id="fileInput" accept="image/*" style="display:none">
                    </label>
                    <button id="pauseBtn">æš‚åœ</button>
                </div>

                <div class="bg-file-name" id="fileName">ç‚¹å‡»é€‰æ‹©å›¾ç‰‡æˆ–è¾“å…¥URL</div>

                <div class="bg-ctrl-row" style="width:100%">
                    <input type="text" id="urlInput" placeholder="è¾“å…¥å›¾ç‰‡ URLâ€¦">
                    <button id="loadUrlBtn">åŠ è½½URLå›¾ç‰‡</button>
                </div>

                <div class="bg-sep"></div>

                <div class="bg-ctrl-row">
                    <label>å¯¹æ¯”åº¦</label>
                    <input type="range" id="contrast" min="0" max="200" value="40">
                </div>

                <div class="bg-ctrl-row">
                    <label>é¥±å’Œåº¦</label>
                    <input type="range" id="saturation" min="0" max="500" value="300">
                </div>

                <div class="bg-ctrl-row">
                    <label>äº®åº¦</label>
                    <input type="range" id="brightness" min="0" max="200" value="75">
                </div>

                <div class="bg-ctrl-row">
                    <label>æ¨¡ç³Š</label>
                    <input type="range" id="blur" min="0" max="10" value="2">
                </div>

                <div class="bg-ctrl-row">
                    <label>æ—‹è½¬é€Ÿåº¦</label>
                    <input type="range" id="speed" min="0" max="200" value="100">
                </div>

                <div class="bg-ctrl-row">
                    <label>ç»†åˆ†çº§åˆ«</label>
                    <input type="range" id="subdivisions" min="5" max="30" value="15">
                </div>

                <div class="bg-ctrl-row" style="width:100%">
                    <button id="randomPreset" style="width:100%">éšæœºç½‘æ ¼é¢„è®¾</button>
                </div>

                <div class="bg-hint" style="margin-top:10px;">
                    æç¤ºï¼šæ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶/URL åï¼Œå°†è‡ªåŠ¨å…³é—­â€œè·Ÿéšä¸“è¾‘å°é¢â€ï¼Œä»¥ä¿ç•™ä½ çš„è‡ªå®šä¹‰å›¾ç‰‡ã€‚
                </div>
            `;
        }

        bindControls(rootEl, { onUserOverride } = {}) {
            if (!rootEl || !this.renderer) return;

            this._controlsAbort = new AbortController();
            const sig = { signal: this._controlsAbort.signal };
            const $ = (id) => rootEl.querySelector(`#${id}`);

            const fileInput = $('fileInput');
            const fileName = $('fileName');
            const urlInput = $('urlInput');
            const loadUrlBtn = $('loadUrlBtn');
            const pauseBtn = $('pauseBtn');

            const contrast = $('contrast');
            const saturation = $('saturation');
            const brightness = $('brightness');
            const blur = $('blur');
            const speed = $('speed');
            const subdivisions = $('subdivisions');
            const randomPreset = $('randomPreset');

            // è®°å½•å½“å‰å›¾ç‰‡æºï¼Œä¾›æ»¤é•œè°ƒå‚åé‡è½½
            const reloadImage = async () => {
                if (this.lastImageSource) {
                    try { await this.renderer.loadImage(this.lastImageSource); } catch (_) {}
                }
            };

            if (fileInput) fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    if (fileName) fileName.textContent = file.name;
                    this.lastImageSource = file;
                    try { await this.renderer.loadImage(file); } catch (_) {}
                    if (typeof onUserOverride === 'function') onUserOverride();
                }
            }, sig);

            if (loadUrlBtn) loadUrlBtn.addEventListener('click', async () => {
                const url = (urlInput?.value || '').trim();
                if (url) {
                    if (fileName) fileName.textContent = url.split('/').pop();
                    this.lastImageSource = url;
                    try { await this.renderer.loadImage(url); } catch (_) {}
                    if (typeof onUserOverride === 'function') onUserOverride();
                }
            }, sig);

            // æš‚åœ/æ’­æ”¾
            let isPaused = false;
            if (pauseBtn) pauseBtn.addEventListener('click', () => {
                isPaused = !isPaused;
                if (isPaused) { this.renderer.pause(); pauseBtn.textContent = 'æ’­æ”¾'; }
                else { this.renderer.resume(); pauseBtn.textContent = 'æš‚åœ'; }
            }, sig);

            if (contrast) contrast.addEventListener('input', async (e) => {
                this.renderer.imageSettings.contrast = e.target.value / 100;
                await reloadImage();
            }, sig);

            if (saturation) saturation.addEventListener('input', async (e) => {
                this.renderer.imageSettings.saturation = e.target.value / 100;
                await reloadImage();
            }, sig);

            if (brightness) brightness.addEventListener('input', async (e) => {
                this.renderer.imageSettings.brightness = e.target.value / 100;
                await reloadImage();
            }, sig);

            if (blur) blur.addEventListener('input', async (e) => {
                this.renderer.imageSettings.blur = parseInt(e.target.value);
                await reloadImage();
            }, sig);

            if (speed) speed.addEventListener('input', (e) => {
                this.renderer.speed = e.target.value / 100;
            }, sig);

            if (subdivisions) subdivisions.addEventListener('input', (e) => {
                this.renderer.setSubdivisions(parseInt(e.target.value));
            }, sig);

            if (randomPreset) randomPreset.addEventListener('click', () => {
                this.renderer.randomizePreset();
            }, sig);
        }

        async updateFromAlbum(url) {
            if (!this.renderer || !url) return;
            this.lastImageSource = url;
            try { await this.renderer.loadImage(url); } catch (e) {}

            const fileNameEl = document.getElementById('fileName');
            if (fileNameEl) fileNameEl.textContent = `[ä¸“è¾‘å°é¢] ${
                (url.split('/').pop() || url).slice(0, 80)
            }`;
        }
    }


    // =========================================================
    // === èƒŒæ™¯ç®¡ç†å™¨ ===
    // =========================================================
    class BackgroundManager {
        constructor({ hostEl, controlsMountEl, badgeEl, followAlbumEl }) {
            console.log("[èƒŒæ™¯ç®¡ç†å™¨] åˆå§‹åŒ–...");
            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'èƒŒæ™¯ç®¡ç†å™¨åˆå§‹åŒ–...');
            this.currentBg = null;
            this.bgTypes = ['default', 'solid', 'pixi', 'mesh'];
            this.currentIndex = 0;

            // é¡µé¢ä¸å¯è§æ—¶æš‚åœèƒŒæ™¯æ¸²æŸ“ï¼Œé™ä½é•¿ä»»åŠ¡/æ‰å¸§é£é™©
            this._onVisibility = () => {
                try {
                    const bg = this.currentBg;
                    if (document.hidden) {
                        window.__GRADIENT_PAUSED = true;
                        if (bg && typeof bg.pause === 'function') bg.pause();
                    } else {
                        window.__GRADIENT_PAUSED = false;
                        if (bg && typeof bg.resume === 'function') bg.resume();
                    }
                } catch (_) {}
            };
            try { document.addEventListener('visibilitychange', this._onVisibility); } catch (_) {}


            this.hostEl = hostEl;
            this.controlsMountEl = controlsMountEl;
            this.badgeEl = badgeEl;
            this.followAlbumEl = followAlbumEl;

            this.lastAlbumUrl = null;

            // â˜… äº’æ–¥åˆ‡æ¢é”ï¼šé˜²æ­¢é¢‘ç¹åˆ‡æ¢å¯¼è‡´èµ„æºç«äº‰/é‡å¤åˆå§‹åŒ–
            this.isSwitching = false;
            this._switchToken = 0;


            this.activeAnimations = new Set(); // è·Ÿè¸ªåŠ¨ç”»ID
            // â˜… èƒŒæ™¯å®ä¾‹å¼•ç”¨ï¼ˆä¾¿äºç»Ÿä¸€é”€æ¯ï¼Œé¿å…èµ„æºæ³„æ¼ï¼‰
            this.pixiBg = null;
            this.meshBg = null;

            // é»˜è®¤èƒŒæ™¯ç³»ç»Ÿ
            this.defaultSystem = new DefaultBackgroundSystem();
        }

        getCurrentType() {
            return this.bgTypes[this.currentIndex] || 'default';
        }

        _setBadge(type) {
            if (!this.badgeEl) return;
            const map = { default: 'é»˜è®¤', pixi: 'Pixi', mesh: 'Mesh' };
            this.badgeEl.textContent = map[type] || type;
        }

        _clearControlsUI() {
            if (!this.controlsMountEl) return;
            this.controlsMountEl.innerHTML = `
                <div class="bg-hint">
                    å½“å‰èƒŒæ™¯æ— é¢å¤–æ§åˆ¶é¡¹ã€‚<br>
                    æç¤ºï¼šåˆ‡æ¢åˆ° Pixi / Mesh èƒŒæ™¯åï¼Œè¿™é‡Œä¼šå‡ºç°å¯¹åº”çš„å®Œæ•´æ§åˆ¶é¢æ¿ã€‚
                </div>
            `;
        }

        _mountControls(bg) {
            if (!this.controlsMountEl) return;

            if (!bg || typeof bg.getControlsHTML !== 'function') {
                this._clearControlsUI();
                return;
            }

            const html = bg.getControlsHTML();
            if (!html) {
                this._clearControlsUI();
                return;
            }

            this.controlsMountEl.innerHTML = html;

            // ç»‘å®šäº‹ä»¶ & æ‰‹åŠ¨è¦†ç›–é€»è¾‘
            const onUserOverride = () => {
                // ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶/URLï¼Œåˆ™å…³é—­è·Ÿéšå°é¢
                const followEl = this.followAlbumEl;
                if (followEl && followEl.checked) {
                    followEl.checked = false;
                    console.log("[èƒŒæ™¯ç³»ç»Ÿ] æ£€æµ‹åˆ°ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹©å›¾ç‰‡ï¼Œå·²è‡ªåŠ¨å…³é—­ï¼šè·Ÿéšä¸“è¾‘å°é¢");
                    dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹©å›¾ç‰‡ï¼šè‡ªåŠ¨å…³é—­â€œè·Ÿéšä¸“è¾‘å°é¢â€');
                }
            };

            if (typeof bg.bindControls === 'function') {
                bg.bindControls(this.controlsMountEl, { onUserOverride });
            }
        }

        async switchBackground(type) {
            // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.group ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
            // â˜… å¼ºåˆ¶åœæ­¢é»˜è®¤æ¸å˜ RAFï¼ˆé˜²æ­¢ animationId æ®‹ç•™å¯¼è‡´å¤šä¸ªç³»ç»ŸåŒæ—¶è·‘ï¼‰
            try {
                if (typeof animationId !== 'undefined' && animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            } catch (_) {}

            // â˜… åœæ­¢å¹¶æ¸…ç©º BackgroundManager è®°å½•çš„åŠ¨ç”»ï¼ˆè‹¥æœ‰ï¼‰
            try {
                if (this.activeAnimations && this.activeAnimations.size) {
                    for (const id of this.activeAnimations) {
                        try { cancelAnimationFrame(id); } catch (_) {}
                    }
                    this.activeAnimations.clear();
                    console.log('[èƒŒæ™¯ç³»ç»Ÿ] å·²åœæ­¢å¹¶æ¸…ç©ºè®°å½•çš„åŠ¨ç”»');
                }
            } catch (_) {}

            // â˜… é˜²å¾¡å¼æ¸…ç†ï¼šè‹¥å†å² WebGL èƒŒæ™¯å®ä¾‹æ„å¤–æ®‹ç•™ï¼ˆé currentBgï¼‰ï¼Œä¹Ÿä¸€å¹¶é”€æ¯ï¼Œé¿å…ä¸Šä¸‹æ–‡ç«äº‰
            try {
                if (this.pixiBg && this.pixiBg !== this.currentBg && typeof this.pixiBg.destroy === 'function') {
                    this.pixiBg.destroy();
                }
            } catch (_) {}
            try {
                if (this.meshBg && this.meshBg !== this.currentBg && typeof this.meshBg.destroy === 'function') {
                    this.meshBg.destroy();
                }
            } catch (_) {}
            if (this.pixiBg && this.pixiBg !== this.currentBg) this.pixiBg = null;
            if (this.meshBg && this.meshBg !== this.currentBg) this.meshBg = null;
            if (this.isSwitching) {
                console.log("[èƒŒæ™¯ç³»ç»Ÿ] æ­£åœ¨åˆ‡æ¢ä¸­ï¼Œè·³è¿‡é‡å¤è¯·æ±‚");
                return;
            }
            this.isSwitching = true;
            const switchToken = ++this._switchToken;

            try {
            try { console.group(`[èƒŒæ™¯åˆ‡æ¢] åˆ‡æ¢åˆ° ${type}`); } catch (e) { try { console.log(`[èƒŒæ™¯åˆ‡æ¢] åˆ‡æ¢åˆ° ${type}`); } catch (_) {} }
            console.log("å½“å‰èƒŒæ™¯:", this.currentBg?.constructor?.name || 'æ— ');
            console.log("å¼€å§‹æ¸…ç†æ—§èµ„æº...");

            // æ¸…ç†æ—§èƒŒæ™¯
            try {
                if (this.currentBg && typeof this.currentBg.destroy === 'function') {
                    this.currentBg.destroy();
                }
            } catch (e) {
                console.warn("[èƒŒæ™¯åˆ‡æ¢] æ¸…ç†æ—§èƒŒæ™¯å¼‚å¸¸:", e);
                dcWarn('èƒŒæ™¯ç³»ç»Ÿ', `æ¸…ç†æ—§èƒŒæ™¯å¼‚å¸¸ï¼š${e.message || e}`);
            }

            // æ¸…ç©ºå®¿ä¸»å±‚
            try {
                if (this.hostEl) this.hostEl.innerHTML = '';
            } catch (_) {}

            console.log("æ—§èµ„æºæ¸…ç†å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–æ–°èƒŒæ™¯...");

            // æ ¹æ®ç±»å‹åˆå§‹åŒ–æ–°èƒŒæ™¯
            let newBg = null;
            try {
                if (type === 'default') {
                    newBg = this.defaultSystem;
                    newBg.init();
                    // é»˜è®¤èƒŒæ™¯æ— ä¸“ç”¨æ§åˆ¶
                    this._clearControlsUI();
                } else if (type === 'solid') {
                    // çº¯è‰²èƒŒæ™¯ï¼šå…³é—­æ‰€æœ‰åŠ¨æ€æ¸²æŸ“å±‚ï¼Œä»…ä¿ç•™å¡ç‰‡æœ¬èº«èƒŒæ™¯è‰²
                    this.defaultSystem.destroy();
                    const gc = document.getElementById('gradientCanvas');
                    if (gc && gc.style) gc.style.display = 'none';
                    if (this.hostEl && this.hostEl.style) this.hostEl.style.display = 'none';

                    // æ¸…ç©ºåŠ¨æ€èƒŒæ™¯å®ä¾‹å¼•ç”¨ï¼ˆé¿å…å ç”¨èµ„æºï¼‰
                    if (this.pixiBg) { try { this.pixiBg.destroy(); } catch (e) {} this.pixiBg = null; }
                    if (this.meshBg) { try { this.meshBg.destroy(); } catch (e) {} this.meshBg = null; }

                    this.currentBg = null;
                    this._clearControlsUI();
                } else if (type === 'pixi') {
                    // å…³é—­é»˜è®¤èƒŒæ™¯
                    this.defaultSystem.destroy();
                    document.getElementById('gradientCanvas')?.style && (document.getElementById('gradientCanvas').style.display = 'none');

                    newBg = new PixiBackgroundSystem();
                    await newBg.init(this.hostEl);
                    this.pixiBg = newBg;
                    this.meshBg = null;
                    this._mountControls(newBg);
                } else if (type === 'mesh') {
                    // å…³é—­é»˜è®¤èƒŒæ™¯
                    this.defaultSystem.destroy();
                    document.getElementById('gradientCanvas')?.style && (document.getElementById('gradientCanvas').style.display = 'none');

                    newBg = new MeshBackgroundSystem();
                    await newBg.init(this.hostEl);
                    this.meshBg = newBg;
                    this.pixiBg = null;
                    this._mountControls(newBg);
                } else {
                    console.warn("[èƒŒæ™¯åˆ‡æ¢] æœªçŸ¥èƒŒæ™¯ç±»å‹ï¼Œå›é€€ default:", type);
                    newBg = this.defaultSystem;
                    newBg.init();
                    this._clearControlsUI();
                }
            } catch (e) {
// Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.error ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
                try { console.error("[èƒŒæ™¯åˆ‡æ¢] æ–°èƒŒæ™¯åˆå§‹åŒ–å¤±è´¥ï¼Œå›é€€é»˜è®¤èƒŒæ™¯:", e); } catch (e) { try { console.log("[èƒŒæ™¯åˆ‡æ¢] æ–°èƒŒæ™¯åˆå§‹åŒ–å¤±è´¥ï¼Œå›é€€é»˜è®¤èƒŒæ™¯:", e); } catch (_) {} }
                dcError('èƒŒæ™¯ç³»ç»Ÿ', `æ–°èƒŒæ™¯åˆå§‹åŒ–å¤±è´¥ï¼š${e.message || e}ï¼Œå·²å›é€€é»˜è®¤èƒŒæ™¯`);
                newBg = this.defaultSystem;
                try { newBg.init(); } catch (_) {}
                this._clearControlsUI();
                type = 'default';
            }

            this.currentBg = newBg;
            this._setBadge(type);

            // è‹¥å¼€å¯è·Ÿéšå°é¢ï¼Œä¸”æœ‰ lastAlbumUrlï¼Œåˆ™ç«‹å³åˆ·æ–°èƒŒæ™¯
            try {
                const follow = !!this.followAlbumEl?.checked;
                if (follow && this.lastAlbumUrl && this.currentBg && typeof this.currentBg.updateFromAlbum === 'function') {
                    await this.currentBg.updateFromAlbum(this.lastAlbumUrl);
                }
            } catch (_) {}

            console.log("æ–°èƒŒæ™¯åˆå§‹åŒ–å®Œæˆ");
            // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.groupEnd ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
            try { console.groupEnd(); } catch (e) { try { console.log('[èƒŒæ™¯åˆ‡æ¢] groupEnd'); } catch (_) {} }
            } finally {
                if (this._switchToken === switchToken) this.isSwitching = false;
            }
        }

        async cycle() {
            this.currentIndex = (this.currentIndex + 1) % this.bgTypes.length;
            const type = this.bgTypes[this.currentIndex];
            await this.switchBackground(type);
        }

        async handleAlbumArtChanged(url) {
            if (!url) return;
            this.lastAlbumUrl = url;

            const follow = !!this.followAlbumEl?.checked;
            if (!follow) return;

            if (this.currentBg && typeof this.currentBg.updateFromAlbum === 'function') {
                try {
                    await this.currentBg.updateFromAlbum(url);
                } catch (e) {
                    console.warn("[èƒŒæ™¯ç³»ç»Ÿ] updateFromAlbum å¤±è´¥:", e);
                }
            }
        }
    }

    // =========================================================
    // æ§åˆ¶é¢æ¿æ™ºèƒ½é€‚é…ï¼šè¿è¡Œæ—¶åˆ†æç°æœ‰å¸ƒå±€ç©ºé—´ï¼ˆæŒ‰éœ€æ±‚å¿…é¡»åˆ†æï¼‰
    // =========================================================
    function analyzeExistingLayout() {
        try {
            const container = document.querySelector('.container');
            const searchSection = document.querySelector('.search-section');
            const controls = document.querySelector('.controls');

            const report = {
                containerWidth: container ? container.clientWidth : null,
                searchSectionWidth: searchSection ? searchSection.clientWidth : null,
                controlsWidth: controls ? controls.clientWidth : null,
                viewport: { w: window.innerWidth, h: window.innerHeight }
            };

            console.log("[å¸ƒå±€åˆ†æ] ç°æœ‰æ§åˆ¶é¢æ¿ç©ºé—´è¯„ä¼°:", report);

            // æ–¹æ¡ˆé€‰æ‹©ï¼šæŠ˜å å¼æ§åˆ¶é¢æ¿ï¼ˆæœ¬å®ç°ï¼‰
            console.log("[å¸ƒå±€æ–¹æ¡ˆ] å·²å¯ç”¨ï¼šæ–¹æ¡ˆAï¼ˆæŠ˜å å¼æ§åˆ¶é¢æ¿ï¼‰ï¼Œé¿å…ç›´æ¥å †å æ§ä»¶ã€‚");
        } catch (e) {
            console.warn("[å¸ƒå±€åˆ†æ] å¤±è´¥:", e);
        }
    }

    // =========================================================
    // èƒŒæ™¯é¢æ¿ï¼šæ‹–æ‹½ï¼ˆå¯é€‰å¢å¼ºï¼Œæ»¡è¶³â€œæ™ºèƒ½é€‚é…/å¯ç”¨ç©ºé—´â€éœ€æ±‚ï¼‰
    // =========================================================
    function enablePanelDrag(panelEl, handleEl) {
        if (!panelEl || !handleEl) return;

        let dragging = false;
        let startX = 0, startY = 0;
        let startLeft = 0, startBottom = 0;

        const onDown = (e) => {
            // ä»…é¼ æ ‡/è§¦æ§ä¸»é”®
            if (e.type === 'mousedown' && e.button !== 0) return;

            dragging = true;
            const rect = panelEl.getBoundingClientRect();
            startLeft = rect.left;
            startBottom = window.innerHeight - rect.bottom;

            const pt = e.touches ? e.touches[0] : e;
            startX = pt.clientX;
            startY = pt.clientY;

            e.preventDefault();
        };

        const onMove = (e) => {
            if (!dragging) return;
            const pt = e.touches ? e.touches[0] : e;
            const dx = pt.clientX - startX;
            const dy = pt.clientY - startY;

            // left å¢åŠ  dxï¼Œbottom å‡å°‘ dyï¼ˆå› ä¸ºå‘ä¸‹ dy>0ï¼‰
            let newLeft = startLeft + dx;
            let newBottom = startBottom - dy;

            // è¾¹ç•Œé™åˆ¶
            const maxLeft = window.innerWidth - panelEl.offsetWidth - 8;
            const maxBottom = window.innerHeight - panelEl.offsetHeight - 8;
            newLeft = Math.max(8, Math.min(maxLeft, newLeft));
            newBottom = Math.max(8, Math.min(maxBottom, newBottom));

            panelEl.style.left = newLeft + 'px';
            panelEl.style.bottom = newBottom + 'px';
        };

        const onUp = () => { dragging = false; };

        handleEl.addEventListener('mousedown', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);

        handleEl.addEventListener('touchstart', onDown, { passive: false });
        window.addEventListener('touchmove', onMove, { passive: false });
        window.addEventListener('touchend', onUp);
        window.addEventListener('touchcancel', onUp);
    }

    // =========================================================
    // æµ‹è¯•æ¸…å•ï¼ˆæ§åˆ¶å°è¾“å‡ºï¼‰
    // =========================================================
    async function runIntegrationTests(bgManager) {
        const results = [];

        const ok = (name, pass, detail='') => {
            results.push({ æµ‹è¯•é¡¹: name, ç»“æœ: pass ? 'âœ…é€šè¿‡' : 'âŒå¤±è´¥', è¯´æ˜: detail });
        };

        // åŸºç¡€åŠŸèƒ½æµ‹è¯•ï¼ˆå°½é‡ä¸å¹²æ‰°åŸæ’­æ”¾å™¨ï¼‰
        ok('1. æ’­æ”¾/æš‚åœ/éŸ³é‡æ§åˆ¶å…ƒç´ å­˜åœ¨', !!document.getElementById('audioPlayer') && !!document.getElementById('playBtn') && !!document.getElementById('volumeSlider'));
        ok('2. å–è‰²å™¨/å°é¢å…ƒç´ å­˜åœ¨', !!document.getElementById('albumArt'));
        ok('3. KMeansæŒ‰é’®å­˜åœ¨', !!document.getElementById('algoToggleBtn') || !!document.querySelector('#algoToggleBtn'));
        ok('4. APIé€‰æ‹©å™¨å­˜åœ¨', !!document.getElementById('apiSelect'));

        // èƒŒæ™¯åˆ‡æ¢æµ‹è¯•ï¼šåšä¸€æ¬¡å¿«é€Ÿåˆ‡æ¢ï¼ˆä»…éªŒè¯æ— å¼‚å¸¸ï¼‰
        try {
            await bgManager.switchBackground('pixi');
            ok('5. PixièƒŒæ™¯åˆå§‹åŒ–', true);
        } catch (e) {
            ok('5. PixièƒŒæ™¯åˆå§‹åŒ–', false, e.message || String(e));
        }

        try {
            await bgManager.switchBackground('mesh');
            ok('6. MeshèƒŒæ™¯åˆå§‹åŒ–', true);
        } catch (e) {
            ok('6. MeshèƒŒæ™¯åˆå§‹åŒ–', false, e.message || String(e));
        }

        try {
            await bgManager.switchBackground('default');
            ok('7. åˆ‡å›é»˜è®¤èƒŒæ™¯', true);
        } catch (e) {
            ok('7. åˆ‡å›é»˜è®¤èƒŒæ™¯', false, e.message || String(e));
        }

        // ç®€æ˜“å†…å­˜é‡Šæ”¾æ£€æµ‹ï¼šæ— æ³•åœ¨æ­¤å¤„çœŸæ­£æ£€æµ‹æ³„æ¼ï¼Œåªèƒ½æ£€æŸ¥ DOM æ˜¯å¦æ¸…ç©º
        ok('8. èƒŒæ™¯å®¿ä¸»DOMæ¸…ç†', (document.getElementById('bgHost')?.querySelectorAll('canvas').length || 0) === 0, 'default æ¨¡å¼ä¸‹ bgHost ä¸åº”æ®‹ç•™ canvas');

        // æ§åˆ¶é¢æ¿æµ‹è¯•
        ok('9. èƒŒæ™¯é¢æ¿æŒ‰é’®å­˜åœ¨', !!document.getElementById('bgToggleBtn'));
        ok('10. èƒŒæ™¯é¢æ¿ç»“æ„å­˜åœ¨', !!document.getElementById('bgPanel') && !!document.getElementById('bgSwitchBtn'));
        ok('11. å“åº”å¼ï¼ˆæ— æ³•å¼ºæµ‹ï¼‰', true, 'è¯·åœ¨ä¸åŒçª—å£å°ºå¯¸ä¸‹è§‚å¯Ÿå¸ƒå±€æ˜¯å¦é‡å ');

        // è°ƒè¯•ç³»ç»Ÿæµ‹è¯•
        ok('12. æ§åˆ¶å°å¯åŠ¨æ—¥å¿—å·²è¾“å‡º', true, 'è¯·æ£€æŸ¥æ§åˆ¶å°é¡¶éƒ¨æ˜¯å¦å‡ºç°â€œéŸ³ä¹æ’­æ”¾å™¨èƒŒæ™¯ç³»ç»Ÿå¯åŠ¨â€');
        ok('13. å…¨å±€é”™è¯¯æ•è·å·²æ³¨å†Œ', true, 'å·²é€šè¿‡ window.addEventListener(error/unhandledrejection) æ³¨å†Œ');
        ok('14. reportPlayerStatus å¯è°ƒç”¨', typeof window.reportPlayerStatus === 'function');

        // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.group ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
        try { console.group("=== é›†æˆæµ‹è¯•æŠ¥å‘Šï¼ˆå¤šèƒŒæ™¯ç³»ç»Ÿï¼‰==="); } catch (e) { try { console.log("=== é›†æˆæµ‹è¯•æŠ¥å‘Šï¼ˆå¤šèƒŒæ™¯ç³»ç»Ÿï¼‰==="); } catch (_) {} }
        console.table(results);
        // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.groupEnd ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
        try { console.groupEnd(); } catch (e) { try { console.log('=== é›†æˆæµ‹è¯•æŠ¥å‘Šç»“æŸ ==='); } catch (_) {} }

        dcInfo('æµ‹è¯•', 'å·²è¾“å‡ºå¤šèƒŒæ™¯ç³»ç»Ÿé›†æˆæµ‹è¯•æŠ¥å‘Šï¼ˆæ§åˆ¶å°ï¼‰');
    }

    // =========================================================
    // åˆå§‹åŒ–å…¥å£
    // =========================================================
    function initBackgroundSystem() {
        analyzeExistingLayout();

        const bgHost = document.getElementById('bgHost');
        const bgPanel = document.getElementById('bgPanel');
        const bgToggleBtn = document.getElementById('bgToggleBtn');
        const bgSwitchBtn = document.getElementById('bgSwitchBtn');
        const bgControlsMount = document.getElementById('bgControlsMount');
        const bgStatusBadge = document.getElementById('bgStatusBadge');
        const bgFollowAlbum = document.getElementById('bgFollowAlbum');
        const bgPanelCloseBtn = document.getElementById('bgPanelCloseBtn');
        const bgPanelMinBtn = document.getElementById('bgPanelMinBtn');
        const bgPanelHeader = document.getElementById('bgPanelHeader');

        if (!bgHost || !bgPanel || !bgToggleBtn || !bgSwitchBtn || !bgControlsMount || !bgStatusBadge || !bgFollowAlbum) {
            console.warn("[èƒŒæ™¯ç³»ç»Ÿ] å¿…è¦DOMç¼ºå¤±ï¼Œåˆå§‹åŒ–ä¸­æ­¢ã€‚");
            return;
        }

        // åˆ›å»ºèƒŒæ™¯ç®¡ç†å™¨
        const bgManager = new BackgroundManager({
            hostEl: bgHost,
            controlsMountEl: bgControlsMount,
            badgeEl: bgStatusBadge,
            followAlbumEl: bgFollowAlbum
        });
        window.__bgManager = bgManager;
        window.PixiBackgroundSystem = PixiBackgroundSystem;
        window.MeshBackgroundSystem = MeshBackgroundSystem;
        window.BackgroundManager = BackgroundManager;

        // é»˜è®¤èƒŒæ™¯ä½œä¸ºåˆå§‹çŠ¶æ€
        bgManager.switchBackground('default');

        // é¢æ¿å¼€å…³
        const openPanel = () => { bgPanel.classList.add('show'); };
        const closePanel = () => { bgPanel.classList.remove('show'); };
        const togglePanel = () => { bgPanel.classList.toggle('show'); };

        bgToggleBtn.addEventListener('click', togglePanel);
        if (bgPanelCloseBtn) bgPanelCloseBtn.addEventListener('click', closePanel);
        if (bgPanelMinBtn) bgPanelMinBtn.addEventListener('click', closePanel);

        // Fix: iOS è§¦æ§/é¼ æ ‡äº‹ä»¶åŒç»‘å®šï¼ˆtouchstart/touchend + mousedown/mouseup + clickï¼‰
        const bindBgBtn = (el, handler) => {
            if (!el || typeof handler !== 'function') return;
            let lastTouch = 0;

            el.addEventListener('touchstart', () => {}, { passive: true });
            el.addEventListener('touchend', (e) => {
                lastTouch = Date.now();
                try { if (e && e.cancelable) e.preventDefault(); } catch (_) {}
                try { handler(e); } catch (_) {}
            }, { passive: false });

            el.addEventListener('mousedown', () => {}, { passive: true });
            el.addEventListener('mouseup', () => {}, { passive: true });

            // æŠ‘åˆ¶ touchend åçš„åˆæˆ clickï¼Œé¿å…åŒè§¦å‘
            el.addEventListener('click', (e) => {
                if (Date.now() - lastTouch < 800) {
                    try { e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation(); } catch (_) {}
                }
            }, true);

            try { el.dataset.compatBound = '1'; } catch (_) {}
        };

        bindBgBtn(bgToggleBtn, togglePanel);
        if (bgPanelCloseBtn) bindBgBtn(bgPanelCloseBtn, closePanel);
        if (bgPanelMinBtn) bindBgBtn(bgPanelMinBtn, closePanel);

        // åˆ‡æ¢èƒŒæ™¯
        const handleBgSwitch = async () => {
            try { await bgManager.cycle(); } catch (e) { console.warn('[èƒŒæ™¯ç³»ç»Ÿ] cycle å¤±è´¥:', e); }
        };
        bgSwitchBtn.addEventListener('click', handleBgSwitch);
        bindBgBtn(bgSwitchBtn, () => { handleBgSwitch(); });

        // æ‹–æ‹½
        enablePanelDrag(bgPanel, bgPanelHeader);

        // ç›‘å¬ä¸“è¾‘å°é¢å˜åŒ–ï¼šç¡®ä¿â€œåŠ è½½æ–°çš„ä¸“è¾‘å°é¢åï¼ŒåŠ¨æ€èƒŒæ™¯ç«‹å³æ›´æ–°â€
        const albumArtEl = document.getElementById('albumArt');
        if (albumArtEl) {
            let last = albumArtEl.src || '';
            if (last) bgManager.lastAlbumUrl = last;

            const mo = new MutationObserver(async (mutations) => {
                for (const m of mutations) {
                    if (m.type === 'attributes' && m.attributeName === 'src') {
                        const url = albumArtEl.src || '';
                        if (url && url !== last) {
                            last = url;
                            console.log("[èƒŒæ™¯ç³»ç»Ÿ] ä¾¦æµ‹åˆ°ä¸“è¾‘å°é¢æ›´æ–°ï¼Œæ¨é€åˆ°èƒŒæ™¯:", url);
                            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', `ä¾¦æµ‹åˆ°ä¸“è¾‘å°é¢æ›´æ–°ï¼š${url}`);
                            await bgManager.handleAlbumArtChanged(url);
                        }
                    }
                }
            });
            mo.observe(albumArtEl, { attributes: true, attributeFilter: ['src'] });
        } else {
            console.warn("[èƒŒæ™¯ç³»ç»Ÿ] æœªæ‰¾åˆ° albumArt å…ƒç´ ï¼Œæ— æ³•è‡ªåŠ¨è·Ÿéšå°é¢ã€‚");
        }

        // æä¾›å¿«æ·æ¥å£ï¼ˆä¾¿äºè°ƒè¯•ï¼‰
        window.switchBackground = async (type) => {
            const allowed = ['default','pixi','mesh'];
            if (!allowed.includes(type)) {
                console.warn("[switchBackground] ä¸æ”¯æŒçš„èƒŒæ™¯ç±»å‹:", type);
                return;
            }
            bgManager.currentIndex = allowed.indexOf(type);
            await bgManager.switchBackground(type);
            openPanel();
        };

        // è¾“å‡ºæµ‹è¯•æŠ¥å‘Šï¼ˆæŒ‰éœ€æ±‚å¿…é¡»å…ˆæµ‹è¯•ï¼‰
        runIntegrationTests(bgManager);
    }

    // ä½¿ç”¨ window.loadï¼Œç¡®ä¿åŸæ’­æ”¾å™¨ window.onload å·²æ‰§è¡Œä¸”ä¸è¢«è¦†ç›–
    window.addEventListener('load', () => {
        try {
            initBackgroundSystem();
        } catch (e) {
// Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.error ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
            try { console.error("[èƒŒæ™¯ç³»ç»Ÿ] åˆå§‹åŒ–å¼‚å¸¸:", e); } catch (e) { try { console.log("[èƒŒæ™¯ç³»ç»Ÿ] åˆå§‹åŒ–å¼‚å¸¸:", e); } catch (_) {} }
            dcError('èƒŒæ™¯ç³»ç»Ÿ', `åˆå§‹åŒ–å¼‚å¸¸ï¼š${e.message || e}`);
        }
    });
})();</script><script>
        document.addEventListener('DOMContentLoaded', () => {
            const card = document.getElementById('card');
            const updateBtn = document.getElementById('updateBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const albumCoverUpload = document.getElementById('albumCoverUpload');
            const albumCoverImg = document.getElementById('albumCoverImg');
            const extractColorBtn = document.getElementById('extractColorBtn');
            const extractedColors = document.getElementById('extractedColors');
            const fontSizeRange = document.getElementById('fontSizeRange');
            const fontSizeValue = document.getElementById('fontSizeValue');
            const lyricsDisplay = document.getElementById('lyricsDisplay');
            const lyricsInput = document.getElementById('lyricsInput');
            const fetchLyricsBtn = document.getElementById('fetchLyricsBtn');
            const fetchingIndicator = document.getElementById('fetchingIndicator');
            const formatLyricsBtn = document.getElementById('formatLyricsBtn');
            const lyricsSelector = document.getElementById('lyricsSelector');
            const lyricsLines = document.getElementById('lyricsLines');
            const selectAllBtn = document.getElementById('selectAllBtn');
            const deselectAllBtn = document.getElementById('deselectAllBtn');
            const splitCnPuncChk = document.getElementById('splitCnPuncChk');
            const maxLinesInput = document.getElementById('maxLinesInput');
            const autoPickBtn = document.getElementById('autoPickBtn');
            const applySelectionBtn = document.getElementById('applySelectionBtn');
            const logoUpload = document.getElementById('logoUpload');
            const logoImg = document.querySelector('.spotify-logo');
            const logoUrl = document.getElementById('logoUrl');
            const textLightBtn = document.getElementById('textLightBtn');
            const textDarkBtn = document.getElementById('textDarkBtn');
            const toggleLogoBtn = document.getElementById('toggleLogoBtn');

            // ========== å…¼å®¹ï¼šé›†æˆå¢å¼ºæ¨¡å—æ‰€éœ€çš„åˆ«åå¼•ç”¨ï¼ˆé˜²æ­¢æœªå®šä¹‰å˜é‡å¯¼è‡´ç™½å±ï¼‰ ==========
            const songTitleInput = document.getElementById('songTitle');
            const artistInput = document.getElementById('artist');
            const albumInput = document.getElementById('album');
            const albumCoverInput = document.getElementById('albumCover');
            const backgroundColorInput = document.getElementById('backgroundColor');
            const songTitleDisplay = document.getElementById('songTitleDisplay');
            const artistDisplay = document.getElementById('artistDisplay');
            const albumDisplay = document.getElementById('albumDisplay');
            const fetchIndicator = document.getElementById('fetchIndicator');

            // è®©æœç´¢ç»“æœç‚¹å‡»åå¯ç›´æ¥åº”ç”¨åˆ°å¡ç‰‡ï¼ˆæ— éœ€å…ˆç‚¹â€œè‡ªåŠ¨è·å–æ­Œè¯â€ï¼‰
            window.__lyricsCardApplyTrack = async (track) => {
                try {
                    const res = await fetchTrackLyricsAndCover(track);
                    if (!res) return;
                    applyFetchedDataToCard(res);
                } catch (e) {
                    console.warn('__lyricsCardApplyTrack failed:', e);
                }
            };

            // ä¸“è¾‘å°é¢æ¯”ä¾‹å’Œå¸ƒå±€è°ƒæ•´ç›¸å…³å˜é‡
            let albumAspectRatio = 1; // é»˜è®¤ä¸ºæ­£æ–¹å½¢
            let albumOriginalWidth = 0;
            let albumOriginalHeight = 0;

            // =========================================================
            // ç§»åŠ¨ç«¯å¡ç‰‡é€‚é…ï¼šè‡ªåŠ¨ç¼©æ”¾ï¼ˆ1200x2100 => æ ¹æ®å±å¹•å®½åº¦è‡ªåŠ¨è®¡ç®—ï¼‰
            // è¯´æ˜ï¼šuserScale ä¸ºç”¨æˆ·æ‰‹åŠ¨ç¼©æ”¾å€ç‡ï¼›scale ä¸ºæœ€ç»ˆåº”ç”¨å€ç‡ã€‚
            // =========================================================
            let userScale = 1;
            let scale = 1; // å®é™…åº”ç”¨ï¼šuserScale * autoScale

            function computeAutoScale() {
                const viewportW = Math.max(320, document.documentElement.clientWidth || window.innerWidth || 320);
                const padding = 40; // ç»™é¢„è§ˆåŒºåŸŸç•™å‡ºè¾¹è·ï¼Œé¿å…è´´è¾¹
                const fitW = Math.max(1, viewportW - padding);
                const auto = Math.min(1, fitW / 1200);
                return Math.max(0.05, (Number.isFinite(auto) ? auto : 0.3));
            }

            // æ¡Œé¢ç«¯é»˜è®¤ç¼©æ”¾ä¿æŒä¸åŸç‰ˆä¸€è‡´ï¼ˆ0.3ï¼‰ï¼›ç§»åŠ¨ç«¯ä»¥ autoScale é€‚é…å®Œæ•´æ˜¾ç¤º
            try {
                if (computeAutoScale() >= 1) userScale = 0.3;
            } catch (e) {}

            // åˆæ¬¡åº”ç”¨ç¼©æ”¾ï¼ˆå«ç§»åŠ¨ç«¯è‡ªåŠ¨ç¼©æ”¾ï¼‰
            applyScale();
            window.addEventListener('resize', () => { try { applyScale(); } catch (e) {} });
            window.addEventListener('orientationchange', () => { try { applyScale(); } catch (e) {} });
            
            // å­—ä½“å¤§å°è°ƒæ•´
            fontSizeRange.addEventListener('input', () => {
                const size = fontSizeRange.value;
                fontSizeValue.textContent = `${size}px`;
                lyricsDisplay.style.fontSize = `${size}px`;
                // è‡ªåŠ¨è°ƒæ•´è¡Œé«˜
                lyricsDisplay.style.lineHeight = `${Math.floor(size * 1.3)}px`;
            });
            
            // å¤„ç†æœ¬åœ°å›¾ç‰‡ä¸Šä¼ 
            albumCoverUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        albumCoverImg.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });

            // å¤„ç†æœ¬åœ°å¾½æ ‡ä¸Šä¼ 
            logoUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        logoImg.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });

            // ä»å›¾ç‰‡æå–é¢œè‰²
            const colorThief = new ColorThief();
            
            extractColorBtn.addEventListener('click', () => {
                if (!albumCoverImg.complete) {
                    alert('è¯·ç­‰å¾…å›¾ç‰‡åŠ è½½å®Œæˆ');
                    return;
                }
                
                try {
                    // æå–ä¸»è‰²è°ƒ
                    const dominantColor = colorThief.getColor(albumCoverImg);
                    const rgbString = `rgb(${dominantColor[0]}, ${dominantColor[1]}, ${dominantColor[2]})`;
                    
                    // è½¬æ¢ä¸ºåå…­è¿›åˆ¶
                    const hexColor = rgbToHex(dominantColor[0], dominantColor[1], dominantColor[2]);
                    document.getElementById('backgroundColor').value = hexColor;
                    
                    // æå–è°ƒè‰²æ¿ï¼ˆå¢åŠ åˆ°16ç§é¢œè‰²ï¼Œä»¥è·å–æ›´å¤šæ ·æœ¬ï¼‰
                    const palette = colorThief.getPalette(albumCoverImg, 16);
                    
                    // æ˜¾ç¤ºæå–çš„é¢œè‰²
                    extractedColors.innerHTML = '';
                    
                    // è®¡ç®—æ¯ç§é¢œè‰²çš„å‡ºç°é¢‘ç‡ï¼ˆæ¨¡æ‹Ÿï¼‰
                    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™éœ€è¦å¯¹å›¾åƒåƒç´ è¿›è¡Œåˆ†æ
                    const colorFrequency = analyzePaletteFrequency(palette);
                    
                    // å…ˆæ·»åŠ ä¸»è‰²è°ƒ
                    addColorSwatch(hexColor, true);
                    
                    // æŒ‰é¢‘ç‡ä»é«˜åˆ°ä½æ·»åŠ å…¶ä»–é¢œè‰²
                    colorFrequency.forEach(colorObj => {
                        addColorSwatch(colorObj.hex);
                    });
                    
                    // æ›´æ–°å¡ç‰‡èƒŒæ™¯è‰²
                    card.style.backgroundColor = hexColor;
                    
                    // æ›´æ–°æ–‡æœ¬é¢œè‰²
                    if (isColorDark(hexColor)) {
                        lyricsDisplay.style.color = '#ffffff';
                        document.getElementById('songTitleDisplay').style.color = '#ffffff';
                        document.getElementById('artistDisplay').style.color = '#ffffff';
                        logoImg.style.filter = 'brightness(10)';
                    } else {
                        lyricsDisplay.style.color = '#000000';
                        document.getElementById('songTitleDisplay').style.color = '#000000';
                        document.getElementById('artistDisplay').style.color = '#000000';
                        logoImg.style.filter = 'brightness(0)';
                    }
                } catch (error) {
                    console.error('æå–é¢œè‰²å¤±è´¥:', error);
                    alert('æ— æ³•ä»å›¾ç‰‡ä¸­æå–é¢œè‰²ï¼Œè¯·ç¡®ä¿å›¾ç‰‡å·²æ­£ç¡®åŠ è½½');
                }
            });
            
            // æ·»åŠ é¢œè‰²æ ·ä¾‹åˆ°è°ƒè‰²æ¿
            function addColorSwatch(hexColor, isMain = false) {
                const swatch = document.createElement('div');
                swatch.style.width = '25px';
                swatch.style.height = '25px';
                swatch.style.backgroundColor = hexColor;
                swatch.style.margin = '0 2px';
                swatch.style.cursor = 'pointer';
                swatch.style.border = isMain ? '2px solid black' : '1px solid #ddd';
                swatch.style.borderRadius = '4px';
                swatch.title = hexColor;
                
                swatch.addEventListener('click', () => {
                    document.getElementById('backgroundColor').value = hexColor;
                    card.style.backgroundColor = hexColor;
                });
                
                extractedColors.appendChild(swatch);
            }
            
            // RGBè½¬åå…­è¿›åˆ¶
            function rgbToHex(r, g, b) {
                return '#' + [r, g, b].map(x => {
                    const hex = x.toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            }
            
            // åˆ¤æ–­é¢œè‰²æ˜¯å¦ä¸ºæ·±è‰²
            function isColorDark(hexColor) {
                // Convert hex to RGB
                const r = parseInt(hexColor.slice(1, 3), 16);
                const g = parseInt(hexColor.slice(3, 5), 16);
                const b = parseInt(hexColor.slice(5, 7), 16);
                
                // Calculate luminance (perceived brightness)
                // Formula: 0.299*R + 0.587*G + 0.114*B
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                
                // Return true if dark (luminance < 0.5)
                return luminance < 0.5;
            }
            /* =========================================================
               ä¸»é¢˜è‰² & åŠ¨æ€èƒŒæ™¯è”åŠ¨ & æ–‡æœ¬å¯è¯»æ€§ï¼ˆæ­Œè¯å¡ç‰‡é›†æˆå¢å¼ºï¼‰
            ========================================================= */

            function setThemeColor(hexColor) {
                if (!hexColor) return;
                try {
                    card.style.setProperty('--bg-theme-color', hexColor);
                    // é»˜è®¤ç»™ä¸€ç‚¹ç‚¹ tintï¼ˆå¯åœ¨éœ€è¦æ—¶è°ƒå¤§/è°ƒå°ï¼‰
                    card.style.setProperty('--bg-theme-strength', '0.10');
                } catch (e) {}
            }

            function createColorDataUrl(hex) {
                try {
                    const c = document.createElement('canvas');
                    c.width = 32;
                    c.height = 32;
                    const cctx = c.getContext('2d', { willReadFrequently: true });
                    cctx.fillStyle = hex;
                    cctx.fillRect(0, 0, c.width, c.height);
                    return c.toDataURL('image/png');
                } catch (e) {
                    return null;
                }
            }

            // UI é¢„è§ˆï¼šå…¼å®¹é’©å­ï¼ˆåŸé›†æˆç‰ˆä¸­ç”¨äºè”åŠ¨æ˜¾ç¤ºï¼Œè¿™é‡Œæä¾›å®‰å…¨å®ç°ï¼Œé¿å…æœªå®šä¹‰å¯¼è‡´å´©æºƒï¼‰
            function updateColorPreview(hex) {
                try {
                    // å¯æ‰©å±•ï¼šä¾‹å¦‚åœ¨ extractedColors å®¹å™¨ä¸­æ ‡è®°å½“å‰è‰²
                    if (!hex) return;
                    card.style.setProperty('--bg-theme-color', hex);
                } catch (e) {}
            }

            async function applyThemeColorToDynamicBackground(hex) {
                try {
                    const mgr = window.__bgManager;
                    if (!mgr) return;

                    const type = mgr.bgTypes && typeof mgr.currentIndex === 'number'
                      ? (mgr.bgTypes[mgr.currentIndex] || 'default')
                      : 'default';

                    if (type === 'solid') return;

                    const dataUrl = createColorDataUrl(hex);
                    if (!dataUrl) return;

                    // ä¼˜å…ˆè®©â€œå½“å‰èƒŒæ™¯ç³»ç»Ÿâ€åƒåˆ°ä¸»é¢˜è‰²
                    if (mgr.currentBg && typeof mgr.currentBg.updateFromAlbum === 'function') {
                        await mgr.currentBg.updateFromAlbum(dataUrl);
                    } else if (typeof window.updateGradientFromAlbum === 'function') {
                        // é»˜è®¤æ¸å˜ç³»ç»Ÿ
                        await window.updateGradientFromAlbum(dataUrl);
                    }
                } catch (e) {
                    console.warn('applyThemeColorToDynamicBackground failed:', e);
                }
            }

            function parseLrcToPlainText(lrcText) {
                if (!lrcText) return '';
                // ç§»é™¤æ—¶é—´æˆ³ä¸å…ƒä¿¡æ¯
                const lines = lrcText.split(/\r?\n/);
                const out = [];
                for (const raw of lines) {
                    const line = raw
                      .replace(/^\s*\[[0-9:.]+\]\s*/g, '')          // [00:12.34]
                      .replace(/^\s*\[(ar|ti|al|by|offset):.*?\]\s*/ig, '')
                      .replace(/^\s*\[[A-Za-z]+:.*?\]\s*/g, '')
                      .trim();
                    if (line) out.push(line);
                }
                return out.join('\n');
            }

            function hexToRgb(hex) {
                const h = (hex || '').replace('#','').trim();
                if (h.length === 3) {
                    const r = parseInt(h[0] + h[0], 16);
                    const g = parseInt(h[1] + h[1], 16);
                    const b = parseInt(h[2] + h[2], 16);
                    return { r, g, b };
                }
                if (h.length === 6) {
                    const r = parseInt(h.slice(0,2), 16);
                    const g = parseInt(h.slice(2,4), 16);
                    const b = parseInt(h.slice(4,6), 16);
                    return { r, g, b };
                }
                return { r: 0, g: 0, b: 0 };
            }

            function srgbToLinear(c) {
                const v = c / 255;
                return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
            }

            function relativeLuminance(rgb) {
                const r = srgbToLinear(rgb.r);
                const g = srgbToLinear(rgb.g);
                const b = srgbToLinear(rgb.b);
                return 0.2126 * r + 0.7152 * g + 0.0722 * b;
            }

            function contrastRatio(rgb1, rgb2) {
                const L1 = relativeLuminance(rgb1);
                const L2 = relativeLuminance(rgb2);
                const lighter = Math.max(L1, L2);
                const darker = Math.min(L1, L2);
                return (lighter + 0.05) / (darker + 0.05);
            }

            // è‡ªåŠ¨è·å–æ­Œè¯ï¼ˆçœŸå® APIï¼‰
            fetchLyricsBtn.addEventListener('click', async () => {
                const titleKeyword = songTitleInput.value.trim();
                const artistKeyword = artistInput.value.trim();
                if (!titleKeyword) {
                    alert('è¯·å…ˆè¾“å…¥æ­Œæ›²æ ‡é¢˜ï¼ˆå¯é€‰ï¼šæ­Œæ‰‹ï¼‰');
                    return;
                }

                const keyword = artistKeyword ? `${titleKeyword} ${artistKeyword}` : titleKeyword;
                const preferredSource = (sourceSelect && sourceSelect.value) ? sourceSelect.value : 'kuwo';

                fetchLyricsBtn.disabled = true;
                fetchIndicator.textContent = 'æ­£åœ¨é€šè¿‡ API æœç´¢...';
                fetchIndicator.classList.remove('hidden');

                try {
                    // è®© displaySearchResults ç‚¹å‡»åå¯ç›´æ¥åº”ç”¨åˆ°å¡ç‰‡
                    window.__lyricsCardApplyTrack = async (track) => {
                        const res = await fetchTrackLyricsAndCover(track);
                        if (!res) return;
                        applyFetchedDataToCard(res);
                    };

                    const apisToTry = ['gdstudio', 'tunehub'];
                    const originalApi = apiSelect && apiSelect.value ? apiSelect.value : 'gdstudio';

                    let bestResult = null;

                    for (const api of apisToTry) {
                        if (apiSelect) apiSelect.value = api;

                        await searchMusic(keyword, preferredSource);

                        const results = Array.isArray(searchResults) ? searchResults : [];
                        if (!results.length) continue;

                        // é»˜è®¤å–ç¬¬ä¸€ä¸ªç»“æœä½œä¸ºå€™é€‰
                        const track = results[0];

                        const res = await fetchTrackLyricsAndCover(track);
                        if (res && res.lyrics && res.lyrics.trim().length > 0) {
                            bestResult = res;
                            bestResult.apiUsed = api;
                            break;
                        }
                    }

                    if (!bestResult) {
                        throw new Error('æœªæ‰¾åˆ°å¯ç”¨æ­Œè¯æ•°æ®ã€‚å»ºè®®ï¼šæ›´æ¢å¹³å° Sourceã€å°è¯•æ›´ç²¾ç¡®çš„æ­Œæ›²å/æ­Œæ‰‹åã€‚');
                    }

                    applyFetchedDataToCard(bestResult);

                    fetchIndicator.textContent = `è·å–æˆåŠŸï¼ˆ${bestResult.apiUsed}ï¼‰`;
                    setTimeout(() => fetchIndicator.classList.add('hidden'), 1200);
                } catch (err) {
                    console.error(err);
                    fetchIndicator.textContent = 'è·å–å¤±è´¥';
                    setTimeout(() => fetchIndicator.classList.add('hidden'), 1500);
                    alert(`è·å–æ­Œè¯å¤±è´¥ï¼š${err.message || err}`);
                } finally {
                    fetchLyricsBtn.disabled = false;
                    // ä¸å¼ºåˆ¶è¿˜åŸ apiSelectï¼Œè®©ç”¨æˆ·çœ‹åˆ°å½“å‰ä½¿ç”¨çš„ API
                }
            });

            async function fetchTrackLyricsAndCover(track) {
                if (!track) return null;

                // ç»Ÿä¸€å­—æ®µ
                const api = track.api || (apiSelect && apiSelect.value) || 'gdstudio';
                const title = track.name || track.title || songTitleInput.value.trim();
                const artist = track.artist || track.singer || artistInput.value.trim();
                const album = track.album || track.al || track.album_name || track.albumName || '';
                const preferredSourceLocal = (sourceSelect && sourceSelect.value) ? sourceSelect.value : 'kuwo';

                // å°é¢ URL
                let coverUrl = '';
                try {
                    if (api === 'gdstudio') {
                        if (track.pic_id) {
                            try {
                                const source = track.source || preferredSourceLocal;
                                let size = '3000';
                                // JOOX ä¸æ”¯æŒ size å‚æ•°ï¼ˆä¸è°ƒè¯•ç‰ˆæœ¬ä¿æŒä¸€è‡´ï¼‰
                                if (String(source).toLowerCase() === 'joox') size = '';

                                const picParams = { types: 'pic', source, id: track.pic_id };
                                if (size) picParams.size = size;

                                // ä»…æ”¹åŠ¨ GDStudioï¼šå°é¢é€šè¿‡åŸAPI(types=pic)è·å–çœŸå® urlï¼ˆä¾‹å¦‚ Kuwo çš„ img2.kuwo.cn/.../3000/...ï¼‰
                                const picData = await apiRequest(picParams, 'gdstudio');
                                const url = picData && (picData.url || picData.pic || picData.data);

                                if (url) {
                                    coverUrl = url;
                                    if (debugConsole) debugConsole.success('ä¸“è¾‘å°é¢', `æˆåŠŸåŠ è½½ä¸“è¾‘å°é¢: ${coverUrl}`);
                                } else {
                                    if (debugConsole) debugConsole.warn('ä¸“è¾‘å°é¢', 'ä¸“è¾‘å°é¢è¯·æ±‚æˆåŠŸä½†è¿”å›æ•°æ®ä¸­æœªæ‰¾åˆ° url');
                                }
                            } catch (e) {
                                if (debugConsole) debugConsole.error('ä¸“è¾‘å°é¢', `è·å–ä¸“è¾‘å°é¢å¤±è´¥: ${e.message}`);
                            }
                        }
                    } else {
                        if (track.pic_url) {
                            coverUrl = track.pic_url;
                        } else if (track.pic_id) {
                            coverUrl = `/api.php?type=pic&source=${track.source}&id=${track.pic_id}`;
                        }
                    }
                } catch (e) {}

                // æ­Œè¯è·å–
                let lyrics = '';
                try {
                    if (api === 'tunehub') {
                        const lyricId = track.lyric_id || track.id;
                        const res = await apiRequest({ types: 'lyric', source: track.source || preferredSourceLocal, id: lyricId });
      return res;
                        const response = await fetch(url);
                        lyrics = await response.text();
                        lyrics = parseLrcToPlainText(lyrics);
                    } else {
                        const lyricId = track.lyric_id || track.id;
                        const lyricData = await apiRequest({ types: 'lyric', source: track.source, id: lyricId });
                        lyrics = lyricData && lyricData.lyric ? lyricData.lyric : '';
                        lyrics = parseLrcToPlainText(lyrics);
                    }
                } catch (e) {
                    console.warn('fetch lyrics failed:', e);
                }

                return { title, artist, album, coverUrl, lyrics };
            }

            function applyFetchedDataToCard(data) {
                if (!data) return;

                // æ¸…ç†ä¸Šä¼ çš„å°é¢æ–‡ä»¶ï¼Œç¡®ä¿ URL ç”Ÿæ•ˆ
                try { albumCoverUpload.value = ''; } catch (e) {}

                if (data.title) songTitleInput.value = data.title;
                if (data.artist) artistInput.value = data.artist;
                if (data.album && albumInput) albumInput.value = data.album;
                if (data.lyrics) lyricsInput.value = data.lyrics;

                if (data.coverUrl) {
                    albumCoverInput.value = data.coverUrl;
                    // æ ‡è®°ï¼šå°é¢åŠ è½½åè‡ªåŠ¨å–è‰²
                    window.__pendingAutoExtractTheme = true;
                }

                // è§¦å‘ä¸€æ¬¡æ›´æ–°é¢„è§ˆ
                updateBtn.click();
            }
            // ä»æ­Œè¯åŒºåŸŸå–æ ·èƒŒæ™¯é¢œè‰²ï¼ˆç”¨äº auto æ–‡æœ¬é…è‰²ï¼‰
            function sampleBackgroundColorForLyrics() {
                try {
                    const cardW = Math.max(1, card.clientWidth || 1200);
                    const cardH = Math.max(1, card.clientHeight || 2100);

                    // å–æ ·ç‚¹ï¼šæ­Œè¯åŒºåŸŸä¸­ä¸Šéƒ¨åä¸­ï¼ˆæ›´è´´è¿‘å®é™…é˜…è¯»åŒºåŸŸï¼‰
                    const lx = (lyricsDisplay.offsetLeft || 0) + (lyricsDisplay.offsetWidth || 0) * 0.5;
                    const ly = (lyricsDisplay.offsetTop || 0) + (lyricsDisplay.offsetHeight || 0) * 0.35;

                    // 1) ä¼˜å…ˆå°è¯•ä»å½“å‰ WebGL èƒŒæ™¯ç”»å¸ƒå–æ ·ï¼ˆPixi/Meshï¼‰
                    const mgr = window.__bgManager;
                    const curType = (mgr && typeof mgr.getCurrentType === 'function')
                        ? mgr.getCurrentType()
                        : (mgr && mgr.bgTypes && typeof mgr.currentIndex === 'number' ? (mgr.bgTypes[mgr.currentIndex] || 'default') : 'default');

                    const tryReadWebGL = (c) => {
                        if (!c) return null;
                        let gl = null;
                        try {
                            gl = c.getContext('webgl2', { preserveDrawingBuffer: true }) || c.getContext('webgl', { preserveDrawingBuffer: true });
                        } catch (_) { gl = null; }
                        if (!gl) return null;

                        const pixels = new Uint8Array(4);
                        const scaleX = c.width / cardW;
                        const scaleY = c.height / cardH;
                        const x = Math.max(0, Math.min(c.width - 1, Math.round(lx * scaleX)));
                        const yCss = Math.max(0, Math.min(c.height - 1, Math.round(ly * scaleY)));
                        // WebGL åæ ‡ç³»ï¼šy è½´ä»åº•éƒ¨å¼€å§‹
                        const y = Math.max(0, Math.min(c.height - 1, (c.height - yCss - 1)));

                        try {
                            gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                            return { r: pixels[0] || 0, g: pixels[1] || 0, b: pixels[2] || 0 };
                        } catch (e) {
                            return null;
                        }
                    };

                    const tryRead2D = (c) => {
                        if (!c) return null;
                        let cctx = null;
                        try { cctx = c.getContext('2d', { willReadFrequently: true, alpha: true }); } catch (_) { cctx = null; }
                        if (!cctx) return null;

                        const scaleX = c.width / cardW;
                        const scaleY = c.height / cardH;
                        const x = Math.max(0, Math.min(c.width - 1, Math.round(lx * scaleX)));
                        const y = Math.max(0, Math.min(c.height - 1, Math.round(ly * scaleY)));

                        try {
                            const data = cctx.getImageData(x, y, 1, 1).data;
                            return { r: data[0] || 0, g: data[1] || 0, b: data[2] || 0 };
                        } catch (e) {
                            return null;
                        }
                    };

                    if (curType !== 'default') {
                        const webglCanvas = document.querySelector('#bgHost canvas');
                        const rgbWebgl = tryReadWebGL(webglCanvas);
                        if (rgbWebgl) return rgbWebgl;
                    }

                    // 2) é»˜è®¤æ¸å˜èƒŒæ™¯ canvas å–æ ·
                    const gradCanvas = document.getElementById('gradientCanvas');
                    const rgb2d = tryRead2D(gradCanvas);
                    if (rgb2d) return rgb2d;
                } catch (e) {}

                // fallbackï¼šä½¿ç”¨ä¸»é¢˜è‰² / èƒŒæ™¯è‰²
                const theme = getComputedStyle(card).getPropertyValue('--bg-theme-color').trim();
                if (theme) return hexToRgb(theme);
                return hexToRgb((backgroundColorInput && backgroundColorInput.value) ? backgroundColorInput.value : '#000000');
            }

            function applyTextColorMode() {
                const modeEl = document.getElementById('textColorMode');
                const glassEl = document.getElementById('glassAlphaRange');
                const glassValEl = document.getElementById('glassAlphaValue');

                const mode = modeEl ? modeEl.value : 'auto';
                const glassAlpha = glassEl ? parseFloat(glassEl.value || '0') : 0;

                if (glassValEl) {
                    glassValEl.textContent = Math.round(glassAlpha * 100) + '%';
                }

                let colorHex = '#FFFFFF';
                if (mode === 'white') colorHex = '#FFFFFF';
                else if (mode === 'black') colorHex = '#000000';
                else if (mode === 'darkgray') colorHex = '#2B2B2B';
                else if (mode === 'lightgray') colorHex = '#F5F5F5';
                else {
                    // autoï¼šä»æ­Œè¯åŒºåŸŸèƒŒæ™¯å–æ ·ï¼Œé€‰æ‹©å¯¹æ¯”åº¦æœ€é«˜çš„æ–‡å­—è‰²
                    const bg = sampleBackgroundColorForLyrics();
                    const candidates = [
                        { hex: '#FFFFFF', rgb: { r:255, g:255, b:255 } },
                        { hex: '#F5F5F5', rgb: { r:245, g:245, b:245 } },
                        { hex: '#000000', rgb: { r:0, g:0, b:0 } },
                        { hex: '#2B2B2B', rgb: { r:43, g:43, b:43 } }
                    ];
                    let best = candidates[0];
                    let bestScore = -1;
                    for (const c of candidates) {
                        const score = contrastRatio(bg, c.rgb);
                        if (score > bestScore) {
                            bestScore = score;
                            best = c;
                        }
                    }
                    colorHex = best.hex;
                }

                // åº”ç”¨åˆ°æ–‡å­—
                lyricsDisplay.style.color = colorHex;
                songTitleDisplay.style.color = colorHex;
                artistDisplay.style.color = colorHex;

                // ç»ç’ƒé®ç½©ï¼šæ ¹æ®æ–‡å­—æ·±æµ…é€‰é»‘/ç™½åº•ï¼Œalpha ç”¨æ»‘å—
                const isTextDark = isColorDark(colorHex);
                if (isTextDark) {
                    card.style.setProperty('--lyrics-glass-rgb', '255,255,255');
                } else {
                    card.style.setProperty('--lyrics-glass-rgb', '0,0,0');
                }
                card.style.setProperty('--lyrics-glass-alpha', String(glassAlpha));

                // Logo é€‚é…ï¼šä»¥æ–‡å­—é¢œè‰²ä¸ºå‡†ï¼ˆäº®å­—åˆ™ invertï¼‰
                if (logoImg) {
                    if (!isTextDark) {
                        logoImg.style.filter = 'invert(1)';
                    } else {
                        logoImg.style.filter = 'invert(0)';
                    }
                }
            }

            
            // æ›´æ–°é¢„è§ˆ
            updateBtn.addEventListener('click', () => {
                // æ›´æ–°æ­Œæ›²ä¿¡æ¯
                document.getElementById('songTitleDisplay').textContent = document.getElementById('songTitle').value;
                document.getElementById('artistDisplay').textContent = document.getElementById('artist').value;
                // æ›´æ–°ä¸“è¾‘ä¿¡æ¯ï¼ˆå¯ä¸ºç©ºï¼‰
                if (albumDisplay) {
                    const av = albumInput ? (albumInput.value || '').trim() : '';
                    albumDisplay.textContent = av;
                    albumDisplay.style.display = av ? 'block' : 'none';
                }
                
                // æ›´æ–°æ­Œè¯
                document.getElementById('lyricsDisplay').innerHTML = lyricsInput.value.replace(/\n/g, '<br>');
                
                // æ›´æ–°ä¸“è¾‘å°é¢ï¼ˆå¦‚æœæ²¡æœ‰ä¸Šä¼ æ–‡ä»¶åˆ™ä½¿ç”¨URLï¼‰
                if (albumCoverUpload.files.length === 0) {
                    albumCoverImg.src = document.getElementById('albumCover').value;
                }
                
                // æ›´æ–°å¾½æ ‡ï¼ˆå¦‚æœæ²¡æœ‰ä¸Šä¼ æ–‡ä»¶åˆ™ä½¿ç”¨URLï¼‰
                if (logoUpload.files.length === 0 && logoUrl.value) {
                    logoImg.src = logoUrl.value;
                }
                
                // æ›´æ–°èƒŒæ™¯é¢œè‰²
                card.style.backgroundColor = document.getElementById('backgroundColor').value;
                
                // è°ƒæ•´å¸ƒå±€ä»¥é€‚åº”ä¸“è¾‘å°é¢
                adjustLayoutForAlbumCover();
                
                // æ·»åŠ åŠ¨æ€æ–‡æœ¬å¯¹é½
                const lyricsLines = lyricsInput.value.split('\n');
                if (lyricsLines.length <= 6) {
                    lyricsDisplay.style.textAlign = 'center';
                    lyricsDisplay.style.letterSpacing = '0.05em';
                } else {
                    lyricsDisplay.style.textAlign = 'left';
                    lyricsDisplay.style.letterSpacing = 'normal';
                }
                
                // ä¼˜åŒ–å¡ç‰‡å¤§å°
                optimizeCardSizeForLyrics();

                // é‡æ–°è¯„ä¼°æ–‡å­—å¯è¯»æ€§
                try { applyTextColorMode(); } catch (e) {}
            });
            
                        // ä¸‹è½½PNG
            // æ€§èƒ½ï¼šæŠŠé‡å‹å¯¼å‡ºæµç¨‹ä» click handler ä¸­æ‹†å‡ºæ¥ï¼ˆclick ç«‹å³è¿”å›ï¼‰ï¼Œé¿å…å‡ºç° 8s+ çš„ç‚¹å‡»é˜»å¡ Violation
            const __ensureExportOverlay = (() => {
                let overlay = null;
                let textEl = null;
                let cancelBtn = null;
                return () => {
                    if (overlay) return { overlay, textEl, cancelBtn };
                    overlay = document.createElement('div');
                    overlay.id = 'exportOverlay';
                    overlay.style.cssText = 'position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:99999;';
                    const box = document.createElement('div');
                    box.style.cssText = 'min-width:260px;max-width:90vw;background:rgba(20,20,20,.92);color:#fff;border-radius:12px;padding:16px 18px;font-size:14px;line-height:1.4;box-shadow:0 10px 30px rgba(0,0,0,.35);';
                    textEl = document.createElement('div');
                    textEl.textContent = 'ç”Ÿæˆä¸­â€¦';
                    textEl.style.cssText = 'margin-bottom:12px;';
                    cancelBtn = document.createElement('button');
                    cancelBtn.type = 'button';
                    cancelBtn.textContent = 'å–æ¶ˆ';
                    cancelBtn.style.cssText = 'padding:8px 12px;border-radius:10px;border:0;background:#ffffff;color:#111;cursor:pointer;';
                    box.appendChild(textEl);
                    box.appendChild(cancelBtn);
                    overlay.appendChild(box);
                    document.body.appendChild(overlay);
                    return { overlay, textEl, cancelBtn };
                };
            })();

            const __yieldToUI = () => new Promise(r => setTimeout(r, 0));

            const startPngExport = async () => {
                // å…è®¸ UI å…ˆæ¸²æŸ“é®ç½©/æŒ‰é’®åé¦ˆ
                await __yieldToUI();

                // ä¿å­˜å½“å‰ç¼©æ”¾æ¯”ä¾‹
                const originalUserScale = userScale;
                const originalScale = scale;

                // é‡ç½®ç¼©æ”¾æ¯”ä¾‹ä»¥ç¡®ä¿å®Œæ•´æˆªå›¾ï¼ˆè®©æœ€ç»ˆ applied scale = 1ï¼‰
                const auto = computeAutoScale();
                userScale = auto > 0 ? (1 / auto) : 1;
                applyScale();

                // è®¡ç®—ç¡®ä¿ä¸“è¾‘å°é¢è‡³å°‘940pxçš„ç¼©æ”¾æ¯”ä¾‹ï¼ˆé¿å… width=0 å¯¼è‡´ scale çˆ†ç‚¸ï¼‰
                const minAlbumSize = 940;
                let currentAlbumSize = 0;
                try {
                    const r = albumCoverImg.getBoundingClientRect();
                    currentAlbumSize = r && r.width ? r.width : 0;
                } catch (_) {}
                if (!currentAlbumSize) currentAlbumSize = albumCoverImg.offsetWidth || albumCoverImg.width || 0;
                if (!currentAlbumSize) currentAlbumSize = 600; // å…œåº•ï¼Œé¿å… Infinity
                let requiredScale = Math.max(2, minAlbumSize / currentAlbumSize);
                try {
                    const perf = (window.__LYRICS_PERF || {});
                    if (perf.isMobile) requiredScale = Math.min(requiredScale, 2.2);
                } catch (_) {}

                // å¯¼å‡ºæ—¶ï¼šè®© WebGL / Canvas èƒŒæ™¯ä»¥ä¸ html2canvas ç›¸åŒçš„åƒç´ å¯†åº¦é‡æ–°æ¸²æŸ“ï¼Œé¿å…èƒŒæ™¯æ¨¡ç³Š/é»‘å±
                const baseDpr = Math.max(1, window.devicePixelRatio || 1);
                let previewScaleNow = 1;
                try {
                    const rect = card.getBoundingClientRect();
                    const ow = card.offsetWidth || card.clientWidth || rect.width;
                    if (ow > 0) previewScaleNow = Math.max(0.05, Math.min(1, rect.width / ow));
                } catch (_) {}

                // è®©èƒŒæ™¯ç³»ç»Ÿå†…éƒ¨ dpr = requiredScaleï¼ˆè€Œä¸æ˜¯ devicePixelRatioï¼‰ï¼Œä»è€Œä¸å¯¼å‡ºåˆ†è¾¨ç‡å¯¹é½
                window.__LYRICS_CARD_EXPORT_SCALE = (requiredScale / (baseDpr * previewScaleNow));

                // å¼ºåˆ¶èƒŒæ™¯é‡æ–°è®¡ç®—å°ºå¯¸å¹¶æ¸²æŸ“ä¸€å¸§ï¼ˆå³ä½¿ç”¨æˆ·æš‚åœäº†èƒŒæ™¯åŠ¨ç”»ï¼‰
                const forceBackgroundRender = () => {
                    try { if (typeof resizeCanvas === 'function') resizeCanvas(); } catch (_) {}
                    try {
                        const bm = window.__bgManager;
                        const bg = bm && bm.currentBg;
                        if (!bg) return;

                        if (typeof bg.resize === 'function') bg.resize();
                        // Pixiï¼šrenderOnce æ˜¯æˆ‘ä»¬æä¾›çš„å¼ºåˆ¶åˆ·æ–°å…¥å£
                        if (typeof bg.renderOnce === 'function') bg.renderOnce();
                        else if (typeof bg.render === 'function') bg.render();
                        else if (typeof bg.draw === 'function') bg.draw();

                        // å…¼å®¹æ—§ç»“æ„
                        if (bg.scene && typeof bg.scene.resize === 'function') bg.scene.resize();
                        if (bg.scene && typeof bg.scene.render === 'function') bg.scene.render();
                    } catch (_) {}
                };

                const waitForWebGLRender = () => new Promise((resolve) => {
                    requestAnimationFrame(() => {
                        forceBackgroundRender();
                        requestAnimationFrame(resolve);
                    });
                });

                const waitForImages = async () => {
                    const images = card.querySelectorAll('img');
                    const promises = Array.from(images).map(img => {
                        if (img.complete) return Promise.resolve();
                        return new Promise(resolve => {
                            img.onload = resolve;
                            img.onerror = resolve;
                        });
                    });
                    await Promise.all(promises);
                };

                const snapshotCanvasToDataURL = (c) => {
                    if (!c) return null;
                    // ä¼˜å…ˆï¼šç›´æ¥ toDataURLï¼ˆ2D canvas / å¯è¯» WebGLï¼‰
                    try {
                        const url = c.toDataURL('image/png');
                        if (url && url.startsWith('data:image')) return url;
                    } catch (_) {}

                    // å¤‡ç”¨ï¼šWebGL readPixels
                    try {
                        const gl = c.getContext('webgl2') || c.getContext('webgl');
                        if (!gl) return null;
                        const w = c.width || 0;
                        const h = c.height || 0;
                        if (w <= 0 || h <= 0) return null;

                        try { gl.bindFramebuffer(gl.FRAMEBUFFER, null); } catch (_) {}
                        try { gl.finish && gl.finish(); } catch (_) {}

                        const pixels = new Uint8Array(w * h * 4);
                        gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

                        const oc = document.createElement('canvas');
                        oc.width = w;
                        oc.height = h;
                        const ctx = oc.getContext('2d', { willReadFrequently: true, alpha: true });
                        if (!ctx) return null;

                        const imgData = ctx.createImageData(w, h);
                        for (let y = 0; y < h; y++) {
                            const srcRow = (h - 1 - y) * w * 4;
                            const dstRow = y * w * 4;
                            imgData.data.set(pixels.subarray(srcRow, srcRow + w * 4), dstRow);
                        }
                        ctx.putImageData(imgData, 0, 0);
                        return oc.toDataURL('image/png');
                    } catch (_) {}
                    return null;
                };

                // ç»™èƒŒæ™¯ canvas æ‰“æ ‡ï¼Œä¾¿äº onclone ç²¾å‡†æ›¿æ¢
                const tagCanvases = (root) => {
                    const canvases = Array.from(root.querySelectorAll('canvas'));
                    canvases.forEach((c, i) => {
                        if (!c.dataset) return;
                        if (!c.dataset.ssId) c.dataset.ssId = String(i + 1);
                    });
                    return canvases;
                };

                const bgRoot = document.getElementById('bgHost') || card;
                const canvases = tagCanvases(bgRoot);

                // æ¸²æŸ“/èµ„æºå°±ç»ª
                await waitForWebGLRender();
                await __yieldToUI();
                await waitForImages();
                await __yieldToUI();
                forceBackgroundRender();
                await waitForWebGLRender();

                // é¢„å…ˆæŠŠ Pixi(WebGL) èƒŒæ™¯å¿«ç…§æˆä¸€å¼  <img> ç›´æ¥æ’å…¥åˆ°çœŸå® DOM ä¸­
                // è¿™æ · html2canvas å…‹éš† DOM æ—¶ä¼šæŠŠå®ƒå½“æ™®é€šå›¾ç‰‡ç»˜åˆ¶ï¼Œé¿å…â€œå…‹éš†å WebGL ä¸¢å¸§/ç©ºç™½/æ ·å¼ä¸¢å¤±â€
                const bm = window.__bgManager;
                const bg = bm && bm.currentBg;
                const bgHostEl = document.getElementById('bgHost');

                let __exportBgImgEl = null;
                let __hiddenCanvases = [];
                try {
                    if (bg && typeof bg.snapshot === 'function' && bgHostEl) {
                        // å¼ºåˆ¶åˆ·æ–°ä¸€å¸§ï¼Œç¡®ä¿å¿«ç…§ä¸æ˜¯ç©ºçš„
                        try { if (typeof bg.renderOnce === 'function') bg.renderOnce(); } catch (_) {}
                        let snapUrl = null;
                        try { snapUrl = bg.snapshot(); } catch (_) { snapUrl = null; }

                        if (snapUrl && snapUrl.startsWith('data:image')) {
                            // ç¡®ä¿ bgHost æœ‰å®šä½ä¸Šä¸‹æ–‡
                            try { if (getComputedStyle(bgHostEl).position === 'static') bgHostEl.style.position = 'relative'; } catch (_) {}

                            __exportBgImgEl = document.createElement('img');
                            __exportBgImgEl.id = '__exportBgSnapshot';
                            __exportBgImgEl.alt = 'export-bg-snapshot';
                            __exportBgImgEl.src = snapUrl;
                            __exportBgImgEl.style.cssText = 'position:absolute;inset:0;width:100%;height:100%;display:block;object-fit:cover;z-index:0;pointer-events:none;';

                            // æŠŠåŸæœ¬çš„ WebGL canvas æš‚æ—¶éšè—ï¼ˆä¿ç•™å¸ƒå±€å°ºå¯¸ï¼‰ï¼Œé¿å… clone æ—¶æ‹¿åˆ°ç©º canvas
                            __hiddenCanvases = Array.from(bgHostEl.querySelectorAll('canvas'));
                            __hiddenCanvases.forEach(c => {
                                c.__prevVisibility = c.style.visibility;
                                c.style.visibility = 'hidden';
                            });

                            // æ’åˆ°æœ€åº•å±‚
                            bgHostEl.insertBefore(__exportBgImgEl, bgHostEl.firstChild);

                            // ç­‰å›¾ç‰‡çœŸæ­£ readyï¼ˆé¿å… html2canvas æŠ“åˆ°æœªåŠ è½½çš„ dataURLï¼‰
                            await new Promise(res => {
                                if (__exportBgImgEl.complete) return res();
                                __exportBgImgEl.onload = () => res();
                                __exportBgImgEl.onerror = () => res();
                            });
                        }
                    }
                } catch (_) {}
// ç”Ÿæˆå¯¼å‡ºï¼ˆé‡ä»»åŠ¡ï¼‰ï¼šå°½å¯èƒ½åœ¨å¼€å§‹å‰ç»™ UI ä¸€æ¬¡åˆ·æ–°æœºä¼š
                await __yieldToUI();

                
                // FIX: html2canvas å¯¹ mix-blend-mode æ”¯æŒä¸ç¨³å®šï¼Œå¯èƒ½æŠŠ tint å½“æˆå®å¿ƒçº¯è‰²ç›–ä½åŠ¨æ€èƒŒæ™¯
                // å¯¼å‡ºæœŸé—´ä¸´æ—¶æŠŠ blend-mode è®¾ä¸º normalï¼Œå¯¼å‡ºåå®Œå…¨æ¢å¤ï¼ˆä¸åˆ åŠŸèƒ½ï¼‰
                let __tintPrev = null;
                try {
                    const tintEl = document.getElementById('bgThemeTint');
                    if (tintEl) {
                        __tintPrev = { mix: tintEl.style.mixBlendMode, bg: tintEl.style.background, op: tintEl.style.opacity };
                        // å°† CSS å˜é‡è§£ææˆå®é™…é¢œè‰²å†™å…¥ inlineï¼Œä¿è¯ clone ä¸€è‡´
                        const cs = getComputedStyle(tintEl);
                        tintEl.style.mixBlendMode = 'normal';
                        tintEl.style.background = cs.backgroundColor;
                        tintEl.style.opacity = cs.opacity;
                    }
                } catch (_) {}
try {
                    const canvas = await html2canvas(card, {
                        width: 1200,
                        height: 2100,
                        scale: requiredScale,
                        useCORS: true,
                        backgroundColor: null,
                        allowTaint: false,
                        logging: false,
                        imageTimeout: 15000,
                        removeContainer: true,
                        foreignObjectRendering: false,
                        onclone: function(clonedDoc) {
                            try {
                                // å¯¼å‡ºæœŸé—´æˆ‘ä»¬å·²åœ¨çœŸå® DOM ä¸­æ’å…¥ __exportBgSnapshotï¼Œå¹¶éšè—äº†åŸ canvasã€‚
                                // åœ¨å…‹éš†æ–‡æ¡£ä¸­åªéœ€ç¡®ä¿è¯¥å›¾ç‰‡ä¿æŒé“ºæ»¡å³å¯ã€‚
                                const img = clonedDoc.getElementById('__exportBgSnapshot');
                                if (img) {
                                    img.style.position = 'absolute';
                                    img.style.inset = '0';
                                    img.style.width = '100%';
                                    img.style.height = '100%';
                                    img.style.display = 'block';
                                    img.style.objectFit = 'cover';
                                    try { img.style.borderRadius = 'inherit'; } catch(_) {}
                                    img.style.visibility = 'visible';
                                    img.style.opacity = '1';
                                    img.style.pointerEvents = 'none';
                                }
                            } catch (_) {}
}
                    });

                    const link = document.createElement('a');
                    link.download = document.getElementById('songTitle').value + ' - ' + document.getElementById('artist').value + '.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                } catch (error) {
                    console.error('æˆªå›¾ç”Ÿæˆå¤±è´¥:', error);
                    alert('ç”Ÿæˆæˆªå›¾å¤±è´¥ï¼š' + (error.message || 'è¯·ç¡®ä¿æ‰€æœ‰å›¾ç‰‡éƒ½å·²æ­£ç¡®åŠ è½½'));
                } finally {
                    // æ¸…ç†å¯¼å‡ºç”¨çš„èƒŒæ™¯å¿«ç…§ï¼ˆå¦‚æœå­˜åœ¨ï¼‰å¹¶æ¢å¤ WebGL canvas å¯è§æ€§
                    try {
                        const bgHostEl2 = document.getElementById('bgHost');
                        const img2 = bgHostEl2 && bgHostEl2.querySelector('#__exportBgSnapshot');
                        if (img2 && img2.parentNode) img2.parentNode.removeChild(img2);
                        if (bgHostEl2) {
                            bgHostEl2.querySelectorAll('canvas').forEach(c => {
                                if (c.__prevVisibility !== undefined) {
                                    c.style.visibility = c.__prevVisibility;
                                    delete c.__prevVisibility;
                                } else {
                                    c.style.visibility = '';
                                }
                            });
                        }
                    } catch (_) {}


                    // æ¢å¤ bgThemeTint å¯¼å‡ºæœŸé—´çš„æ ·å¼
                    try {
                        const tintEl = document.getElementById('bgThemeTint');
                        if (tintEl && typeof __tintPrev === 'object' && __tintPrev) {
                            tintEl.style.mixBlendMode = __tintPrev.mix || '';
                            tintEl.style.background = __tintPrev.bg || '';
                            tintEl.style.opacity = __tintPrev.op || '';
                        }
                    } catch (_) {}
// æ¢å¤èƒŒæ™¯å¯¼å‡ºç¼©æ”¾ï¼ˆé¢„è§ˆç”¨ï¼‰
                    window.__LYRICS_CARD_EXPORT_SCALE = 1;

                    // å¯¼å‡ºåï¼Œå¼ºåˆ¶èƒŒæ™¯æ¢å¤åˆ°é¢„è§ˆåˆ†è¾¨ç‡
                    try { if (typeof resizeCanvas === 'function') resizeCanvas(); } catch (_) {}
                    try {
                        const bm2 = window.__bgManager;
                        const bg2 = bm2 && bm2.currentBg;
                        if (bg2 && typeof bg2.resize === 'function') bg2.resize();
                        if (bg2 && bg2.scene && typeof bg2.scene.resize === 'function') bg2.scene.resize();
                    } catch (_) {}

                    // æ¢å¤åŸæ¥çš„ç¼©æ”¾
                    userScale = originalUserScale;
                    scale = originalScale;
                    applyScale();
                }
            };

            downloadBtn.addEventListener('click', () => {
                // click handler ç«‹å³è¿”å›ï¼Œé¿å… Violation: click handler took xxxxms
                const { overlay, textEl, cancelBtn } = __ensureExportOverlay();
                if (window.__EXPORT_IN_PROGRESS) return;
                window.__EXPORT_IN_PROGRESS = true;

                let cancelled = false;
                overlay.style.display = 'flex';
                textEl.textContent = 'ç”Ÿæˆä¸­â€¦ï¼ˆå‡†å¤‡èµ„æºï¼‰';
                cancelBtn.onclick = () => { cancelled = true; textEl.textContent = 'å·²å–æ¶ˆ'; };

                // æŠŠé‡ä»»åŠ¡æ”¾åˆ°ä¸‹ä¸€ä¸ª tick æ‰§è¡Œ
                setTimeout(async () => {
                    try {
                        if (cancelled) return;
                        textEl.textContent = 'ç”Ÿæˆä¸­â€¦ï¼ˆæ¸²æŸ“èƒŒæ™¯ï¼‰';
                        await __yieldToUI();
                        if (cancelled) return;
                        textEl.textContent = 'ç”Ÿæˆä¸­â€¦ï¼ˆåˆæˆå¯¼å‡ºï¼‰';
                        await startPngExport();
                    } finally {
                        window.__EXPORT_IN_PROGRESS = false;
                        // å»¶è¿Ÿä¸€ç‚¹ç‚¹è®©ç”¨æˆ·çœ‹åˆ°çŠ¶æ€å˜åŒ–
                        setTimeout(() => { overlay.style.display = 'none'; }, 120);
                    }
                }, 0);
            });

            // ç¼©æ”¾æ§åˆ¶
            zoomInBtn.addEventListener('click', () => {
                userScale += 0.1;
                applyScale();
            });
            
            zoomOutBtn.addEventListener('click', () => {
                if (userScale > 0.2) {
                    userScale -= 0.1;
                    applyScale();
                }
            });
            
            // åº”ç”¨ç¼©æ”¾
            function applyScale() {
                // è‡ªåŠ¨ç¼©æ”¾ï¼šæŒ‰å±å¹•å®½åº¦ fitï¼Œä¿è¯æ‰‹æœºç«¯å®Œæ•´æ˜¾ç¤ºå¡ç‰‡ï¼ˆç¦æ­¢æˆªæ–­ï¼‰
                const auto = computeAutoScale();
                scale = Math.max(0.05, (Number.isFinite(userScale) ? userScale : 1) * auto);

                card.style.transform = `scale(${scale})`;
                card.style.transformOrigin = 'top left';
                
                // è°ƒæ•´é¢„è§ˆå®¹å™¨é«˜åº¦
                const previewContainer = document.querySelector('.preview-container');
                const baseW = card.offsetWidth || 1200;
                const baseH = card.offsetHeight || 2100;
                previewContainer.style.height = `${baseH * scale + 40}px`;
                previewContainer.style.width = `${baseW * scale + 40}px`;

                // é€šçŸ¥èƒŒæ™¯ç³»ç»Ÿï¼šå¡ç‰‡ transform scale æ”¹å˜åï¼Œéœ€è¦é‡æ–°è®¡ç®—ç¦»å±åˆ†è¾¨ç‡ï¼ˆé¿å…â€œå¡çˆ†â€/è¦†ç›–ä¸å…¨ï¼‰
                try { if (typeof resizeCanvas === 'function') resizeCanvas(); } catch (_) {}

                try {
                    const bm = window.__bgManager;
                    const bg = bm && bm.currentBg;
                    if (bg) {
                        if (bg.scene && typeof bg.scene.resize === 'function') bg.scene.resize();
                        if (bg.renderer && typeof bg.renderer.resize === 'function') bg.renderer.resize();
                    }
                } catch (_) {}
            }
            
            // è‡ªåŠ¨è·å–æ­Œè¯
            fetchLyricsBtn.addEventListener('click', async () => {
                // è‹¥å·²æ¥å…¥çœŸå® APIï¼ˆGDStudio/TuneHubï¼‰ï¼Œåˆ™è·³è¿‡æ­¤æ¨¡æ‹Ÿåˆ†æ”¯ã€‚
                // è¯´æ˜ï¼šæ¨¡æ‹Ÿä»£ç ä¿ç•™ä»¥æ»¡è¶³â€œå®Œæ•´ç§»æ¤/ä¸åˆ é€»è¾‘â€çš„è¦æ±‚ã€‚
                if (typeof searchMusic === 'function' && typeof apiRequest === 'function' && document.getElementById('apiSelect')) {
                    return;
                }
                const songTitle = document.getElementById('songTitle').value.trim();
                const artist = document.getElementById('artist').value.trim();
                
                if (!songTitle || !artist) {
                    alert('è¯·è¾“å…¥æ­Œæ›²åç§°å’Œæ­Œæ‰‹åç§°');
                    return;
                }
                
                fetchingIndicator.style.display = 'inline-block';
                
                try {
                    // è¿™é‡Œæ¨¡æ‹ŸAPIè°ƒç”¨è·å–æ­Œè¯ï¼Œå®é™…é¡¹ç›®ä¸­åº”æ›¿æ¢ä¸ºçœŸå®API
                    // åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªå»¶è¿Ÿæ¥æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
                    await new Promise(resolve => setTimeout(resolve, 1500));
                    
                    // æ¨¡æ‹Ÿæ­Œè¯æ•°æ®
                    let demoLyrics;
                    
                    if (songTitle === 'çƒŸèŠ±æ˜“å†·' && artist === 'å‘¨æ°ä¼¦') {
                        demoLyrics = `ç¹åå£°
éå…¥ç©ºé—¨
æŠ˜ç…äº†ä¸–äººæ¢¦åå†·
è¾—è½¬ä¸€ç”Ÿ
æƒ…å€ºåˆå‡ æœ¬å¦‚ä½ é»˜è®¤
ç”Ÿæ­»æ¯ç­‰æ¯ç­‰ä¸€åœˆ
åˆä¸€åœˆçš„
å¹´è½®æµ®å± å¡”
æ–­äº†å‡ å±‚
æ–­äº†è°çš„é­‚`;
                    } else {
                        // å…¶ä»–æ­Œæ›²æ˜¾ç¤ºä¸€ä¸ªé€šç”¨ç¤ºä¾‹
                        demoLyrics = `è¿™æ˜¯ ${songTitle} - ${artist} çš„æ­Œè¯ç¤ºä¾‹
è¿™é‡Œå°†æ˜¾ç¤ºç¬¬ä¸€æ®µæ­Œè¯
æ¯ä¸€è¡Œä»£è¡¨æ­Œè¯çš„ä¸€è¡Œ
å¯ä»¥é€šè¿‡é€‰æ‹©æ­Œè¯è¡Œ
æ¥å†³å®šæ˜¾ç¤ºå“ªäº›éƒ¨åˆ†

è¿™æ˜¯ç¬¬äºŒæ®µæ­Œè¯
é€šå¸¸æ­Œè¯ä¼šæœ‰å¤šä¸ªæ®µè½
æ‚¨å¯ä»¥é€‰æ‹©æœ€å–œæ¬¢çš„éƒ¨åˆ†
æ¥åˆ¶ä½œæ‚¨çš„æ­Œè¯å¡ç‰‡

å‰¯æ­Œéƒ¨åˆ†é€šå¸¸æ˜¯æœ€æ‰“åŠ¨äººçš„
æ‚¨å¯ä»¥åªé€‰æ‹©å‰¯æ­Œéƒ¨åˆ†
æˆ–è€…é€‰æ‹©æ•´é¦–æ­Œçš„æ­Œè¯
ä¸€åˆ‡ç”±æ‚¨å†³å®š`;
                    }
                    
                    // æ›´æ–°æ­Œè¯è¾“å…¥æ¡†
                    lyricsInput.value = demoLyrics;
                    
                    // ç”Ÿæˆæ­Œè¯é€‰æ‹©å™¨
                    generateLyricsSelector(demoLyrics, {
                        splitCnPunc: !!(splitCnPuncChk && splitCnPuncChk.checked)
                    });
                    
                    // æ˜¾ç¤ºæ­Œè¯é€‰æ‹©å™¨
                    lyricsSelector.classList.add('active');
                    
                } catch (error) {
                    console.error('è·å–æ­Œè¯å¤±è´¥:', error);
                    alert('è·å–æ­Œè¯å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
                } finally {
                    fetchingIndicator.style.display = 'none';
                }
            });
            
            // ç”Ÿæˆæ­Œè¯é€‰æ‹©å™¨
            function __splitCnPunc(line) {
                // å°†ä¸­æ–‡é•¿å¥æŒ‰æ ‡ç‚¹æ‹†å¼€ï¼Œæ–¹ä¾¿â€œé€‰å‡ å¥â€
                // è§„åˆ™ï¼šä¿ç•™æ ‡ç‚¹åœ¨å¥æœ«ï¼ˆæ›´åƒæ­Œè¯å¥å­ï¼‰
                const s = String(line || '');
                const out = [];
                // å…ˆæŒ‰æ¢è¡Œå¤–å±‚å¤„ç†ï¼Œè¿™é‡Œåªå¤„ç†å•è¡Œ
                const parts = s.split(/(?<=[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€,.!?:;])/g);
                for (const p of parts) {
                    const t = (p || '').trim();
                    if (t) out.push(t);
                }
                return out.length ? out : [s];
            }

            // ç”Ÿæˆæ­Œè¯é€‰æ‹©å™¨ï¼ˆå¯é€‰ï¼šæŒ‰ä¸­æ–‡æ ‡ç‚¹æ‹†åˆ†é•¿å¥ï¼‰
            function generateLyricsSelector(lyrics, options = {}) {
                // æ¸…ç©ºç°æœ‰å†…å®¹
                lyricsLines.innerHTML = '';
                
                // æŒ‰è¡Œåˆ†å‰²æ­Œè¯
                const rawLines = String(lyrics || '').split(/\r?\n/);
                const splitCnPunc = !!options.splitCnPunc;
                const lines = [];
                for (const ln of rawLines) {
                    if (splitCnPunc) {
                        // ä»…å¯¹åŒ…å«ä¸­æ–‡çš„è¡Œåšæ‹†åˆ†ï¼Œè‹±æ–‡è¡Œä¿æŒåŸæ ·
                        if (/[\u4e00-\u9fa5]/.test(ln) && /[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€]/.test(ln)) {
                            lines.push(...__splitCnPunc(ln));
                        } else {
                            lines.push(ln);
                        }
                    } else {
                        lines.push(ln);
                    }
                }
                
                // åˆ›å»ºé€‰æ‹©è¡Œ
                lines.forEach((line, index) => {
                    const lineElement = document.createElement('div');
                    lineElement.className = 'lyrics-line selected';
                    lineElement.textContent = line || ' '; // å¦‚æœæ˜¯ç©ºè¡Œï¼Œæ·»åŠ ä¸€ä¸ªç©ºæ ¼
                    lineElement.dataset.index = index;
                    
                    lineElement.addEventListener('click', () => {
                        lineElement.classList.toggle('selected');
                    });
                    
                    lyricsLines.appendChild(lineElement);
                });
            }
            
            // å…¨é€‰æŒ‰é’®
            selectAllBtn.addEventListener('click', () => {
                document.querySelectorAll('.lyrics-line').forEach(line => {
                    line.classList.add('selected');
                });
            });
            
            // å–æ¶ˆå…¨é€‰æŒ‰é’®
            deselectAllBtn.addEventListener('click', () => {
                document.querySelectorAll('.lyrics-line').forEach(line => {
                    line.classList.remove('selected');
                });
            });

            // æ‹†åˆ†ä¸­æ–‡é•¿å¥ï¼šåˆ‡æ¢åå³æ—¶é‡æ–°ç”Ÿæˆåˆ—è¡¨ï¼ˆä¸æ”¹åŸæ­Œè¯ï¼Œä»…æ”¹é€‰æ‹©è§†å›¾ï¼‰
            if (splitCnPuncChk) {
                splitCnPuncChk.addEventListener('change', () => {
                    try {
                        generateLyricsSelector(lyricsInput.value, { splitCnPunc: !!splitCnPuncChk.checked });
                        if (lyricsSelector) lyricsSelector.classList.add('active');
                    } catch (e) {}
                });
            }

            // è‡ªåŠ¨é€‰å–ï¼šæŒ‰â€œæœ€å¤šä¿ç•™ N å¥â€ä»ä¸Šåˆ°ä¸‹é€‰éç©ºè¡Œï¼ˆæ–¹ä¾¿å¿«é€ŸæŒ‘å‡ å¥ï¼‰
            if (autoPickBtn) {
                autoPickBtn.addEventListener('click', () => {
                    const maxN = Math.max(1, Math.min(60, parseInt((maxLinesInput && maxLinesInput.value) || '10', 10) || 10));
                    const all = Array.from(document.querySelectorAll('.lyrics-line'));
                    all.forEach(el => el.classList.remove('selected'));
                    let picked = 0;
                    for (const el of all) {
                        const t = (el.textContent || '').trim();
                        if (!t) continue;
                        el.classList.add('selected');
                        picked++;
                        if (picked >= maxN) break;
                    }
                });
            }
            
            // åº”ç”¨é€‰æ‹©æŒ‰é’®
            applySelectionBtn.addEventListener('click', () => {
                const selectedLines = [];
                
                document.querySelectorAll('.lyrics-line.selected').forEach(line => {
                    selectedLines.push(line.textContent);
                });
                
                // æ›´æ–°æ­Œè¯è¾“å…¥æ¡†
                lyricsInput.value = selectedLines.join('\n');
                
                // æ›´æ–°æ˜¾ç¤º
                lyricsDisplay.innerHTML = lyricsInput.value.replace(/\n/g, '<br>');
                
                // ä¸ºçŸ­æ­Œè¯å¢å¼ºé—´è·
                enhanceShortLyrics();
                
                // ä¼˜åŒ–å¡ç‰‡å¤§å°
                optimizeCardSizeForLyrics();

                // æ›´æ–°åé‡æ–°è¯„ä¼°æ–‡å­—å¯è¯»æ€§
                try { applyTextColorMode(); } catch (e) {}
            });
            
            // åˆ†æè°ƒè‰²æ¿é¢‘ç‡å¹¶æ’åºï¼ˆä»é«˜åˆ°ä½ï¼‰
            function analyzePaletteFrequency(palette) {
                // å°†é¢œè‰²è½¬æ¢ä¸ºå¯æ¯”è¾ƒçš„æ ¼å¼
                let colorMap = new Map();
                
                palette.forEach(color => {
                    const hex = rgbToHex(color[0], color[1], color[2]);
                    
                    // è®¡ç®—é¢œè‰²ç°‡ï¼Œå°†è§†è§‰ä¸Šç›¸ä¼¼çš„é¢œè‰²å½’ä¸ºä¸€ç»„
                    const colorKey = getColorCluster(color);
                    
                    if (colorMap.has(colorKey)) {
                        let item = colorMap.get(colorKey);
                        item.count++;
                        // å¦‚æœå½“å‰é¢œè‰²æ¯”ä»£è¡¨è‰²æ›´é¥±å’Œï¼Œåˆ™æ›´æ–°ä»£è¡¨è‰²
                        if (colorSaturation(color) > colorSaturation(item.rgb)) {
                            item.rgb = color;
                            item.hex = hex;
                        }
                    } else {
                        colorMap.set(colorKey, {
                            rgb: color,
                            hex: hex,
                            count: 1
                        });
                    }
                });
                
                // è½¬æ¢ä¸ºæ•°ç»„å¹¶æ’åº
                let sortedColors = Array.from(colorMap.values());
                sortedColors.sort((a, b) => b.count - a.count);
                
                // è¿‡æ»¤æ‰è§†è§‰ä¸Šå¤ªç›¸ä¼¼çš„é¢œè‰²
                return filterSimilarColors(sortedColors);
            }

            // è·å–é¢œè‰²ç°‡ï¼ˆå°†RGBåˆ†ä¸ºè¾ƒç²—çš„åŒºé—´ï¼Œå°†ç›¸ä¼¼é¢œè‰²å½’ä¸ºä¸€ç»„ï¼‰
            function getColorCluster(rgb) {
                // å°†RGBå€¼åˆ†ä¸º8ä¸ªåŒºé—´
                const clusterSize = 32;
                const r = Math.floor(rgb[0] / clusterSize);
                const g = Math.floor(rgb[1] / clusterSize);
                const b = Math.floor(rgb[2] / clusterSize);
                
                return `${r}-${g}-${b}`;
            }

            // è®¡ç®—é¢œè‰²é¥±å’Œåº¦
            function colorSaturation(rgb) {
                const r = rgb[0] / 255;
                const g = rgb[1] / 255;
                const b = rgb[2] / 255;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                
                // å¦‚æœmaxä¸º0ï¼Œé¥±å’Œåº¦ä¸º0
                if (max === 0) return 0;
                
                return (max - min) / max;
            }

            // è¿‡æ»¤è§†è§‰ä¸Šå¤ªç›¸ä¼¼çš„é¢œè‰²
            function filterSimilarColors(colors) {
                let result = [];
                let addedColors = new Set();
                
                for (let color of colors) {
                    // è®¡ç®—ä¸€ä¸ªç®€åŒ–çš„é¢œè‰²ç­¾å
                    const signature = getSimplifiedColorSignature(color.rgb);
                    
                    // å¦‚æœè¿™ä¸ªç­¾åè¿˜æ²¡æœ‰æ·»åŠ è¿‡ï¼Œæ·»åŠ å®ƒ
                    if (!addedColors.has(signature)) {
                        result.push(color);
                        addedColors.add(signature);
                        
                        // æœ€å¤šæ˜¾ç¤º8ç§ä¸åŒçš„é¢œè‰²
                        if (result.length >= 8) break;
                    }
                }
                
                return result;
            }

            // è·å–ç®€åŒ–çš„é¢œè‰²ç­¾åï¼ˆæ›´ç²—çš„èšç±»ï¼‰
            function getSimplifiedColorSignature(rgb) {
                // å°†RGBå€¼åˆ†ä¸º4ä¸ªåŒºé—´
                const signatureSize = 64;
                const r = Math.floor(rgb[0] / signatureSize);
                const g = Math.floor(rgb[1] / signatureSize);
                const b = Math.floor(rgb[2] / signatureSize);
                
                return `${r}-${g}-${b}`;
            }
            
            // ä¼˜åŒ–æ­Œè¯æ’ç‰ˆ
            formatLyricsBtn.addEventListener('click', () => {
                // Apple é£æ ¼ï¼šä¼˜å…ˆç”¨çº¯è§†è§‰æ’ç‰ˆï¼ˆä¸å¼ºè¡Œæ™ºèƒ½æ‹†å¥ï¼‰ï¼Œé¿å…è¶Šæ’è¶Šæ€ª
                const appleMode = true;

                let lyrics = lyricsInput.value;
                
                // å¤„ç†è¿ç»­ç©ºè¡Œ
                lyrics = lyrics.replace(/\n{3,}/g, '\n\n');
                
                // æ™ºèƒ½åˆ†è¡Œå¤„ç†
                const formattedLines = [];
                const lines = lyrics.split('\n');
                
                // è¯†åˆ«æ­Œè¯ç»“æ„
                const structure = analyzeStructure(lines);
                
                for (const line of lines) {
                    if (line.trim() === '') {
                        formattedLines.push('');
                        continue;
                    }
                    
                    if (line.length > 12) {
                        // æ™ºèƒ½åˆ†è¡Œ
                        const segments = smartLineBreak(line, structure);
                        formattedLines.push(...segments);
                    } else {
                        formattedLines.push(line);
                    }
                }
                
                // åº”ç”¨Apple Musicæ ·å¼æ’ç‰ˆä¼˜åŒ–
                const appleStyleLyrics = applyAppleMusicStyling(formattedLines, structure);

                // æ›´æ–°è¾“å…¥æ¡†ä¸é¢„è§ˆ
                lyricsInput.value = appleStyleLyrics;
                lyricsDisplay.innerHTML = appleStyleLyrics.replace(/\n/g, '<br>');

                // æ ¹æ®ç»“æ„åº”ç”¨è§†è§‰æ ·å¼
                try { applyVisualStyle(structure); } catch (e) {}
                try { optimizeCardSizeForLyrics(); } catch (e) {}

                // é‡æ–°è¯„ä¼°æ–‡å­—å¯è¯»æ€§
                try { applyTextColorMode(); } catch (e) {}

                // â€”â€” æ–°å¢ï¼šç‚¹â€œä¼˜åŒ–æ­Œè¯æ’ç‰ˆâ€åï¼Œä¹ŸåŒæ­¥ç”Ÿæˆâ€œå¯é€‰å¥å­â€åˆ—è¡¨ï¼ˆä¾¿äºæŒ‘é€‰å‡ å¥ï¼‰
                try {
                    generateLyricsSelector(lyricsInput.value, {
                        splitCnPunc: !!(splitCnPuncChk && splitCnPuncChk.checked)
                    });
                    if (lyricsSelector) lyricsSelector.classList.add('active');
                } catch (e) {}
            });

            // æ–‡æœ¬é¢œè‰²ï¼ˆæ–°ï¼šä¸‹æ‹‰ + ç»ç’ƒé®ç½©ï¼‰
            const textColorModeEl = document.getElementById('textColorMode');
            const glassAlphaEl = document.getElementById('glassAlphaRange');

            if (textColorModeEl) {
                textColorModeEl.addEventListener('change', () => {
                    applyTextColorMode();
                });
            }
            if (glassAlphaEl) {
                // æ€§èƒ½ï¼šinput è¿ç»­è§¦å‘ä¼šå¯¼è‡´å¯è¯»æ€§è®¡ç®—ï¼ˆé‡‡æ ·/åƒç´ è¯»å–ï¼‰åå¤è¿è¡Œï¼Œä½¿ç”¨è½»é‡é˜²æŠ–
                let _glassDebounceT = null;
                glassAlphaEl.addEventListener('input', () => {
                    if (_glassDebounceT) clearTimeout(_glassDebounceT);
                    _glassDebounceT = setTimeout(() => {
                        _glassDebounceT = null;
                        try { applyTextColorMode(); } catch (e) {}
                    }, 80);
                });
            }

            // èƒŒæ™¯æ¨¡å¼ä¸‹æ‹‰ï¼šè”åŠ¨ BackgroundManagerï¼ˆé»˜è®¤/çº¯è‰²/Pixi/Meshï¼‰
            const bgModeSelect = document.getElementById('bgModeSelect');
            if (bgModeSelect) {
                bgModeSelect.addEventListener('change', async () => {
                    try {
                        const mgr = window.__bgManager;
                        if (!mgr) return;
                        const type = bgModeSelect.value;
                        mgr.currentIndex = mgr.bgTypes.indexOf(type);
                        await mgr.switchBackground(type);

                        // åˆ‡æ¢åç¨ç­‰ä¸€å¸§å†åšå¯è¯»æ€§è®¡ç®—
                        setTimeout(() => {
                            try { applyTextColorMode(); } catch (e) {}
                        }, 120);
                    } catch (e) {
                        console.warn('bgModeSelect change failed:', e);
                    }
                });
            }

            // å¦‚æœç‚¹å‡»â€œå¾ªç¯åˆ‡æ¢â€ï¼Œä¹ŸåŒæ­¥ä¸‹æ‹‰å€¼
            const bgSwitchBtn2 = document.getElementById('bgSwitchBtn');
            if (bgSwitchBtn2 && bgModeSelect) {
                bgSwitchBtn2.addEventListener('click', () => {
                    setTimeout(() => {
                        try {
                            const mgr = window.__bgManager;
                            if (mgr && mgr.bgTypes) {
                                const cur = mgr.bgTypes[mgr.currentIndex] || 'default';
                                bgModeSelect.value = cur;
                            }
                            applyTextColorMode();
                        } catch (e) {}
                    }, 160);
                });
            }

            // èƒŒæ™¯é¢œè‰²ï¼šå®æ—¶é¢„è§ˆ + ä¸»é¢˜è‰²è”åŠ¨
            if (backgroundColorInput) {
                backgroundColorInput.addEventListener('input', () => {
                    const v = backgroundColorInput.value;
                    card.style.backgroundColor = v;
                    setThemeColor(v);
                    applyThemeColorToDynamicBackground(v);
                    updateColorPreview(v);
                    applyTextColorMode();
                });
            }

            // å°é¢å˜åŒ–ï¼šåŒæ­¥ç»™èƒŒæ™¯ç³»ç»Ÿç›‘å¬çš„ #albumArtï¼Œå¹¶åœ¨éœ€è¦æ—¶è‡ªåŠ¨å–è‰²
            const albumArtAlias = document.getElementById('albumArt');
            if (albumArtAlias) {
                albumArtAlias.src = albumCoverImg.src;
            }

            albumCoverImg.addEventListener('load', () => {
                try {
                    if (albumArtAlias) albumArtAlias.src = albumCoverImg.src;
                } catch (e) {}

                // åŒæ­¥ç»™é¢œè‰²ç®—æ³•/èƒŒæ™¯ç³»ç»Ÿä½¿ç”¨çš„å½“å‰å°é¢ URLï¼ˆå®Œæ•´ç§»æ¤æ‰€éœ€å­—æ®µï¼‰
                try { currentAlbumUrl = albumCoverImg.src; } catch (e) {}

                // èƒŒæ™¯ç³»ç»Ÿï¼šè·Ÿéšå°é¢æ›´æ–°ï¼ˆå…œåº•ï¼‰
                try {
                    const mgr = window.__bgManager;
                    if (mgr && typeof mgr.handleAlbumArtChanged === 'function') {
                        mgr.handleAlbumArtChanged(albumCoverImg.src);
                    }
                } catch (e) {}

                // è‹¥æ ‡è®°éœ€è¦è‡ªåŠ¨å–è‰²ï¼ˆAPI è·å–å°é¢åï¼‰ï¼Œåˆ™è§¦å‘ä¸€æ¬¡å–è‰²
                if (window.__pendingAutoExtractTheme) {
                    window.__pendingAutoExtractTheme = false;
                    try { extractColorBtn.click(); } catch (e) {}
                }

                // èƒŒæ™¯æ”¹å˜åé‡æ–°åº”ç”¨æ–‡å­—å¯è¯»æ€§
                try { applyTextColorMode(); } catch (e) {}
            });

            // åˆå§‹åŒ–ï¼šåº”ç”¨ä¸€æ¬¡æ–‡æœ¬å¯è¯»æ€§ä¸ä¸»é¢˜è‰²
            setThemeColor(backgroundColorInput.value || '#000000');
            applyTextColorMode();

            // è¯†åˆ«æ­Œè¯ç»“æ„ï¼ˆä¾›â€œä¼˜åŒ–æ­Œè¯æ’ç‰ˆâ€ä½¿ç”¨ï¼‰
            function analyzeStructure(lines) {
                const structure = {
                    isShort: false,
                    averageLineLength: 0,
                    hasChorus: false,
                    language: 'unknown'
                };

                const list = Array.isArray(lines) ? lines : (typeof lines === 'string' ? lines.split(/\r?\n/) : []);
                const nonEmpty = list.filter(l => (l || '').trim() !== '');
                // çŸ­æ­Œè¯ï¼šæœ‰æ•ˆè¡Œæ•° <= 8ï¼ˆä¿æŒåŸé€»è¾‘æ„å›¾ï¼‰
                structure.isShort = nonEmpty.length <= 8;

                // è®¡ç®—å¹³å‡è¡Œé•¿
                let totalLength = 0;
                let nonEmptyLines = 0;
                for (const line of list) {
                    if ((line || '').trim() !== '') {
                        totalLength += (line || '').length;
                        nonEmptyLines++;
                    }
                }
                structure.averageLineLength = nonEmptyLines > 0 ? totalLength / nonEmptyLines : 0;

                // æ£€æµ‹è¯­è¨€ï¼ˆç®€å•åˆ¤æ–­ï¼‰
                let chineseChars = 0;
                let englishChars = 0;
                for (const line of list) {
                    chineseChars += ((line || '').match(/[\u4e00-\u9fa5]/g) || []).length;
                    englishChars += ((line || '').match(/[a-zA-Z]/g) || []).length;
                }
                if (chineseChars > englishChars) {
                    structure.language = 'chinese';
                } else if (englishChars > chineseChars) {
                    structure.language = 'english';
                }

                // æ£€æµ‹æ˜¯å¦æœ‰å‰¯æ­Œéƒ¨åˆ†ï¼ˆé€šè¿‡é‡å¤è¡Œï¼‰
                const lineFrequency = {};
                for (const line of list) {
                    if ((line || '').trim() !== '') {
                        lineFrequency[line] = (lineFrequency[line] || 0) + 1;
                    }
                }
                for (const line in lineFrequency) {
                    if (lineFrequency[line] >= 2 && line.length > 5) {
                        structure.hasChorus = true;
                        break;
                    }
                }

                return structure;
            }

            // æ™ºèƒ½åˆ†è¡Œ
            function smartLineBreak(line, structure) {
                const segments = [];
                
                // æ ¹æ®è¯­è¨€åº”ç”¨ä¸åŒçš„åˆ†è¡Œç­–ç•¥
                if (structure.language === 'chinese') {
                    // ä¸­æ–‡æ­Œè¯åˆ†è¡Œç­–ç•¥
                    const breakPoints = [
                        ',', 'ï¼Œ', 'ã€‚', '.', '!', 'ï¼', '?', 'ï¼Ÿ', 
                        'ã€', ';', 'ï¼›', 'ï¼š', ':', ')', 'ï¼‰', '(', 'ï¼ˆ'
                    ];
                    
                    // æœ€å¤§è¡Œé•¿åº¦ï¼ˆä¸­æ–‡å’Œè‹±æ–‡ä¸åŒï¼‰
                    const maxLineLength = 15;
                    
                    if (line.length <= maxLineLength) {
                        segments.push(line);
                        return segments;
                    }
                    
                    // å°è¯•åœ¨æ–­å¥å¤„åˆ†è¡Œ
                    let currentLine = '';
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        currentLine += char;
                        
                        // å½“å‰å­—ç¬¦æ˜¯æ–­å¥ç¬¦å·ä¸”å½“å‰è¡Œé•¿åº¦é€‚ä¸­
                        if (breakPoints.includes(char) && currentLine.length >= 7) {
                            segments.push(currentLine);
                            currentLine = '';
                        }
                        // å¼ºåˆ¶åˆ†è¡Œï¼ˆè¡Œå¤ªé•¿ï¼‰
                        else if (currentLine.length >= maxLineLength) {
                            // å¯»æ‰¾ä¹‹å‰çš„æ–­å¥ç‚¹
                            let breakFound = false;
                            for (let j = currentLine.length - 1; j >= Math.max(0, currentLine.length - 5); j--) {
                                if (breakPoints.includes(currentLine[j])) {
                                    segments.push(currentLine.substring(0, j + 1));
                                    currentLine = currentLine.substring(j + 1);
                                    breakFound = true;
                                    break;
                                }
                            }
                            
                            // å¦‚æœæ²¡æ‰¾åˆ°åˆé€‚çš„æ–­å¥ç‚¹ï¼Œç›´æ¥åˆ†è¡Œ
                            if (!breakFound && currentLine.length >= maxLineLength) {
                                segments.push(currentLine);
                                currentLine = '';
                            }
                        }
                    }
                    
                    // æ·»åŠ å‰©ä½™éƒ¨åˆ†
                    if (currentLine) {
                        segments.push(currentLine);
                    }
                } else {
                    // è‹±æ–‡æ­Œè¯åˆ†è¡Œç­–ç•¥
                    const words = line.split(' ');
                    let currentLine = '';
                    
                    for (const word of words) {
                        const potentialLine = currentLine ? currentLine + ' ' + word : word;
                        
                        if (potentialLine.length > 35) { // è‹±æ–‡è¡Œé•¿åº¦ä¸Šé™
                            segments.push(currentLine);
                            currentLine = word;
                        } else {
                            currentLine = potentialLine;
                        }
                    }
                    
                    if (currentLine) {
                        segments.push(currentLine);
                    }
                }
                
                return segments;
            }

            // åº”ç”¨Apple Musicé£æ ¼æ’ç‰ˆ
            function applyAppleMusicStyling(lines, structure) {
                // ä¸ºçŸ­æ­Œè¯æ·»åŠ é¢å¤–çš„ç©ºè¡Œä»¥å±…ä¸­å±•ç¤º
                if (structure.isShort) {
                    // æ·»åŠ å‰å¯¼ç©ºè¡Œ
                    for (let i = 0; i < 3; i++) {
                        lines.unshift('');
                    }
                    
                    // åœ¨è¡Œä¹‹é—´æ·»åŠ ç©ºè¡Œ
                    const newLines = [];
                    for (const line of lines) {
                        newLines.push(line);
                        if (line.trim() !== '') {
                            newLines.push('');
                        }
                    }
                    
                    // æ·»åŠ å°¾éƒ¨ç©ºè¡Œ
                    for (let i = 0; i < 3; i++) {
                        newLines.push('');
                    }
                    
                    return newLines.join('\n');
                }
                
                // ä¸ºæ™®é€šé•¿åº¦æ­Œè¯ä¼˜åŒ–é—´è·
                if (structure.hasChorus) {
                    // å°è¯•è¯†åˆ«å‰¯æ­Œéƒ¨åˆ†å¹¶æ·»åŠ ä¸€è¡Œé—´è·
                    const newLines = [];
                    let lastLineEmpty = false;
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        const nextLine = i < lines.length - 1 ? lines[i + 1] : '';
                        
                        newLines.push(line);
                        
                        // å¦‚æœå½“å‰è¡Œä¸ä¸ºç©ºï¼Œä¸‹ä¸€è¡Œä¹Ÿä¸ä¸ºç©ºï¼Œä¸”æ˜¯æ–°çš„æ®µè½å¼€å§‹
                        // åˆ™æ·»åŠ ä¸€ä¸ªç©ºè¡Œï¼ˆç”¨äºåˆ†éš”å‰¯æ­Œå’Œå…¶ä»–éƒ¨åˆ†ï¼‰
                        if (line.trim() !== '' && nextLine.trim() !== '' && 
                            (i > 0 && lines[i-1].trim() === '')) {
                            newLines.push('');
                        }
                        
                        lastLineEmpty = line.trim() === '';
                    }
                    
                    return newLines.join('\n');
                }
                
                return lines.join('\n');
            }

            // åº”ç”¨è§†è§‰æ ·å¼
            function applyVisualStyle(structure) {
                // æ ¹æ®æ­Œè¯ç»“æ„åº”ç”¨ä¸åŒè§†è§‰æ ·å¼
                if (structure.isShort) {
                    // çŸ­æ­Œè¯ï¼šå±…ä¸­å¯¹é½ï¼Œè¾ƒå¤§å­—ä½“
                    lyricsDisplay.style.textAlign = 'center';
                    lyricsDisplay.style.letterSpacing = '0.05em';
                    
                    // ä¸­æ–‡å’Œè‹±æ–‡ä¸åŒå­—ä½“å¤§å°
                    const fontSize = structure.language === 'chinese' ? 90 : 85;
                    fontSizeRange.value = fontSize;
                    fontSizeValue.textContent = `${fontSize}px`;
                    lyricsDisplay.style.fontSize = `${fontSize}px`;
                    lyricsDisplay.style.lineHeight = `${Math.floor(fontSize * 1.3)}px`;
                } else {
                    // é•¿æ­Œè¯ï¼šå·¦å¯¹é½ï¼Œé€‚ä¸­å­—ä½“
                    lyricsDisplay.style.textAlign = 'left';
                    lyricsDisplay.style.letterSpacing = 'normal';
                    
                    // ä¸­æ–‡å’Œè‹±æ–‡ä¸åŒå­—ä½“å¤§å°
                    const fontSize = structure.language === 'chinese' ? 80 : 75;
                    fontSizeRange.value = fontSize;
                    fontSizeValue.textContent = `${fontSize}px`;
                    lyricsDisplay.style.fontSize = `${fontSize}px`;
                    lyricsDisplay.style.lineHeight = `${Math.floor(fontSize * 1.3)}px`;
                }
                
                // å¦‚æœæ˜¯ä¸­æ–‡æ­Œè¯ï¼Œå¢åŠ å­—é—´è·
                if (structure.language === 'chinese'){
                    lyricsDisplay.style.letterSpacing = '0.05em';
                }
            }
            
            // è·å–å›¾ç‰‡åŸå§‹å°ºå¯¸å’Œæ¯”ä¾‹
            albumCoverImg.onload = function() {
                albumOriginalWidth = this.naturalWidth;
                albumOriginalHeight = this.naturalHeight;
                albumAspectRatio = albumOriginalWidth / albumOriginalHeight;
                
                // è°ƒæ•´å¸ƒå±€ä»¥é€‚åº”ä¸“è¾‘å°é¢æ¯”ä¾‹
                adjustLayoutForAlbumCover();
            };
            
            // æ ¹æ®ä¸“è¾‘å°é¢æ¯”ä¾‹è°ƒæ•´å¸ƒå±€
            function adjustLayoutForAlbumCover() {
                // ä¿æŒä¸“è¾‘å°é¢çš„åŸå§‹æ¯”ä¾‹
                const coverWidth = 200; // ä¿æŒåŸå®½åº¦
                const coverHeight = coverWidth / albumAspectRatio;
                
                albumCoverImg.style.width = `${coverWidth}px`;
                albumCoverImg.style.height = `${coverHeight}px`;
                
                // è°ƒæ•´æ­Œè¯ä½ç½®ï¼Œé˜²æ­¢é®æŒ¡
                const newTop = Math.max(300, 90 + coverHeight + 20); // ç¡®ä¿æ­Œè¯åœ¨å°é¢ä¸‹æ–¹è‡³å°‘20px
                lyricsDisplay.style.top = `${newTop}px`;
                
                // è°ƒæ•´å¡ç‰‡é«˜åº¦ï¼ˆå¦‚æœéœ€è¦ï¼‰
                if (newTop + 1650 > 2100) {
                    card.style.height = `${newTop + 1650 + 90}px`; // ç¡®ä¿åº•éƒ¨æœ‰90pxçš„è¾¹è·
                }
            }
            
            // ä¼˜åŒ–å¡ç‰‡å¤§å°ä»¥é€‚åº”æ­Œè¯
            function optimizeCardSizeForLyrics() {
                const lyrics = lyricsInput.value;
                const lyricsLines = lyrics.split('\n').filter(line => line.trim() !== '');
                
                // è·å–å½“å‰å­—ä½“å¤§å°
                const fontSize = parseInt(fontSizeRange.value);
                const lineHeight = Math.floor(fontSize * 1.3);
                
                // è®¡ç®—æœ€ä½³æ­Œè¯é«˜åº¦
                let optimalLyricsHeight = lyricsLines.length * lineHeight + 100; // æ·»åŠ å†…è¾¹è·
                
                // è·å–å½“å‰æ­Œè¯çš„é¡¶éƒ¨ä½ç½®
                const lyricsTop = parseInt(lyricsDisplay.style.top) || 300;
                
                // è®¡ç®—æœ€ä½³å¡ç‰‡é«˜åº¦ï¼ˆæœ€å°1300pxï¼Œæœ€å¤§2100pxï¼‰
                const minCardHeight = 1300;
                const maxCardHeight = 2100;
                const calculatedHeight = lyricsTop + optimalLyricsHeight + 200; // æ·»åŠ åº•éƒ¨è¾¹è·
                
                // è®¾ç½®æœ€ä½³å¡ç‰‡é«˜åº¦ï¼ˆåœ¨é™åˆ¶èŒƒå›´å†…ï¼‰
                const optimalCardHeight = Math.max(minCardHeight, Math.min(maxCardHeight, calculatedHeight));
                card.style.height = `${optimalCardHeight}px`;
                
                // å¦‚æœæ­Œè¯è¾ƒçŸ­ï¼Œå‚ç›´å±…ä¸­
                if (lyricsLines.length <= 10) {
                    const availableSpace = optimalCardHeight - lyricsTop - 150;
                    const contentHeight = lyricsLines.length * lineHeight;
                    const topPadding = Math.max(0, (availableSpace - contentHeight) / 2);
                    lyricsDisplay.style.paddingTop = `${topPadding}px`;
                } else {
                    lyricsDisplay.style.paddingTop = '0';
                }
                
                // è°ƒæ•´æ­Œè¯å®¹å™¨é«˜åº¦
                lyricsDisplay.style.height = `${optimalCardHeight - lyricsTop - 150}px`;
            }
            
            // ä¸ºçŸ­æ­Œè¯å¢å¼ºé—´è·
            function enhanceShortLyrics() {
                const selectedLines = lyricsInput.value.split('\n').filter(line => line.trim() !== '');
                
                if (selectedLines.length <= 4) {
                    // éå¸¸çŸ­çš„æ­Œè¯ï¼Œå¢åŠ è¡Œé—´è·
                    const enhancedLyrics = selectedLines.join('\n\n');
                    lyricsInput.value = enhancedLyrics;
                    lyricsDisplay.innerHTML = enhancedLyrics.replace(/\n/g, '<br>');
                    
                    // å¢å¤§å­—ä½“å¤§å°ä»¥å¢å¼ºè§†è§‰æ•ˆæœ
                    const currentSize = parseInt(fontSizeRange.value);
                    const newSize = Math.min(100, currentSize + 10);
                    fontSizeRange.value = newSize;
                    fontSizeValue.textContent = `${newSize}px`;
                    lyricsDisplay.style.fontSize = `${newSize}px`;
                    lyricsDisplay.style.lineHeight = `${Math.floor(newSize * 1.4)}px`;
                }
            }
            
            // æ–‡æœ¬é¢œè‰²æ§åˆ¶
            textLightBtn.addEventListener('click', () => {
                lyricsDisplay.style.color = '#ffffff';
                document.getElementById('songTitleDisplay').style.color = '#ffffff';
                document.getElementById('artistDisplay').style.color = '#ffffff';
                logoImg.style.filter = 'brightness(10)';
            });
            
            textDarkBtn.addEventListener('click', () => {
                lyricsDisplay.style.color = '#000000';
                document.getElementById('songTitleDisplay').style.color = '#000000';
                document.getElementById('artistDisplay').style.color = '#000000';
                logoImg.style.filter = 'brightness(0)';
            });
            
            // é»˜è®¤éšè—Logoå¹¶æ›´æ–°æŒ‰é’®æ–‡æœ¬
            logoImg.style.display = 'none';
            toggleLogoBtn.textContent = 'å¼€å¯æ ‡å¿—';

            // åˆ‡æ¢Logoæ˜¾ç¤º/éšè—
            toggleLogoBtn.addEventListener('click', () => {
                const isVisible = logoImg.style.display !== 'none';
                logoImg.style.display = isVisible ? 'none' : 'block';
                toggleLogoBtn.textContent = isVisible ? 'å¼€å¯æ ‡å¿—' : 'å…³é—­æ ‡å¿—';
            });
            
            // åˆå§‹åŒ–æ›´æ–°
            updateBtn.click();
        });
    </script>

</body>
<style></style></html>