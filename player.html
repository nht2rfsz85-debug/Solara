<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <!-- Fix: iOS/PWA å…ƒä¿¡æ¯å¢å¼º -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- å•æ–‡ä»¶ç‰ˆï¼šå·²ç§»é™¤å¤–éƒ¨ apple-touch-icon ä¾èµ–ï¼ˆå¦‚éœ€å›¾æ ‡å¯æ”¹ä¸º data: URIï¼‰ -->
<!-- å¯æ ¹æ®éœ€è¦è¡¥å……æ›´å¤šå°ºå¯¸çš„å›¾æ ‡é“¾æ¥ -->

    <!-- Fix: å…¼å®¹ iOS / PWA åœºæ™¯ä¸‹ console ç¼ºå¤±å¯¼è‡´çš„å´©æºƒï¼ˆå¿…é¡»ç½®äºæ‰€æœ‰è„šæœ¬ä¹‹å‰ï¼‰ -->
    <script>
    // === CONSOLE å®‰å…¨å…¼å®¹å±‚ (å¿…é¡»ç½®äºæ‰€æœ‰è„šæœ¬ä¹‹å‰) ===
    (function() {
        if (!window.console) window.console = {};
        const methods = ['log', 'error', 'warn', 'info', 'debug', 'group', 'groupCollapsed', 'groupEnd', 'table'];
        methods.forEach(m => {
            if (typeof console[m] !== 'function') console[m] = function() {};
        });
    })();
    // === ç»“æŸ ===

    // Fix: è§†å£é«˜åº¦ --vhï¼ˆæ›¿ä»£ 100vhï¼Œé¿å… iOS åœ°å€æ /å·¥å…·æ é®æŒ¡ï¼‰
    (function() {
        function setVhVar() {
            try {
                const h = (window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight;
                document.documentElement.style.setProperty('--vh', (h * 0.01) + 'px');
            } catch (_) {}
        }
        setVhVar();
        window.addEventListener('resize', setVhVar);
        window.addEventListener('orientationchange', setVhVar);
        window.addEventListener('pageshow', setVhVar);
        if (window.visualViewport && typeof window.visualViewport.addEventListener === 'function') {
            window.visualViewport.addEventListener('resize', setVhVar);
        }
        // æš´éœ²ç»™è‡ªæ£€ä½¿ç”¨
        window.__compatFix = window.__compatFix || {};
        window.__compatFix.setVhVar = setVhVar;
    })();
    </script>

    <title>éŸ³ä¹æ’­æ”¾å™¨ - Apple Liquid Glass é£æ ¼</title>
    <style>
        /* åªæ·»åŠ å¿…è¦çš„CSSä¿®æ”¹ï¼Œå…¶ä»–CSSä¿æŒä¸å˜ */
        
        /* APIé€‰æ‹©å™¨æ ·å¼ */
        .api-select {
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
            min-width: 180px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .api-select:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .api-select option {
            background: #333;
            color: white;
        }
        
        

/* é¢œè‰²ç®—æ³•åˆ‡æ¢æŒ‰é’®æ ·å¼ */
.algo-toggle-btn {
    padding: 15px 20px;
    border: none;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    font-size: 1rem;
    backdrop-filter: blur(10px);
    min-width: 180px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.algo-toggle-btn:hover {
    background: rgba(255, 255, 255, 0.2);
}

        /* APIé€‰æ‹©å™¨æç¤ºæ ‡ç­¾ */
        .api-select-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
            margin-left: 5px;
            font-weight: normal;
        }
        
        @media (max-width: 768px) {
            .search-section {
                flex-direction: column;
            }
            
            .api-select, .algo-toggle-btn, .source-select, .quality-select {
                width: 100%;
            }
        }
        
        /* æœç´¢ç»“æœä¸­çš„å¹³å°æ ‡ç­¾ */
        .result-item .platform-badge {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 2px;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .result-item .platform-badge.kuwo {
            background: rgba(255, 87, 34, 0.2);
            color: #ff5722;
        }
        
        .result-item .platform-badge.netease {
            background: rgba(216, 30, 6, 0.2);
            color: #d81e06;
        }
        
        .result-item .platform-badge.qq {
            background: rgba(25, 137, 250, 0.2);
            color: #1989fa;
        }
        
        .result-item .platform-badge.joox {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
        
        .result-item .platform-badge.aggregate {
            background: rgba(156, 39, 176, 0.2);
            color: #9c27b0;
        }
        
        /* æ€§èƒ½ä¼˜åŒ–ï¼šé€è¯é«˜äº®ä½¿ç”¨CSSç±»è€Œéå†…è”æ ·å¼ */
        .word-highlight {
            transition: color 0.15s ease;
        }
        .word-highlight.word-active {
            color: #ffcc00 !important;
        }
        
        /* æ€§èƒ½ä¼˜åŒ–ï¼šè¿›åº¦æ¡ä½¿ç”¨transformä»£æ›¿width */
        #progress, #fullscreenProgress {
            width: 100% !important;
            transform-origin: left;
            transform: scaleX(0);
        }
        
        /* æ€§èƒ½ä¼˜åŒ–ï¼šå¯ç”¨GPUåŠ é€Ÿ */
        .lyric-line, .fullscreen-lyric-line {
            will-change: transform, opacity;
        }
        
        /* åŸæœ‰çš„æ‰€æœ‰CSSä¿æŒä¸å˜ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-overflow-scrolling: touch; 
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', 'Inter', sans-serif;
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
            position: relative;
            overflow-x: hidden; 
            background-color: #000;
            -webkit-font-smoothing: antialiased;
        }

        #gradientCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            transform: scale(1.05);
            filter: blur(15px);
            opacity: 0.9;
            transition: opacity 0.5s ease;
        }

        .liquid-glass-effect {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(35px) saturate(180%);
            -webkit-backdrop-filter: blur(35px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4), 
                        inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 20px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        .search-section {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .search-box {
            flex: 1;
            min-width: 300px;
            position: relative;
        }
        
        .search-input {
            width: 100%;
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(255,255,255,0.1);
        }
        
        .source-select, .quality-select {
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
            min-width: 150px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .source-select option, .quality-select option {
            background: #333;
            color: white;
        }

        .source-select:hover, .quality-select:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .search-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .search-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .player-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            .player-container {
                grid-template-columns: 1fr;
            }
        }
        
        .now-playing {
            border-radius: 20px;
            padding: 30px;
            position: relative;
        }
        
        .album-art {
            width: 100%;
            border-radius: 20px;
            margin-bottom: 25px;
            aspect-ratio: 1;
            object-fit: cover;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4);
            display: none;
            transition: transform 0.3s ease;
        }
        
        .album-art-placeholder {
            width: 100%;
            border-radius: 20px;
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 4rem;
            margin-bottom: 25px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
        }
        
        .song-info {
            margin-bottom: 25px;
        }
        
        .song-title {
            font-size: 1.8rem;
            margin-bottom: 8px;
            font-weight: 700;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .song-artist {
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.1rem;
            font-weight: 500;
        }
        
        .progress-container {
            margin-bottom: 25px;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
            margin-bottom: 12px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: white;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .progress-handle {
            position: absolute;
            top: 50%;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            will-change: left; /* æ€§èƒ½ä¼˜åŒ–ï¼šæç¤ºæµè§ˆå™¨å‡†å¤‡GPUåŠ é€Ÿ */
        }
        
        .progress-bar:hover .progress-handle {
            opacity: 1;
        }
        
        .time-info {
            display: flex;
            justify-content: space-between;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 25px;
            margin-bottom: 25px;
        }
        
        .control-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }
        
        .play-btn {
            background: rgba(255, 255, 255, 0.2);
            width: 70px;
            height: 70px;
            font-size: 2rem;
        }

        .play-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .speed-control {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.2);
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .speed-control input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            cursor: pointer;
        }
        
        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .lyrics-container {
            border-radius: 20px;
            padding: 30px;
            max-height: 400px;
            overflow-y: auto;
            touch-action: pan-y; 
            position: relative;
        }

        .lyrics-container::-webkit-scrollbar {
            width: 8px;
        }

        .lyrics-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .lyrics-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .lyrics-container::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .fullscreen-lyrics-btn {
            position: absolute;
            bottom: 25px;
            right: 25px;
            background: rgba(255, 255, 255, 0.25);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            z-index: 10;
            font-weight: 600;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .fullscreen-lyrics-btn:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .lyrics-content {
            line-height: 1.8;
            text-align: center;
        }
        
        .lyric-line {
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.5);
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            cursor: pointer;
            padding: 10px 15px;
            border-radius: 12px;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-weight: 500;
        }
        
        .lyric-line.active {
            color: #fff;
            font-size: 1.2rem;
            background: rgba(255, 255, 255, 0.15);
            font-weight: 700;
            transform: scale(1.02);
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .original-text, .translation-text {
            display: inline-block;
            transition: color 0.3s ease;
        }
        .translation-text {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
            font-weight: 400;
        }
        
        .lyric-line.active .translation-text {
            color: rgba(255, 255, 255, 0.85);
        }

        .word-highlight {
            color: #ffcc00;
            transition: color 0.1s linear;
        }

        .fullscreen-lyrics-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
            display: none;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.65); 
            transition: opacity 0.5s ease;
            opacity: 0;
            touch-action: none; 
        }

        .fullscreen-lyrics-overlay.active {
            display: block;
            opacity: 1;
        }

        .fullscreen-lyrics-content {
            position: relative;
            z-index: 2;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0;
        }

        .close-fullscreen-btn {
            position: fixed;
            top: 50px;
            right: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 10000;
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .fullscreen-lyrics-lines {
            width: 100%;
            flex-grow: 1;
            padding: 0 20px 0 40px;
            margin-top: 20px;
            overflow-y: auto;
            text-align: left;
            scrollbar-width: none;
            touch-action: pan-y; 
            mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
        }
        
        .fullscreen-lyrics-lines::-webkit-scrollbar {
            display: none;
        }

        .fullscreen-lyric-line {
            font-size: clamp(2rem, 5vw, 3rem);
            line-height: 1.35;
            padding: 10px 0;
            margin: 25px 0;
            color: rgba(255, 255, 255, 0.4);
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            font-weight: 700;
            cursor: pointer;
        }
        
        .fullscreen-line-wrapper {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .fullscreen-lyric-line.active {
            color: #fff;
            font-size: clamp(2.5rem, 6vw, 3.5rem);
            font-weight: 800;
            transform: scale(1.01);
            text-shadow: 0 4px 30px rgba(0,0,0,0.4);
        }
        
        .fullscreen-translation-text {
            font-size: 0.6em;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        }
        
        .fullscreen-lyric-line.active .fullscreen-translation-text {
             color: rgba(255, 255, 255, 0.85);
        }

        .fullscreen-controls-panel {
            flex-shrink: 0;
            width: 90%;
            max-width: 600px;
            margin-bottom: 50px;
            padding: 15px 25px;
            border-radius: 40px;
        }

        .fullscreen-song-info {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .fullscreen-album-art {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            object-fit: cover;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .fullscreen-track-details {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            white-space: nowrap;
        }

        .fullscreen-song-title {
            font-size: 1.2rem;
            font-weight: 700;
            text-overflow: ellipsis;
        }

        .fullscreen-song-artist {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .fullscreen-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .fullscreen-progress {
            height: 100%;
            background: white;
            border-radius: 2px;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .fullscreen-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
        }

        .fullscreen-control-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            font-size: 2.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .fullscreen-control-btn.play {
            width: 65px;
            height: 65px;
            background: white;
            color: black;
            font-size: 2.5rem;
            padding-left: 5px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .fullscreen-control-btn:hover {
            transform: scale(1.1);
        }
        
        .fullscreen-control-btn.play:hover {
            transform: scale(1.05);
        }
        
        @media (max-width: 900px) {
            .fullscreen-lyrics-content {
                justify-content: flex-end;
                align-items: flex-start;
            }
            .fullscreen-lyrics-lines {
                margin-top: auto;
                height: 60vh;
                padding-bottom: 20px;
                padding-left: 20px;
                text-align: left;
            }
            .fullscreen-lyric-line {
                font-size: clamp(1.8rem, 5vw, 2.5rem);
            }
            .fullscreen-lyric-line.active {
                font-size: clamp(2.3rem, 6vw, 3rem);
            }
            .fullscreen-controls-panel {
                width: 95%;
                margin-bottom: 30px;
            }
            .close-fullscreen-btn {
                top: 20px;
                right: 20px;
            }
        }
        
        .search-results {
            border-radius: 20px;
            padding: 20px;
        }
        
        .results-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 15px;
            padding: 0 10px;
        }

        #resultsContainer {
            overflow: hidden;
        }
        
        .result-item {
            display: flex;
            align-items: center;
            padding: 12px 10px;
            gap: 15px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            position: relative;
            background: rgba(255, 255, 255, 0.05); 
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #resultsContainer .result-item:first-child {
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
        }
        #resultsContainer .result-item:last-child {
            border-bottom-left-radius: 15px;
            border-bottom-right-radius: 15px;
            border-bottom: none;
        }
        
        .result-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.005);
        }
        
        .result-item.active {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.005);
        }

        .result-album {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            object-fit: cover;
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .result-info {
            flex-grow: 1;
            min-width: 0;
            overflow: hidden;
        }

        .result-title {
            font-size: 1.1rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .result-artist {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .result-album-name {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 2px;
        }
        
        .result-platform-info {
            display: flex;
            gap: 8px;
            margin-top: 2px;
        }
        
        .search-results .loading {
            padding: 20px 10px;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
        }

        /* ========== è°ƒè¯•æ§åˆ¶å°æ ·å¼ ========== */
        .debug-console {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            width: 400px;
            max-height: 500px;
            background: rgba(20, 20, 20, 0.95);
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            transition: all 0.3s ease;
        }
        
        .debug-console.collapsed {
            height: auto;
        }
        
        .debug-console.expanded {
            height: 500px;
        }
        
        .debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: rgba(40, 40, 40, 0.9);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: move;
            user-select: none;
        }
        
        .debug-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .debug-controls {
            display: flex;
            gap: 5px;
        }
        
        .debug-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .debug-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .debug-btn.clear {
            color: #ff6b6b;
        }
        
        .debug-btn.clear:hover {
            background: rgba(255, 107, 107, 0.2);
        }
        
        .debug-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Courier New', Monaco, monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .debug-log {
            margin-bottom: 8px;
            padding: 8px 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.03);
            border-left: 3px solid #4dabf7;
            word-break: break-all;
            white-space: pre-wrap;
            color: #e9ecef;
        }
        
        .debug-log.error {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.08);
            color: #ffc9c9;
        }
        
        .debug-log.warning {
            border-left-color: #ffd43b;
            background: rgba(255, 212, 59, 0.08);
            color: #ffec99;
        }
        
        .debug-log.info {
            border-left-color: #4dabf7;
            background: rgba(77, 171, 247, 0.08);
            color: #c5f6fa;
        }
        
        .debug-log.success {
            border-left-color: #51cf66;
            background: rgba(81, 207, 102, 0.08);
            color: #b2f2bb;
        }
        
        .debug-log.api {
            border-left-color: #9775fa;
            background: rgba(151, 117, 250, 0.08);
            color: #d0bfff;
        }
        
        .debug-timestamp {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 2px;
        }
        
        .debug-message {
            margin-top: 2px;
        }
        
        .debug-toggle-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            width: 50px;
            height: 50px;
            border-radius: 25px;
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        .debug-toggle-btn:hover {
            background: rgba(60, 60, 60, 0.9);
            transform: scale(1.05);
        }
        
        .debug-toggle-btn.hidden {
            display: none;
        }
        
        .debug-console.hidden {
            display: none;
        }
        
        /* æ»šåŠ¨æ¡æ ·å¼ */
        .debug-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .debug-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        .debug-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }
        
        .debug-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        @media (max-width: 600px) {
            .debug-console {
                width: 95%;
                right: 2.5%;
                bottom: 80px;
                max-height: 300px;
            }
            
            .debug-console.expanded {
                height: 300px;
            }
            
            .result-item {
                padding: 10px;
            }
        }

        @media (max-width: 600px) {
            .result-item {
                padding: 10px;
            }
        }
    </style>

<style>

    /* =========================================================
       å¤šèƒŒæ™¯ç³»ç»Ÿï¼ˆé›†æˆç‰ˆï¼‰
       æ–¹æ¡ˆAï¼šæŠ˜å å¼æ§åˆ¶é¢æ¿ï¼ˆä¸å ç”¨åŸæ§åˆ¶åŒºç©ºé—´ï¼‰
       ========================================================= */

    /* èƒŒæ™¯å®¿ä¸»å±‚ï¼šç”¨äºæŒ‚è½½ Pixi / Mesh çš„ç”»å¸ƒ */
    #bgHost {
        position: fixed;
        inset: 0;
        z-index: -1;
        pointer-events: none; /* å…³é”®ï¼šç¡®ä¿å–è‰²/ç‚¹å‡»/æ»šåŠ¨ç­‰äº¤äº’ä¸è¢«èƒŒæ™¯æ‹¦æˆª */
        overflow: hidden;
        /* PixièƒŒæ™¯åŸç‰ˆç”¨äºé¿å…åŠ è½½å‰é»‘å±çš„å¾„å‘æ¸å˜ï¼Œè¿™é‡Œä½œä¸ºç»Ÿä¸€å…œåº• */
        background: radial-gradient(circle at center, rgba(255,107,107,0.55) 0%, rgba(78,205,196,0.45) 30%, rgba(69,183,209,0.35) 60%, rgba(150,206,180,0.30) 100%);
        /* Fix: é»˜è®¤éšè— bgHostï¼Œåªåœ¨åˆ‡æ¢åˆ° pixi/mesh èƒŒæ™¯æ—¶æ˜¾ç¤ºï¼Œé¿å…è¦†ç›– gradientCanvas */
        display: none;
    }
    #bgHost .bg-layer {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
    }
    #bgHost canvas {
        width: 100%;
        height: 100%;
        display: block;
        pointer-events: none;
    }

    /* ç¡®ä¿é»˜è®¤æ¸å˜èƒŒæ™¯ç”»å¸ƒä¸æ‹¦æˆªäº¤äº’ */
    #gradientCanvas { pointer-events: none; }

    /* èƒŒæ™¯æ§åˆ¶é¢æ¿ï¼šæµ®åŠ¨æŒ‰é’®ï¼ˆå·¦ä¸‹è§’ï¼‰ */
    #bgToggleBtn {
        position: fixed;
        left: calc(16px + env(safe-area-inset-left));
        bottom: calc(16px + env(safe-area-inset-bottom));
        z-index: 9999;

        width: 44px;
        height: 44px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.25);

        color: #fff;
        background: rgba(255,255,255,0.12);
        box-shadow: 0 10px 30px rgba(0,0,0,0.25);
        -webkit-backdrop-filter: blur(18px) saturate(180%);
        backdrop-filter: blur(18px) saturate(180%);
        cursor: pointer;
        user-select: none;
        transition: transform 0.15s ease, background 0.15s ease;
    }
    #bgToggleBtn:hover { transform: translateY(-1px); background: rgba(255,255,255,0.16); }
    #bgToggleBtn:active { transform: translateY(0px) scale(0.99); }

    /* èƒŒæ™¯é¢æ¿ä¸»ä½“ */
    #bgPanel {
        position: fixed;
        left: calc(16px + env(safe-area-inset-left));
        bottom: calc(68px + env(safe-area-inset-bottom));
        z-index: 9998;

        width: min(360px, calc(100vw - 32px));
        max-height: min(72vh, 640px);
        overflow: hidden;

        border-radius: 16px;
        border: 1px solid rgba(255,255,255,0.22);
        background: rgba(255,255,255,0.10);
        box-shadow: 0 16px 40px rgba(0,0,0,0.30);
        -webkit-backdrop-filter: blur(18px) saturate(180%);
        backdrop-filter: blur(18px) saturate(180%);

        display: none;
    }
    #bgPanel.show { display: block; }

    .bg-panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;

        padding: 12px 12px 10px 12px;
        border-bottom: 1px solid rgba(255,255,255,0.18);
        cursor: move; /* æ”¯æŒæ‹–æ‹½ */
        user-select: none;
    }

    .bg-panel-title {
        display: flex;
        align-items: center;
        gap: 8px;
        color: #fff;
        font-weight: 700;
        font-size: 14px;
    }

    .bg-badge {
        display: inline-flex;
        align-items: center;
        padding: 3px 8px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        color: #fff;
        background: rgba(0,0,0,0.25);
        border: 1px solid rgba(255,255,255,0.20);
    }

    .bg-panel-actions { display: flex; gap: 8px; }
    .bg-panel-actions button {
        width: 30px;
        height: 30px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.20);
        background: rgba(0,0,0,0.18);
        color: #fff;
        cursor: pointer;
        transition: background 0.15s ease;
    }
    .bg-panel-actions button:hover { background: rgba(0,0,0,0.28); }

    .bg-panel-body {
        padding: 12px;
        overflow: auto;
        max-height: calc(min(72vh, 640px) - 52px);
    }

    .bg-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
    }

    .bg-main-btn {
        padding: 10px 14px;
        border: none;
        border-radius: 12px;
        background: rgba(255,255,255,0.16);
        color: #fff;
        cursor: pointer;
        font-weight: 700;
        transition: background 0.15s ease, transform 0.15s ease;
    }
    .bg-main-btn:hover { background: rgba(255,255,255,0.22); transform: translateY(-1px); }
    .bg-main-btn:active { transform: translateY(0px) scale(0.99); }

    .bg-checkbox {
        display: flex;
        align-items: center;
        gap: 8px;
        color: rgba(255,255,255,0.95);
        font-size: 13px;
        user-select: none;
        cursor: pointer;
    }
    .bg-checkbox input { width: 18px; height: 18px; cursor: pointer; }

    .bg-sep {
        height: 1px;
        background: rgba(255,255,255,0.16);
        margin: 10px 0 12px 0;
    }

    .bg-hint {
        color: rgba(255,255,255,0.85);
        font-size: 12px;
        line-height: 1.45;
        padding: 10px;
        border-radius: 12px;
        border: 1px dashed rgba(255,255,255,0.18);
        background: rgba(0,0,0,0.10);
    }

    /* èƒŒæ™¯ä¸“ç”¨æ§åˆ¶åŒºï¼šå¤ç”¨åŸæ§ä»¶è¯­ä¹‰ï¼Œä½†ç»Ÿä¸€æˆâ€œæ¶²æ€ç»ç’ƒâ€é£æ ¼ */
    .bg-controls .control-group-title {
        color: rgba(255,255,255,0.95);
        font-weight: 800;
        font-size: 13px;
        margin: 8px 0 10px 0;
    }
    .bg-controls .bg-ctrl-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
    }
    .bg-controls label {
        color: rgba(255,255,255,0.92);
        font-size: 13px;
        user-select: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .bg-controls input[type="range"] { width: 160px; }
    .bg-controls input[type="text"] {
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.22);
        background: rgba(0,0,0,0.18);
        color: #fff;
        outline: none;
    }
    .bg-controls .bg-file-btn,
    .bg-controls button {
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.22);
        background: rgba(0,0,0,0.18);
        color: #fff;
        cursor: pointer;
        transition: background 0.15s ease;
    }
    .bg-controls .bg-file-btn:hover,
    .bg-controls button:hover { background: rgba(0,0,0,0.28); }
    .bg-controls .bg-file-name {
        color: rgba(255,255,255,0.75);
        font-size: 12px;
        word-break: break-all;
        line-height: 1.35;
    }
    .bg-controls .bg-subtle {
        color: rgba(255,255,255,0.75);
        font-size: 12px;
    }

    /* å°å±é€‚é…ï¼šé¢æ¿é åº•éƒ¨ã€å®½åº¦é“ºæ»¡ï¼Œé¿å…ä¸æ’­æ”¾å™¨æ§ä»¶é‡å  */
    @media (max-width: 680px) {
        #bgPanel {
            left: calc(12px + env(safe-area-inset-left));
            right: calc(12px + env(safe-area-inset-right));
            width: auto;
            bottom: calc(64px + env(safe-area-inset-bottom));
            max-height: 62vh;
        }
        #bgToggleBtn {
            left: calc(12px + env(safe-area-inset-left));
            bottom: calc(12px + env(safe-area-inset-bottom));
        }
        .bg-controls input[type="range"] { width: 100%; }
    }

</style>

<style id="ios-pwa-fixes">
/* =========================================================
   Fix: iOS / å…¨å¹³å°å…¼å®¹å¢å¼ºï¼ˆä»…åšæ·»åŠ /å®‰å…¨è¦†ç›–ï¼‰
   ========================================================= */

/* Fix: è®©æ»šåŠ¨å®¹å™¨åœ¨ iOS ä¸Šå…·å¤‡æƒ¯æ€§æ»šåŠ¨ä½“éªŒ */
.lyrics-container,
.fullscreen-lyrics-lines,
.bg-panel-body,
.debug-content {
    -webkit-overflow-scrolling: touch;
}

/* Fix: å®‰å…¨åŒºåŸŸï¼ˆåˆ˜æµ·å±/åœ†è§’å±ï¼‰é€‚é… */
body {
    padding-top: calc(20px + env(safe-area-inset-top));
    padding-left: calc(20px + env(safe-area-inset-left));
    padding-right: calc(20px + env(safe-area-inset-right));
    padding-bottom: calc(20px + env(safe-area-inset-bottom));
}

/* Fix: ä½¿ç”¨ --vh æ›¿ä»£ 100vhï¼ˆé…åˆ head å†… setVhVar è„šæœ¬ï¼‰ */
:root { --vh: 1vh; }
body { min-height: calc(var(--vh, 1vh) * 100); }
.fullscreen-lyrics-overlay { height: calc(var(--vh, 1vh) * 100); }
#gradientCanvas, #bgHost { height: calc(var(--vh, 1vh) * 100); }

/* Fix: å…¨å±å…³é—­æŒ‰é’®é¿å¼€é¡¶éƒ¨å®‰å…¨åŒº */
.close-fullscreen-btn {
    top: calc(20px + env(safe-area-inset-top));
    right: calc(20px + env(safe-area-inset-right));
}
@media (max-width: 900px) {
    .close-fullscreen-btn {
        top: calc(12px + env(safe-area-inset-top));
        right: calc(12px + env(safe-area-inset-right));
    }
}
</style>


<script>
  // âœ…TuneHubï¼šsearch ç›´è¿ï¼›url/pic/lrc èµ°åç«¯ï¼ˆè§£å†³ flac24bit / é˜²ç›—é“¾ / è·¨åŸŸï¼‰
  const __TUNEHUB_DIRECT = "https://music-dl.sayqz.com/api/";
  const __TUNEHUB_PROXY  = "/api/"; // Functions: functions/api/index.ts

  function __tunehubBaseFor(params){
    const t = String(params?.types || params?.type || '').toLowerCase();
    if (t === 'search') return __TUNEHUB_DIRECT;
    // æ’­æ”¾é“¾æ¥/å°é¢/æ­Œè¯ éƒ½èµ°åç«¯
    if (t === 'url' || t === 'pic' || t === 'lrc' || t === 'lyric') return __TUNEHUB_PROXY;
    return __TUNEHUB_PROXY;
  }

  // é…·æˆ‘ç›´é“¾å›¾ç‰‡ï¼ˆkuwo.cnï¼‰é˜²ç›—é“¾ï¼šèµ° /api.php?target=
  function __wrapKuwoIfNeeded(u){
    try{
      const url = new URL(u, location.origin);
      const host = url.hostname || '';
      // âœ…ä½ æŠ¥é”™çš„ img1.kwcdn.kuwo.cn ä¹ŸåŒ…å«åœ¨è¿™é‡Œ
      if (/((\.|^)kuwo\.cn$|(\.|^)kwcdn\.kuwo\.cn$)/i.test(host)) {
        // âœ…å¼ºåˆ¶ httpï¼šé¿å… Kuwo https 514ï¼›å¹¶ä¸”é¿å… https é¡µé¢ç›´è¿è¢«æ‹¦æˆªï¼Œç»Ÿä¸€èµ°åç«¯
        url.protocol = 'http:';
        return '/api.php?target=' + encodeURIComponent(url.toString());
      }
      return u;
    }catch(e){
      return u;
    }
  }
</script>

</head>
<body>
    <canvas id="gradientCanvas"></canvas>
    <div id="bgHost" aria-hidden="true"></div>

    <div class="container">
        <div class="header liquid-glass-effect">
            <h1>éŸ³ä¹æ’­æ”¾å™¨</h1>
        </div>
        
        <div class="search-section">
            <div class="search-box">
                <input type="text" class="search-input" id="searchInput" placeholder="æœç´¢æ­Œæ›²ã€æ­Œæ‰‹æˆ–ä¸“è¾‘..." value="å‘¨æ°ä¼¦">
            </div>
            <!-- æ–°å¢ï¼šAPIé€‰æ‹©å™¨ -->
            <select class="api-select" id="apiSelect" title="é€‰æ‹©APIæ¥å£æº">
                <option value="gdstudio" selected>åŸAPI (GDStudio)</option>
                <option value="tunehub">å¤‡ç”¨API (TuneHub)</option>
            </select>
                        <button class="algo-toggle-btn" id="algoToggleBtn" title="åˆ‡æ¢ä¸“è¾‘å°é¢é¢œè‰²æå–ç®—æ³•">ç®—æ³•ï¼šåŸ(ä¸­ä½åˆ‡åˆ†)</button>
<select class="source-select" id="sourceSelect">
                <option value="kuwo" selected>é…·æˆ‘éŸ³ä¹</option>
                <option value="joox">JOOXéŸ³ä¹</option>
                <option value="netease">ç½‘æ˜“äº‘éŸ³ä¹</option>
                <!-- TuneHub APIä¸“ç”¨é€‰é¡¹ -->
                <option value="qq">QQéŸ³ä¹ (ä»…TuneHub)</option>
                <option value="aggregate">èšåˆæœç´¢ (ä»…TuneHub)</option>
            </select>
            <button class="search-btn" id="searchBtn">æœç´¢</button>
        </div>
        
        <div class="player-container">
            <div class="now-playing liquid-glass-effect">
                
                <div class="speed-control">
                    <span>é€Ÿåº¦</span>
                    <input type="range" id="speedSlider" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>

                <div class="album-art-placeholder">â™ª</div>
                <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==" alt="ä¸“è¾‘å°é¢" class="album-art" id="albumArt">
                <div class="song-info">
                    <h2 class="song-title" id="songTitle">è¯·é€‰æ‹©æ­Œæ›²</h2>
                    <p class="song-artist" id="songArtist">æœªçŸ¥è‰ºæœ¯å®¶</p>
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar">
                        <div class="progress" id="progress"></div>
                        <div class="progress-handle" id="progressHandle"></div>
                    </div>
                    <div class="time-info">
                        <span id="currentTime">0:00</span>
                        <span id="duration">0:00</span>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="control-btn" id="prevBtn">â®</button>
                    <button class="control-btn play-btn" id="playBtn">â–¶</button>
                    <button class="control-btn" id="nextBtn">â­</button>
                </div>
                
                <select class="quality-select" id="qualitySelect">
                    <option value="128">æ ‡å‡†å“è´¨ (128k)</option>
                    <option value="192">è‰¯å¥½å“è´¨ (192k)</option>
                    <option value="320">é«˜å“è´¨ (320k)</option>
                    <option value="740">æ— æŸå“è´¨ (740k)</option>
                    <option value="999" selected>é«˜è§£æåº¦ (999k)</option>
                </select>
            </div>
            
            <div class="lyrics-container liquid-glass-effect" id="lyricsContainer">
                <h3 class="lyrics-title">æ­Œè¯</h3>
                <div class="lyrics-content" id="lyricsContent">
                    <div class="loading">æš‚æ— æ­Œè¯</div>
                </div>
                <button class="fullscreen-lyrics-btn" id="fullscreenLyricsBtn">
                    <span>â›¶</span> å…¨å±æ²‰æµ¸æ¨¡å¼
                </button>
            </div>
        </div>
        
        <div class="search-results liquid-glass-effect">
            <h3 class="results-title">æœç´¢ç»“æœ</h3>
            <div id="resultsContainer">
                <div class="loading">ç‚¹å‡»æœç´¢æŒ‰é’®å¼€å§‹æœç´¢éŸ³ä¹</div>
            </div>
        </div>
    </div>

    <div class="fullscreen-lyrics-overlay" id="fullscreenLyricsOverlay">
        <button class="close-fullscreen-btn" id="closeFullscreenBtn">âœ•</button>
        
        <div class="fullscreen-lyrics-content">
            <div class="fullscreen-lyrics-lines" id="fullscreenLyricsLines">
                <div class="loading">æš‚æ— æ­Œè¯</div>
            </div>

            <div class="fullscreen-controls-panel liquid-glass-effect">
                
                <div class="fullscreen-song-info">
                    <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==" alt="ä¸“è¾‘å°é¢" class="fullscreen-album-art" id="fullscreenAlbumArt">
                    <div class="fullscreen-track-details">
                        <div class="fullscreen-song-title" id="fullscreenSongTitle">æ­Œæ›²åç§°</div>
                        <div class="fullscreen-song-artist" id="fullscreenSongArtist">è‰ºæœ¯å®¶</div>
                    </div>
                </div>
                
                <div class="fullscreen-progress-bar" id="fullscreenProgressBar">
                    <div class="fullscreen-progress" id="fullscreenProgress"></div>
                </div>
                
                <div class="fullscreen-controls">
                    <button class="fullscreen-control-btn" id="fullscreenPrevBtn">â®</button>
                    <button class="fullscreen-control-btn play" id="fullscreenPlayBtn">â–¶</button>
                    <button class="fullscreen-control-btn" id="fullscreenNextBtn">â­</button>
                </div>
            </div>
        </div>
    </div>

    <!-- è°ƒè¯•æ§åˆ¶å° -->
    <button class="debug-toggle-btn" id="debugToggleBtn">ğŸ›</button>
    
    <div class="debug-console hidden" id="debugConsole">
        <div class="debug-header">
            <div class="debug-title">
                <span>ğŸ”§ è°ƒè¯•æ§åˆ¶å°</span>
            </div>
            <div class="debug-controls">
                <button class="debug-btn clear" id="debugClearBtn" title="æ¸…ç©ºæ—¥å¿—">ğŸ—‘ï¸</button>
                <button class="debug-btn" id="debugMinimizeBtn" title="æœ€å°åŒ–">âˆ’</button>
                <button class="debug-btn" id="debugCloseBtn" title="å…³é—­">âœ•</button>
            </div>
        </div>
        <div class="debug-content" id="debugContent">
            <div class="debug-log info">
                <div class="debug-timestamp">ç³»ç»Ÿå¯åŠ¨</div>
                <div class="debug-message">è°ƒè¯•æ§åˆ¶å°å·²åˆå§‹åŒ–ï¼Œç­‰å¾…æ“ä½œ...</div>
            </div>
        </div>
    </div>

    
    <!-- =============================
         å¤šèƒŒæ™¯ç³»ç»Ÿ - æŠ˜å å¼æ§åˆ¶é¢æ¿ï¼ˆå·¦ä¸‹è§’ï¼‰
         è¯´æ˜ï¼šé¿å…åœ¨åŸæœç´¢/æ’­æ”¾æ§åˆ¶åŒºå †å æ§ä»¶
         ============================= -->
    <button id="bgToggleBtn" title="èƒŒæ™¯æ§åˆ¶é¢æ¿">ğŸ¨</button>

    <div id="bgPanel" role="dialog" aria-label="èƒŒæ™¯æ§åˆ¶é¢æ¿">
        <div class="bg-panel-header" id="bgPanelHeader">
            <div class="bg-panel-title">
                <span>ğŸ¨ èƒŒæ™¯æ§åˆ¶</span>
                <span class="bg-badge" id="bgStatusBadge">é»˜è®¤</span>
            </div>
            <div class="bg-panel-actions">
                <button id="bgPanelMinBtn" title="æœ€å°åŒ–">â€”</button>
                <button id="bgPanelCloseBtn" title="å…³é—­">âœ•</button>
            </div>
        </div>

        <div class="bg-panel-body">
            <div class="bg-row">
                <button class="bg-main-btn" id="bgSwitchBtn" title="å¾ªç¯åˆ‡æ¢èƒŒæ™¯ï¼šé»˜è®¤ â†’ PixiåŠ¨æ€ â†’ Meshæ¸å˜">åˆ‡æ¢èƒŒæ™¯</button>
                <label class="bg-checkbox" title="å¼€å¯åï¼šåˆ‡æ­Œ/æ¢å°é¢æ—¶ï¼ŒèƒŒæ™¯è‡ªåŠ¨æ›´æ–°">
                    <input type="checkbox" id="bgFollowAlbum" checked>
                    è·Ÿéšä¸“è¾‘å°é¢
                </label>
            </div>

            <div class="bg-sep"></div>

            <div class="bg-controls" id="bgControlsMount">
                <div class="bg-hint">
                    å½“å‰èƒŒæ™¯æ— é¢å¤–æ§åˆ¶é¡¹ã€‚<br>
                    æç¤ºï¼šåˆ‡æ¢åˆ° Pixi / Mesh èƒŒæ™¯åï¼Œè¿™é‡Œä¼šå‡ºç°å¯¹åº”çš„å®Œæ•´æ§åˆ¶é¢æ¿ã€‚
                </div>
            </div>
        </div>
    </div>

    <audio id="audioPlayer" playsinline webkit-playsinline preload="metadata"></audio>

    <script>
        // ========== è°ƒè¯•æ§åˆ¶å°ç³»ç»Ÿ ==========
        // ä¿æŒåŸæœ‰çš„è°ƒè¯•æ§åˆ¶å°é€»è¾‘ï¼Œä½†å»¶è¿Ÿåˆå§‹åŒ–
        let debugConsole = null;
        
        function initDebugConsole() {
            if (document.getElementById('debugConsole') && !debugConsole) {
                class DebugConsole {
                    constructor() {
                        this.consoleElement = document.getElementById('debugConsole');
                        this.contentElement = document.getElementById('debugContent');
                        this.toggleBtn = document.getElementById('debugToggleBtn');
                        this.clearBtn = document.getElementById('debugClearBtn');
                        this.minimizeBtn = document.getElementById('debugMinimizeBtn');
                        this.closeBtn = document.getElementById('debugCloseBtn');
                        this.isExpanded = true;
                        this.isVisible = false;
                        this.logCount = 0;
                        this.maxLogs = 100;
                        
                        this.init();
                    }
                    
                    init() {
                        // ç»‘å®šäº‹ä»¶
                        this.toggleBtn.addEventListener('click', () => this.toggleVisibility());
                        this.clearBtn.addEventListener('click', () => this.clearLogs());
                        this.minimizeBtn.addEventListener('click', () => this.toggleSize());
                        this.closeBtn.addEventListener('click', () => this.hide());
                        
                        // åˆå§‹çŠ¶æ€
                        this.consoleElement.classList.add('expanded');
                        
                        this.log('ç³»ç»Ÿ', 'è°ƒè¯•æ§åˆ¶å°åˆå§‹åŒ–å®Œæˆ', 'info');
                    }
                    
                    toggleVisibility() {
                        this.isVisible = !this.isVisible;
                        if (this.isVisible) {
                            this.show();
                        } else {
                            this.hide();
                        }
                    }
                    
                    show() {
                        this.consoleElement.classList.remove('hidden');
                        this.toggleBtn.classList.add('hidden');
                        this.isVisible = true;
                        this.log('ç³»ç»Ÿ', 'è°ƒè¯•æ§åˆ¶å°å·²æ‰“å¼€', 'info');
                    }
                    
                    hide() {
                        this.consoleElement.classList.add('hidden');
                        this.toggleBtn.classList.remove('hidden');
                        this.isVisible = false;
                    }
                    
                    toggleSize() {
                        this.isExpanded = !this.isExpanded;
                        if (this.isExpanded) {
                            this.consoleElement.classList.remove('collapsed');
                            this.consoleElement.classList.add('expanded');
                            this.minimizeBtn.textContent = 'âˆ’';
                            this.minimizeBtn.title = 'æœ€å°åŒ–';
                        } else {
                            this.consoleElement.classList.remove('expanded');
                            this.consoleElement.classList.add('collapsed');
                            this.minimizeBtn.textContent = 'â–¡';
                            this.minimizeBtn.title = 'æœ€å¤§åŒ–';
                        }
                    }
                    
                    clearLogs() {
                        this.contentElement.innerHTML = '';
                        this.logCount = 0;
                        this.log('ç³»ç»Ÿ', 'æ—¥å¿—å·²æ¸…ç©º', 'info');
                    }
                    
                    log(category, message, type = 'info') {
                        this.logCount++;
                        
                        // é™åˆ¶æ—¥å¿—æ•°é‡
                        if (this.logCount > this.maxLogs) {
                            const logs = this.contentElement.querySelectorAll('.debug-log');
                            if (logs.length > this.maxLogs) {
                                logs[0].remove();
                            }
                        }
                        
                        const timestamp = new Date().toLocaleTimeString('zh-CN', {
                            hour12: false,
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                        
                        const logElement = document.createElement('div');
                        logElement.className = `debug-log ${type}`;
                        
                        logElement.innerHTML = `
                            <div class="debug-timestamp">[${timestamp}] [${category}]</div>
                            <div class="debug-message">${this.escapeHtml(message)}</div>
                        `;
                        
                        this.contentElement.appendChild(logElement);
                        
                        // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ RAF å»¶è¿Ÿæ»šåŠ¨ï¼Œé¿å…è¯»å†™äº¤é”™å¯¼è‡´çš„å¼ºåˆ¶å›æµ
                        requestAnimationFrame(() => {
                            this.contentElement.scrollTop = this.contentElement.scrollHeight;
                        });
                    }
                    
                    error(category, message) {
                        this.log(category, message, 'error');
                    }
                    
                    warn(category, message) {
                        this.log(category, message, 'warning');
                    }
                    
                    info(category, message) {
                        this.log(category, message, 'info');
                    }
                    
                    success(category, message) {
                        this.log(category, message, 'success');
                    }
                    
                    api(category, message) {
                        this.log(category, message, 'api');
                    }
                    
                    escapeHtml(text) {
                        const div = document.createElement('div');
                        div.textContent = text;
                        return div.innerHTML;
                    }
                }
                
                debugConsole = new DebugConsole();
            }
        }

        // ========== åŠ¨æ€ç½‘æ ¼æ¸å˜ç³»ç»Ÿ ==========
        const canvas = document.getElementById('gradientCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        
        let gradientPoints = [];
        let animationId = null;
        let lastTime = 0;
        let ANIMATION_SPEED_MULTIPLIER = 1.0; 
        
        // é»˜è®¤é…è‰²æ–¹æ¡ˆ
        const defaultPalette = [
            { r: 11,  g: 11,  b: 11  },   // #0B0B0B æ·±åŸºè‰²
            { r: 146, g: 30,  b: 88  },   // #921E58 éœ“è™¹ç«ç´«
            { r: 25,  g: 137, b: 250 },   // #1989FA éœ“è™¹è“
            { r: 156, g: 39,  b: 176 }    // #9C27B0 éœ“è™¹ç´«
        ];

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // åˆå§‹åŒ– 6x6 ç½‘æ ¼ç‚¹
        function initGradientPoints(colors = null) {
            gradientPoints = [];
            const cols = 6;
            const rows = 6;
            const width = canvas.width;
            const height = canvas.height;
            const cellW = width / cols;
            const cellH = height / rows;
            const palette = colors && colors.length > 0 ? colors : defaultPalette;

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const baseX = j * cellW + cellW / 2;
                    const baseY = i * cellH + cellH / 2;
                    
                    const colorIdx = (i * cols + j) % palette.length;
                    const initialColor = palette[colorIdx];

                    gradientPoints.push({
                        x: baseX,
                        y: baseY,
                        baseX: baseX,
                        baseY: baseY,
                        color: { ...initialColor },
                        targetColor: { ...initialColor },

                        rangeX: cellW * 1.5,
                        rangeY: cellH * 1.5,
                        phaseX: Math.random() * Math.PI * 2,
                        phaseY: Math.random() * Math.PI * 2,
                        speedX: (0.0001 + Math.random() * 0.0003) * (Math.random() > 0.5 ? 1 : -1),
                        speedY: (0.0001 + Math.random() * 0.0003) * (Math.random() > 0.5 ? 1 : -1),
                        
                        radiusBase: Math.max(width, height) * 0.35, 
                        radiusPhase: Math.random() * Math.PI * 2,
                        radiusSpeed: 0.0005 + Math.random() * 0.0005,
                        
                        phaseZ: Math.random() * Math.PI * 2,
                        speedZ: 0.001 + Math.random() * 0.0015
                    });
                }
            }
        }

        // æ ¸å¿ƒæ¸²æŸ“å¾ªç¯
        function animate(time) {
            if (!lastTime) lastTime = time;
            const deltaTime = time - lastTime;
            lastTime = time;

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-over';

            gradientPoints.forEach(p => {
                const speed = ANIMATION_SPEED_MULTIPLIER;
                p.phaseX += p.speedX * deltaTime * speed;
                p.phaseY += p.speedY * deltaTime * speed;
                p.radiusPhase += p.radiusSpeed * deltaTime * speed;
                p.phaseZ += p.speedZ * deltaTime * speed;

                p.x = p.baseX + Math.sin(p.phaseX) * p.rangeX / 3 + Math.sin(p.phaseZ) * p.rangeX / 6;
                p.y = p.baseY + Math.cos(p.phaseY) * p.rangeY / 3 + Math.cos(p.phaseZ) * p.rangeY / 6;

                const ease = 0.015;
                p.color.r += (p.targetColor.r - p.color.r) * ease;
                p.color.g += (p.targetColor.g - p.color.g) * ease;
                p.color.b += (p.targetColor.b - p.color.b) * ease;

                const currentRadius = p.radiusBase + Math.sin(p.radiusPhase) * (p.radiusBase * 0.1);
                
                const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, currentRadius);
                
                const r = Math.round(p.color.r);
                const gVal = Math.round(p.color.g);
                const b = Math.round(p.color.b);
                
                g.addColorStop(0, `rgba(${r}, ${gVal}, ${b}, 0.8)`);
                g.addColorStop(0.3, `rgba(${r}, ${gVal}, ${b}, 0.5)`);
                g.addColorStop(1, `rgba(${r}, ${gVal}, ${b}, 0)`);

                ctx.fillStyle = g;
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
            });

            animationId = requestAnimationFrame(animate);
        }

        // ========== å®Œæ•´ç‰ˆé¢œè‰²é‡åŒ–ç®—æ³•ï¼ˆä¸­ä½åˆ‡åˆ†æ³• / K-meansï¼‰ ==========
        function extractMainColors(img) {
            try {
                if (debugConsole) debugConsole.log('é¢œè‰²æå–', 'å¼€å§‹æå–ä¸“è¾‘å°é¢ä¸»è¦é¢œè‰²...', 'info');
                
                // åˆ›å»ºCanvaså¤„ç†å›¾åƒ
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // è®¾ç½®Canvaså°ºå¯¸ï¼ˆé€‚å½“ç¼©å°ä»¥æé«˜æ€§èƒ½ï¼‰
                const maxSize = 200;
                let width = img.width;
                let height = img.height;
                
                if (width > maxSize || height > maxSize) {
                    const scale = maxSize / Math.max(width, height);
                    width = Math.floor(width * scale);
                    height = Math.floor(height * scale);
                }
                
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);
                
                // è·å–å›¾åƒæ•°æ®
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                // æ”¶é›†æ‰€æœ‰åƒç´ é¢œè‰²
                const pixels = [];
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    // å¿½ç•¥å®Œå…¨é€æ˜æˆ–æ¥è¿‘é€æ˜çš„åƒç´ 
                    if (data[i + 3] < 50) continue;
                    
                    pixels.push({ r, g, b });
                }
                
                if (pixels.length === 0) {
                    if (debugConsole) debugConsole.warn('é¢œè‰²æå–', 'æœªæå–åˆ°æœ‰æ•ˆåƒç´ é¢œè‰²ï¼Œä½¿ç”¨é»˜è®¤é…è‰²æ–¹æ¡ˆ');
                    return defaultPalette;
                }
                
                if (debugConsole) debugConsole.log('é¢œè‰²æå–', `æˆåŠŸé‡‡é›† ${pixels.length} ä¸ªåƒç´ ç‚¹é¢œè‰²`, 'success');
                

                // æ ¹æ®é€‰æ‹©çš„ç®—æ³•æå–é¢œè‰²
                const colorCount = 12; // éœ€è¦æå–çš„é¢œè‰²æ•°é‡
                let colors = [];

                if (COLOR_EXTRACTION_ALGO === 'kmeans') {
                    // K-meansèšç±»æå–é¢œè‰²
                    colors = kMeansQuantize(pixels, colorCount, 10);
                    if (debugConsole) debugConsole.log('é¢œè‰²æå–', `K-means æå–åˆ° ${colors.length} ç§ä¸»è¦é¢œè‰²`, 'success');
                } else {
                    // åŸç®—æ³•ï¼šä¸­ä½åˆ‡åˆ†æ³•æå–é¢œè‰²
                    const buckets = medianCut(pixels, colorCount);

                    // è®¡ç®—æ¯ä¸ªbucketçš„å¹³å‡é¢œè‰²
                    colors = buckets.map(bucket => {
                        let r = 0, g = 0, b = 0;
                        const count = bucket.length;

                        for (let i = 0; i < count; i++) {
                            r += bucket[i].r;
                            g += bucket[i].g;
                            b += bucket[i].b;
                        }

                        return {
                            r: Math.round(r / count),
                            g: Math.round(g / count),
                            b: Math.round(b / count)
                        };
                    });

                    if (debugConsole) debugConsole.log('é¢œè‰²æå–', `ä¸­ä½åˆ‡åˆ†æ³•æˆåŠŸæå– ${colors.length} ç§ä¸»è¦é¢œè‰²`, 'success');
                }

                if (debugConsole) debugConsole.log('é¢œè‰²æå–', `æå–çš„é¢œè‰²: ${JSON.stringify(colors)}`, 'info');

                return colors;
            } catch (error) {
                if (debugConsole) debugConsole.error('é¢œè‰²æå–', `é¢œè‰²æå–è¿‡ç¨‹å‡ºç°å¼‚å¸¸: ${error.message}\nå †æ ˆ: ${error.stack}`);
                return defaultPalette;
            }
        }



// K-meansèšç±»æå–ä¸»è¦é¢œè‰²
function kMeansQuantize(pixels, k = 12, maxIter = 10) {
    // ä¸ºæ€§èƒ½æ§åˆ¶ï¼šæœ€å¤šé‡‡æ ·çº¦8000ä¸ªåƒç´ 
    const maxSamples = 8000;
    let samples = pixels;
    if (pixels.length > maxSamples) {
        const stride = Math.ceil(pixels.length / maxSamples);
        samples = [];
        for (let i = 0; i < pixels.length; i += stride) {
            samples.push(pixels[i]);
        }
    }

    // éšæœºåˆå§‹åŒ–èšç±»ä¸­å¿ƒ
    const centroids = [];
    for (let i = 0; i < k; i++) {
        const p = samples[Math.floor(Math.random() * samples.length)];
        centroids.push({ r: p.r, g: p.g, b: p.b });
    }

    const assignments = new Array(samples.length).fill(-1);
    let counts = new Array(k).fill(0);

    for (let iter = 0; iter < maxIter; iter++) {
        const sumR = new Array(k).fill(0);
        const sumG = new Array(k).fill(0);
        const sumB = new Array(k).fill(0);
        counts = new Array(k).fill(0);

        let changed = false;

        for (let i = 0; i < samples.length; i++) {
            const p = samples[i];
            let best = 0;
            let bestDist = Infinity;

            for (let c = 0; c < k; c++) {
                const dr = p.r - centroids[c].r;
                const dg = p.g - centroids[c].g;
                const db = p.b - centroids[c].b;
                const dist = dr * dr + dg * dg + db * db;
                if (dist < bestDist) {
                    bestDist = dist;
                    best = c;
                }
            }

            if (assignments[i] !== best) {
                changed = true;
                assignments[i] = best;
            }

            counts[best]++;
            sumR[best] += p.r;
            sumG[best] += p.g;
            sumB[best] += p.b;
        }

        // æ›´æ–°èšç±»ä¸­å¿ƒ
        for (let c = 0; c < k; c++) {
            if (counts[c] > 0) {
                centroids[c].r = sumR[c] / counts[c];
                centroids[c].g = sumG[c] / counts[c];
                centroids[c].b = sumB[c] / counts[c];
            } else {
                // ç©ºç°‡é‡æ–°éšæœºåˆå§‹åŒ–
                const p = samples[Math.floor(Math.random() * samples.length)];
                centroids[c] = { r: p.r, g: p.g, b: p.b };
            }
        }

        if (!changed) break;
    }

    // æŒ‰ç°‡å¤§å°æ’åºï¼ˆæ›´â€œä¸»è‰²â€ä¼˜å…ˆï¼‰
    const items = centroids.map((c, idx) => ({
        r: Math.round(c.r),
        g: Math.round(c.g),
        b: Math.round(c.b),
        count: counts[idx] || 0
    })).sort((a, b) => b.count - a.count);

    return items.map(({ r, g, b }) => ({ r, g, b }));
}

        // ä¸­ä½åˆ‡åˆ†æ³•å®ç°
        function medianCut(pixels, targetColors) {
            // åˆå§‹åŒ–ä¸€ä¸ªbucketåŒ…å«æ‰€æœ‰åƒç´ 
            let buckets = [pixels];
            
            // æŒç»­åˆ‡åˆ†ç›´åˆ°è¾¾åˆ°ç›®æ ‡é¢œè‰²æ•°é‡
            while (buckets.length < targetColors) {
                // æ‰¾åˆ°æœ€å¤§çš„bucketæ¥åˆ‡åˆ†
                let largestBucketIndex = 0;
                let largestBucketSize = 0;
                
                for (let i = 0; i < buckets.length; i++) {
                    if (buckets[i].length > largestBucketSize) {
                        largestBucketSize = buckets[i].length;
                        largestBucketIndex = i;
                    }
                }
                
                const bucketToSplit = buckets[largestBucketIndex];
                
                // å¦‚æœbucketå¤ªå°ï¼Œæ— æ³•ç»§ç»­åˆ‡åˆ†
                if (bucketToSplit.length < 2) {
                    break;
                }
                
                // æ‰¾åˆ°é¢œè‰²èŒƒå›´æœ€å¤§çš„é€šé“
                let rMin = 255, rMax = 0;
                let gMin = 255, gMax = 0;
                let bMin = 255, bMax = 0;
                
                for (let i = 0; i < bucketToSplit.length; i++) {
                    const pixel = bucketToSplit[i];
                    rMin = Math.min(rMin, pixel.r);
                    rMax = Math.max(rMax, pixel.r);
                    gMin = Math.min(gMin, pixel.g);
                    gMax = Math.max(gMax, pixel.g);
                    bMin = Math.min(bMin, pixel.b);
                    bMax = Math.max(bMax, pixel.b);
                }
                
                const rRange = rMax - rMin;
                const gRange = gMax - gMin;
                const bRange = bMax - bMin;
                
                // ç¡®å®šåˆ‡åˆ†é€šé“
                let splitChannel;
                if (rRange >= gRange && rRange >= bRange) {
                    splitChannel = 'r';
                } else if (gRange >= rRange && gRange >= bRange) {
                    splitChannel = 'g';
                } else {
                    splitChannel = 'b';
                }
                
                // æŒ‰é€‰å®šé€šé“æ’åº
                bucketToSplit.sort((a, b) => a[splitChannel] - b[splitChannel]);
                
                // æ‰¾åˆ°ä¸­ä½æ•°
                const medianIndex = Math.floor(bucketToSplit.length / 2);
                
                // åˆ‡åˆ†bucket
                const bucket1 = bucketToSplit.slice(0, medianIndex);
                const bucket2 = bucketToSplit.slice(medianIndex);
                
                // æ›¿æ¢åŸbucketä¸ºä¸¤ä¸ªæ–°bucket
                buckets.splice(largestBucketIndex, 1, bucket1, bucket2);
            }
            
            return buckets;
        }

        // ä»ä¸“è¾‘å°é¢æå–ä¸»è¦é¢œè‰²
        function updateGradientFromAlbum(imageUrl) {
            if (!imageUrl) {
                if (debugConsole) debugConsole.warn('æ¸å˜èƒŒæ™¯', 'æ— ä¸“è¾‘å°é¢URLï¼Œä½¿ç”¨é»˜è®¤é¢œè‰²');
                gradientPoints.forEach((p, i) => {
                    const newColor = defaultPalette[i % defaultPalette.length];
                    p.targetColor = { ...newColor };
                });
                return;
            }
            
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                try {
                    if (debugConsole) debugConsole.log('æ¸å˜èƒŒæ™¯', 'å¼€å§‹ä»ä¸“è¾‘å°é¢æå–é¢œè‰²...', 'info');
                    const colors = extractMainColors(img);
                    
                    // ç¡®ä¿æˆ‘ä»¬æœ‰è¶³å¤Ÿçš„é¢œè‰²
                    let extendedColors = [];
                    while (extendedColors.length < 36) {
                        extendedColors = extendedColors.concat(colors);
                    }
                    
                    // æ›´æ–°æ¸å˜ç‚¹çš„ç›®æ ‡é¢œè‰²
                    gradientPoints.forEach((p, i) => {
                        const newColor = extendedColors[i];
                        if (newColor) {
                            p.targetColor = { ...newColor };
                        }
                    });
                    
                    if (debugConsole) debugConsole.success('æ¸å˜èƒŒæ™¯', 'ä¸“è¾‘å°é¢é¢œè‰²æå–å®Œæˆï¼Œæ¸å˜èƒŒæ™¯å·²æ›´æ–°');
                } catch (error) {
                    if (debugConsole) debugConsole.error('æ¸å˜èƒŒæ™¯', `ä¸“è¾‘å°é¢é¢œè‰²æå–å¤±è´¥: ${error.message}`);
                }
            };
            
            img.onerror = (e) => {
                if (debugConsole) debugConsole.error('æ¸å˜èƒŒæ™¯', `ä¸“è¾‘å°é¢å›¾ç‰‡åŠ è½½å¤±è´¥: ${imageUrl}\né”™è¯¯ä¿¡æ¯: ${e.message}`);
                // åŠ è½½å¤±è´¥ä½¿ç”¨é»˜è®¤è‰²
                gradientPoints.forEach((p, i) => {
                    const newColor = defaultPalette[i % defaultPalette.length];
                    p.targetColor = { ...newColor };
                });
            };
            
            img.src = imageUrl;
        }

        function startGradientAnimation() {
            if (animationId) cancelAnimationFrame(animationId);
            resizeCanvas();
            initGradientPoints(); 
            animate(0);
            if (debugConsole) debugConsole.log('æ¸å˜èƒŒæ™¯', 'åŠ¨æ€æ¸å˜èƒŒæ™¯ç³»ç»Ÿå·²å¯åŠ¨', 'success');
        }

        // Fix: æš´éœ²æ¸å˜åŠ¨ç”»ç›¸å…³å‡½æ•°å’Œå˜é‡åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œä¾›èƒŒæ™¯ç³»ç»Ÿè°ƒç”¨
        window.startGradientAnimation = startGradientAnimation;
        window.updateGradientFromAlbum = updateGradientFromAlbum;
        window.getGradientAnimationId = function() { return animationId; };
        window.setGradientAnimationId = function(val) { animationId = val; };
        window.cancelGradientAnimation = function() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        };

        // ========== éŸ³ä¹æ’­æ”¾å™¨é€»è¾‘ ==========
        const searchInput = document.getElementById('searchInput');
        const apiSelect = document.getElementById('apiSelect'); // æ–°å¢ï¼šAPIé€‰æ‹©å™¨
        const algoToggleBtn = document.getElementById('algoToggleBtn'); // æ–°å¢ï¼šé¢œè‰²ç®—æ³•åˆ‡æ¢æŒ‰é’®
        const sourceSelect = document.getElementById('sourceSelect');
        const searchBtn = document.getElementById('searchBtn');
        const albumArt = document.getElementById('albumArt');
        const albumArtPlaceholder = document.querySelector('.album-art-placeholder');
        const songTitle = document.getElementById('songTitle');
        const songArtist = document.getElementById('songArtist');
        const progressBar = document.getElementById('progressBar');
        const progress = document.getElementById('progress');
        const progressHandle = document.getElementById('progressHandle');
        const currentTime = document.getElementById('currentTime');
        const duration = document.getElementById('duration');
        const playBtn = document.getElementById('playBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const qualitySelect = document.getElementById('qualitySelect');
        const lyricsContainer = document.getElementById('lyricsContainer');
        const lyricsContent = document.getElementById('lyricsContent');
        const resultsContainer = document.getElementById('resultsContainer');
        const audioPlayer = document.getElementById('audioPlayer');

        const fullscreenLyricsBtn = document.getElementById('fullscreenLyricsBtn');
        const fullscreenLyricsOverlay = document.getElementById('fullscreenLyricsOverlay');
        const closeFullscreenBtn = document.getElementById('closeFullscreenBtn');
        const fullscreenAlbumArt = document.getElementById('fullscreenAlbumArt');
        const fullscreenSongTitle = document.getElementById('fullscreenSongTitle');
        const fullscreenSongArtist = document.getElementById('fullscreenSongArtist');
        const fullscreenLyricsLines = document.getElementById('fullscreenLyricsLines');
        const fullscreenProgressBar = document.getElementById('fullscreenProgressBar');
        const fullscreenProgress = document.getElementById('fullscreenProgress');
        const fullscreenPlayBtn = document.getElementById('fullscreenPlayBtn');
        const fullscreenPrevBtn = document.getElementById('fullscreenPrevBtn');
        const fullscreenNextBtn = document.getElementById('fullscreenNextBtn');
        
        const speedSlider = document.getElementById('speedSlider');

        let currentTrack = null;
        let searchResults = [];
        let requestTimestamps = [];
        let mergedLyricsData = null;
        let isDragging = false;
        let userScrolledLyrics = false;
        let currentAlbumUrl = null;

        // =========================================================
        // Fix: iOS / å…¨å¹³å°ç¨³å®šæ€§å¢å¼ºï¼ˆè§¦æ§äº‹ä»¶ + éŸ³é¢‘è§£é” + AudioContext æ¢å¤ï¼‰
        // =========================================================
        window.__compatFix = window.__compatFix || {};
        window.__compatFix.flags = window.__compatFix.flags || {};
        window.__compatFix.flags.consoleShim = true; // Fix: console å«ç‰‡å·²åŠ è½½ï¼ˆè§ <head>ï¼‰

        let __lastUserGestureAt = 0;
        let __pendingPlayAfterUnlock = false;
        let __audioCtx = null;
        let __audioCtxSource = null;
        let __audioUnlockAttempts = 0;

        function markUserGesture() {
            __lastUserGestureAt = Date.now();
            try { window.__compatFix.lastUserGestureAt = __lastUserGestureAt; } catch (_) {}
        }

        function getAudioContext() {
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if (!Ctx) return null;
            if (!__audioCtx) {
                try { __audioCtx = new Ctx(); } catch (_) { __audioCtx = null; }
            }
            return __audioCtx;
        }

        function ensureAudioContextRoute() {
            const ctx = getAudioContext();
            if (!ctx) return;
            if (__audioCtxSource) return;
            try {
                __audioCtxSource = ctx.createMediaElementSource(audioPlayer);
                __audioCtxSource.connect(ctx.destination);
            } catch (_) {
                // createMediaElementSource å¯èƒ½å› é‡å¤è°ƒç”¨/æµè§ˆå™¨é™åˆ¶è€Œå¤±è´¥ï¼šå¿½ç•¥å³å¯
            }
        }

        async function resumeAudioContext() {
            const ctx = getAudioContext();
            if (!ctx) {
                window.__compatFix.flags.audioContext = { supported: false };
                return false;
            }
            try {
                if (ctx.state === 'suspended') await ctx.resume();
            } catch (_) {}
            window.__compatFix.flags.audioContext = { supported: true, state: ctx.state };
            return ctx.state === 'running';
        }

        // Fix: ç”Ÿæˆæå°çš„é™éŸ³ WAVï¼Œç”¨äº iOS é¦–æ¬¡æ‰‹åŠ¿â€œè§£é”â€åª’ä½“æ’­æ”¾
        function createSilentWavBlob(durationSec = 0.06, sampleRate = 44100) {
            const numSamples = Math.max(1, Math.floor(durationSec * sampleRate));
            const bytesPerSample = 2; // 16-bit
            const blockAlign = bytesPerSample * 1;
            const byteRate = sampleRate * blockAlign;
            const dataSize = numSamples * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            function writeString(offset, str) {
                for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
            }

            writeString(0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // PCM
            view.setUint16(22, 1, true); // channels
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, 16, true); // bits
            writeString(36, 'data');
            view.setUint32(40, dataSize, true);

            // samples are zero => silence
            return new Blob([buffer], { type: 'audio/wav' });
        }

        async function unlockIOSAudioOnce(reason = 'first-gesture') {
            // æœ€å¤šå°è¯• 2 æ¬¡ï¼Œé¿å…æç«¯æƒ…å†µä¸‹åå¤è§¦å‘
            if (window.__compatFix.flags.audioUnlocked === true) return;
            if (__audioUnlockAttempts >= 2) return;
            __audioUnlockAttempts++;

            markUserGesture();
            // Fix: ç§»é™¤AudioContextè·¯ç”±ï¼Œå› ä¸ºè·¨åŸŸéŸ³é¢‘ä¼šè¢«é™éŸ³
            // try { ensureAudioContextRoute(); } catch (_) {}
            try { await resumeAudioContext(); } catch (_) {}

            // iOS éƒ¨åˆ†ç‰ˆæœ¬åœ¨å¼‚æ­¥ play æ—¶ä¼šä¸¢å¤±æ‰‹åŠ¿ä¸Šä¸‹æ–‡ï¼šå…ˆç”¨â€œé™éŸ³æ’­æ”¾â€è§£é”ä¸€æ¬¡
            try {
                const unlockEl = new Audio();
                unlockEl.setAttribute('playsinline', '');
                unlockEl.setAttribute('webkit-playsinline', '');
                unlockEl.playsInline = true;
                unlockEl.muted = false;
                unlockEl.volume = 0;

                const url = URL.createObjectURL(createSilentWavBlob());
                unlockEl.src = url;

                const p = unlockEl.play();
                if (p && typeof p.then === 'function') await p;

                unlockEl.pause();
                unlockEl.src = '';
                URL.revokeObjectURL(url);

                window.__compatFix.flags.audioUnlocked = true;
            } catch (e) {
                // è§£é”å¤±è´¥ä¹Ÿä¸è‡´å‘½ï¼šåç»­ç”± safePlayAudio + é‡æ–°æ‰‹åŠ¿é‡è¯•å…œåº•
                window.__compatFix.flags.audioUnlocked = false;
            }
        }

        function armPendingPlayRetry() {
            if (armPendingPlayRetry._armed) return;
            armPendingPlayRetry._armed = true;

            const handler = async (e) => {
                armPendingPlayRetry._armed = false;
                markUserGesture();
                try { await unlockIOSAudioOnce('retry'); } catch (_) {}

                if (__pendingPlayAfterUnlock && audioPlayer && audioPlayer.src) {
                    __pendingPlayAfterUnlock = false;
                    await safePlayAudio('retry-after-gesture');
                }
            };

            // Fix: ç”¨æˆ·æ‰‹åŠ¿è§¦å‘ï¼ˆtouchend ä¼˜å…ˆï¼‰ï¼ŒåŒæ—¶å…¼å®¹ mouse/click
            ['touchend','click','mousedown'].forEach((evt) => {
                document.addEventListener(evt, handler, { once: true, capture: true, passive: false });
            });
        }

        async function safePlayAudio(from = '') {
            // Fix: ç§»é™¤AudioContextè·¯ç”±ï¼Œå› ä¸ºè·¨åŸŸéŸ³é¢‘ä¼šè¢«é™éŸ³
            // try { ensureAudioContextRoute(); } catch (_) {}
            // try { await resumeAudioContext(); } catch (_) {}

            try {
                const p = audioPlayer.play();
                if (p && typeof p.then === 'function') await p;
                window.__compatFix.flags.lastPlayOK = true;
                window.__compatFix.flags.lastPlayError = null;
                return true;
            } catch (e) {
                window.__compatFix.flags.lastPlayOK = false;
                window.__compatFix.flags.lastPlayError = { name: e && e.name, message: e && e.message };

                // Fix: iOS / Safari è‡ªåŠ¨æ’­æ”¾ç­–ç•¥æ‹¦æˆªæ—¶ï¼Œä¸æŠ›å‡ºæœªæ•è·å¼‚å¸¸ï¼Œè€Œæ˜¯æŒ‚èµ·ç­‰å¾…ä¸‹ä¸€æ¬¡æ‰‹åŠ¿
                __pendingPlayAfterUnlock = true;
                armPendingPlayRetry();

                // æ§åˆ¶å°/è°ƒè¯•é¢æ¿è¾“å‡ºï¼ˆä¸ä¾èµ– console.group/errorï¼‰
                try {
                    if (debugConsole) debugConsole.warn('æ’­æ”¾æ§åˆ¶', `éŸ³é¢‘æ’­æ”¾è¢«æµè§ˆå™¨ç­–ç•¥é˜»æ­¢æˆ–å¤±è´¥: ${e && e.name ? e.name : 'Error'} - ${e && e.message ? e.message : ''}`);
                } catch (_) {}
                return false;
            }
        }

        // Fix: é¦–æ¬¡ç”¨æˆ·äº¤äº’æ—¶ï¼Œå°½æ—© resume AudioContextï¼ˆiOS å¿…é¡»ï¼‰
        (function bindFirstUserGestureUnlock() {
            const once = () => { unlockIOSAudioOnce('first-gesture'); };
            document.addEventListener('touchend', once, { once: true, capture: true, passive: true });
            document.addEventListener('mousedown', once, { once: true, capture: true, passive: true });
            document.addEventListener('keydown', once, { once: true, capture: true, passive: true });
        })();

        // Fix: å…³é”®æŒ‰é’®è¡¥å…… touch/mouse äº‹ä»¶ï¼ˆä¸ç ´ååŸ click/onClick é€»è¾‘ï¼‰
        function bindUnifiedPress(el, handler, label) {
            if (!el || typeof handler !== 'function') return;
            let lastTouchTime = 0;

            try { el.dataset.compatBound = '1'; if (label) el.dataset.compatLabel = label; } catch (_) {}

            el.addEventListener('touchstart', () => { markUserGesture(); }, { passive: true });
            el.addEventListener('touchend', (e) => {
                lastTouchTime = Date.now();
                markUserGesture();
                try { unlockIOSAudioOnce('touchend'); } catch (_) {}
                try { if (e && e.cancelable) e.preventDefault(); } catch (_) {}
                try { handler(e); } catch (_) {}
            }, { passive: false });

            // mouse: ä»…è®°å½•æ‰‹åŠ¿ï¼Œä¿æŒåŸ click è¡Œä¸ºä¸å˜
            el.addEventListener('mousedown', () => { markUserGesture(); }, { passive: true });
            el.addEventListener('mouseup', () => { markUserGesture(); }, { passive: true });

            // click: è‹¥åˆšåˆšè§¦å‘è¿‡ touchendï¼Œåˆ™æŠ‘åˆ¶åˆæˆ clickï¼Œé¿å…åŒè§¦å‘ï¼ˆå°¤å…¶ iOSï¼‰
            el.addEventListener('click', (e) => {
                markUserGesture();
                try { unlockIOSAudioOnce('click'); } catch (_) {}

                if (Date.now() - lastTouchTime < 800) {
                    try {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                        e.stopPropagation();
                    } catch (_) {}
                }
            }, true);
        }

        // æš´éœ²ç»™è‡ªæ£€
        window.__compatFix.bindUnifiedPress = bindUnifiedPress;

        
        // APIé…ç½® - ä¸¤å¥—ç‹¬ç«‹ç³»ç»Ÿ
        const API_CONFIG = {
            gdstudio: {
                name: 'åŸAPI (GDStudio)',
                baseUrl: '/api.php',
                // åŸAPIéŸ³è´¨é€‰é¡¹
                qualities: [
                    { value: '128', label: 'æ ‡å‡†å“è´¨ (128k)' },
                    { value: '192', label: 'è‰¯å¥½å“è´¨ (192k)' },
                    { value: '320', label: 'é«˜å“è´¨ (320k)' },
                    { value: '740', label: 'æ— æŸå“è´¨ (740k)' },
                    { value: '999', label: 'é«˜è§£æåº¦ (999k)' }
                ]
            },
            tunehub: {
                name: 'å¤‡ç”¨API (TuneHub)',
                baseUrl: "https://music-dl.sayqz.com/api/",
                // TuneHub APIéŸ³è´¨é€‰é¡¹ - ä¸éŸ³ä¹ä¸‹è½½.htmlå®Œå…¨ä¸€è‡´
                qualities: [
                    { value: '128k', label: 'æ ‡å‡†å“è´¨ (128k)' },
                    { value: '320k', label: 'é«˜å“è´¨ (320k)' },
                    { value: 'flac', label: 'æ— æŸå“è´¨ (FLAC)' },
                    { value: 'flac24bit', label: 'é«˜è§£æåº¦ (24bit FLAC)' }
                ]
            }
        };

        // æ›´æ–°éŸ³ä¹æºé€‰æ‹©é€‰é¡¹
        function updateSourceOptions() {
            const api = apiSelect.value;
            const sourceOptions = sourceSelect.options;
            
            // é‡ç½®æ‰€æœ‰é€‰é¡¹
            for (let i = 0; i < sourceOptions.length; i++) {
                sourceOptions[i].disabled = false;
                sourceOptions[i].style.display = '';
            }
            
            if (api === 'tunehub') {
                // TuneHub APIæ”¯æŒçš„å¹³å°
                if (debugConsole) debugConsole.info('APIåˆ‡æ¢', 'åˆ‡æ¢åˆ°TuneHub APIï¼Œæ›´æ–°å¹³å°é€‰é¡¹');
                
                // å¯ç”¨TuneHubæ”¯æŒçš„é€‰é¡¹ï¼Œç¦ç”¨ä¸æ”¯æŒçš„
                for (let i = 0; i < sourceOptions.length; i++) {
                    const option = sourceOptions[i];
                    const value = option.value;
                    
                    // TuneHubæ”¯æŒçš„å¹³å°ï¼šnetease, kuwo, qq, aggregate
                    if (value === 'netease' || value === 'kuwo' || value === 'qq' || value === 'aggregate') {
                        option.disabled = false;
                        option.style.display = '';
                    } else {
                        option.disabled = true;
                        option.style.display = 'none';
                    }
                }
                
                // è®¾ç½®é»˜è®¤å€¼
                if (!['netease', 'kuwo', 'qq', 'aggregate'].includes(sourceSelect.value)) {
                    sourceSelect.value = 'netease';
                }
            } else {
                // åŸAPIæ”¯æŒçš„å¹³å°
                if (debugConsole) debugConsole.info('APIåˆ‡æ¢', 'åˆ‡æ¢åˆ°åŸAPIï¼Œæ¢å¤å¹³å°é€‰é¡¹');
                
                // æ¢å¤æ‰€æœ‰é€‰é¡¹
                for (let i = 0; i < sourceOptions.length; i++) {
                    const option = sourceOptions[i];
                    const value = option.value;
                    
                    // åŸAPIæ”¯æŒçš„å¹³å°ï¼škuwo, joox, netease
                    if (value === 'kuwo' || value === 'joox' || value === 'netease') {
                        option.disabled = false;
                        option.style.display = '';
                    } else {
                        option.disabled = true;
                        option.style.display = 'none';
                    }
                }
                
                // è®¾ç½®é»˜è®¤å€¼
                if (!['kuwo', 'joox', 'netease'].includes(sourceSelect.value)) {
                    sourceSelect.value = 'kuwo';
                }
            }
        }

        // æ›´æ–°éŸ³è´¨é€‰é¡¹
        function updateQualityOptions() {
            const api = apiSelect.value;
            const apiConfig = API_CONFIG[api];
            const qualitySelect = document.getElementById('qualitySelect');
            
            // æ¸…ç©ºç°æœ‰é€‰é¡¹
            qualitySelect.innerHTML = '';
            
            // æ·»åŠ æ–°é€‰é¡¹
            apiConfig.qualities.forEach(quality => {
                const option = document.createElement('option');
                option.value = quality.value;
                option.textContent = quality.label;
                qualitySelect.appendChild(option);
            });
            
            if (debugConsole) debugConsole.info('éŸ³è´¨é€‰é¡¹', `å·²æ›´æ–°ä¸º ${apiConfig.name} çš„éŸ³è´¨é€‰é¡¹`);
        }

        // APIé€‰æ‹©å™¨äº‹ä»¶
        apiSelect.addEventListener('change', () => {
            if (debugConsole) debugConsole.info('APIåˆ‡æ¢', `åˆ‡æ¢åˆ°: ${apiSelect.value} - ${API_CONFIG[apiSelect.value].name}`);
            updateSourceOptions();
            updateQualityOptions();
        });

        // åˆå§‹åŒ–æ—¶æ›´æ–°é€‰é¡¹
        updateSourceOptions();
        updateQualityOptions();


// ========== é¢œè‰²æå–ç®—æ³•åˆ‡æ¢ï¼ˆåŸï¼šä¸­ä½åˆ‡åˆ† / æ–°ï¼šK-meansï¼‰ ==========
let COLOR_EXTRACTION_ALGO = localStorage.getItem('colorExtractionAlgo') || 'medianCut'; // 'medianCut' | 'kmeans'

function updateAlgoToggleButton() {
    if (!algoToggleBtn) return;
    algoToggleBtn.textContent = COLOR_EXTRACTION_ALGO === 'kmeans' ? 'ç®—æ³•ï¼šK-means' : 'ç®—æ³•ï¼šåŸ(ä¸­ä½åˆ‡åˆ†)';
}

if (algoToggleBtn) {
    updateAlgoToggleButton();
    algoToggleBtn.addEventListener('click', () => {
        COLOR_EXTRACTION_ALGO = (COLOR_EXTRACTION_ALGO === 'kmeans') ? 'medianCut' : 'kmeans';
        localStorage.setItem('colorExtractionAlgo', COLOR_EXTRACTION_ALGO);
        updateAlgoToggleButton();
        if (debugConsole) debugConsole.info('é¢œè‰²æå–', `å·²åˆ‡æ¢é¢œè‰²æå–ç®—æ³•ä¸º: ${COLOR_EXTRACTION_ALGO === 'kmeans' ? 'K-means' : 'åŸ(ä¸­ä½åˆ‡åˆ†)'}`);

        // å¦‚æœå½“å‰å·²æœ‰ä¸“è¾‘å°é¢ï¼Œç«‹å³æŒ‰æ–°ç®—æ³•åˆ·æ–°èƒŒæ™¯
        if (currentAlbumUrl) {
            updateGradientFromAlbum(currentAlbumUrl);
        }
    });
}


        function checkRateLimit() {
            const now = Date.now();
            const fiveMinutesAgo = now - 5 * 60 * 1000;
            requestTimestamps = requestTimestamps.filter(timestamp => timestamp > fiveMinutesAgo);
            
            if (requestTimestamps.length >= 60) {
                const message = 'APIè¯·æ±‚é¢‘ç‡è¿‡é«˜ï¼Œå·²è¶…è¿‡é™åˆ¶ï¼ˆ5åˆ†é’Ÿå†…æœ€å¤š60æ¬¡è¯·æ±‚ï¼‰ã€‚è¯·ç­‰å¾…5åˆ†é’Ÿåå†è¯•ã€‚å½“å‰è¯·æ±‚æ¬¡æ•°ï¼š' + requestTimestamps.length;
                if (debugConsole) debugConsole.error('APIé™åˆ¶', message);
                return false;
            }
            
            requestTimestamps.push(now);
            if (debugConsole) debugConsole.info('APIè¯·æ±‚', `å½“å‰5åˆ†é’Ÿå†…APIè¯·æ±‚æ¬¡æ•°: ${requestTimestamps.length}/60`);
            return true;
        }

        // TuneHub APIè¯·æ±‚å‡½æ•° - å®Œå…¨æŒ‰ç…§éŸ³ä¹ä¸‹è½½.htmlçš„æ–¹å¼
        async function tunehubRequest(params) {
  const base = __tunehubBaseFor(params);

            try {
                const apiConfig = API_CONFIG.tunehub;
                const url = new URL(base, location.origin);
                
                // ç›´æ¥ä½¿ç”¨å‚æ•°ï¼Œä¸è¿›è¡Œæ˜ å°„
                Object.keys(params).forEach(k => {
                    if (params[k] !== undefined && params[k] !== null) {
                        url.searchParams.append(k, params[k]);
                    }
                });
                
                const urlString = url.toString();
                if (debugConsole) debugConsole.api('TuneHub APIè¯·æ±‚', `å‘é€è¯·æ±‚: ${urlString}`);
                
                const response = await fetch(urlString);
                
                if (!response.ok) {
                    const errorMsg = `HTTPè¯·æ±‚å¤±è´¥: çŠ¶æ€ç  ${response.status} ${response.statusText}`;
                    if (debugConsole) debugConsole.error('TuneHub APIè¯·æ±‚', errorMsg);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // éŸ³é¢‘URLè¯·æ±‚è¿”å›æ–‡æœ¬
                if (params.type === 'url') {
                    const audioUrl = await response.text();
                    if (debugConsole) debugConsole.api('TuneHub APIè¯·æ±‚', `éŸ³é¢‘URLè·å–æˆåŠŸ: ${audioUrl.substring(0, 100)}...`);
                    return { url: audioUrl };
                }
                
                // å…¶ä»–è¯·æ±‚è¿”å›JSON
                const data = await response.json();
                if (debugConsole) debugConsole.api('TuneHub APIè¯·æ±‚', `è¯·æ±‚æˆåŠŸï¼Œè¿”å›æ•°æ®`);
                return data;
            } catch (error) {
                const errorMsg = `TuneHub APIè¯·æ±‚å¼‚å¸¸: ${error.message}\né”™è¯¯å †æ ˆ: ${error.stack}`;
                if (debugConsole) debugConsole.error('TuneHub APIè¯·æ±‚', errorMsg);
                return null;
            }
        }

        // åŸAPIè¯·æ±‚å‡½æ•°
        async function gdstudioRequest(params) {
            try {
                const apiConfig = API_CONFIG.gdstudio;
                const queryString = new URLSearchParams(params).toString();
                const url = `${apiConfig.baseUrl}?${queryString}`;
                
                if (debugConsole) debugConsole.api('åŸAPIè¯·æ±‚', `å‘é€è¯·æ±‚: ${url}`);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    const errorMsg = `HTTPè¯·æ±‚å¤±è´¥: çŠ¶æ€ç  ${response.status} ${response.statusText}`;
                    if (debugConsole) debugConsole.error('åŸAPIè¯·æ±‚', errorMsg);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                if (debugConsole) debugConsole.api('åŸAPIè¯·æ±‚', `è¯·æ±‚æˆåŠŸï¼Œè¿”å›æ•°æ®`);
                return data;
            } catch (error) {
                const errorMsg = `åŸAPIè¯·æ±‚å¼‚å¸¸: ${error.message}\né”™è¯¯å †æ ˆ: ${error.stack}`;
                if (debugConsole) debugConsole.error('åŸAPIè¯·æ±‚', errorMsg);
                return null;
            }
        }

        // ç»Ÿä¸€APIè¯·æ±‚å‡½æ•°
        async function apiRequest(params, apiType = null) {
            const api = apiType || apiSelect.value;
            
            if (!checkRateLimit()) {
                const errorMsg = 'APIè¯·æ±‚é¢‘ç‡é™åˆ¶ï¼š5åˆ†é’Ÿå†…æœ€å¤š60æ¬¡è¯·æ±‚ï¼Œå½“å‰å·²è¶…é™ã€‚';
                if (debugConsole) debugConsole.error('APIé™åˆ¶', errorMsg);
                return null;
            }
            
            if (api === 'gdstudio') {
                return await gdstudioRequest(params);
            } else if (api === 'tunehub') {
                // å°†åŸAPIå‚æ•°è½¬æ¢ä¸ºTuneHubå‚æ•°
                let tunehubParams = {};
                
                if (params.types === 'search') {
                    // å¤„ç†èšåˆæœç´¢
                    if (params.source === 'aggregate') {
                        tunehubParams = {
                            type: 'aggregateSearch',
                            keyword: params.name,
                            limit: params.count || 20
                        };
                    } else {
                        tunehubParams = {
                            source: params.source,
                            type: 'search',
                            keyword: params.name,
                            limit: params.count || 20,
                            page: params.pages || 1
                        };
                    }
                } else if (params.types === 'url') {
                    // ç›´æ¥ä½¿ç”¨éŸ³ä¹ä¸‹è½½.htmlä¸­çš„æ–¹å¼
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'url',
                        br: params.br // ç›´æ¥ä½¿ç”¨éŸ³è´¨å€¼ï¼Œä¸æ˜ å°„
                    };
                } else if (params.types === 'pic') {
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'pic'
                    };
                } else if (params.types === 'lyric') {
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'lrc'
                    };
                }
                
                return await tunehubRequest(tunehubParams);
            }
        }

        async function searchMusic(keyword, source = null) {
            if (!keyword.trim()) {
                const errorMsg = 'æœç´¢å¤±è´¥: æœç´¢å…³é”®è¯ä¸ºç©ºï¼Œè¯·è¾“å…¥æœ‰æ•ˆçš„æ­Œæ›²åã€æ­Œæ‰‹åæˆ–ä¸“è¾‘åè¿›è¡Œæœç´¢ã€‚';
                if (debugConsole) debugConsole.error('æœç´¢', errorMsg);
                
                const d = document.createElement('div');
                d.className = 'error';
                d.textContent = 'è¯·è¾“å…¥æœç´¢å…³é”®è¯';
                resultsContainer.prepend(d);
                setTimeout(() => d.remove(), 4000);
                return;
            }
            
            const api = apiSelect.value;
            const selectedSource = source || sourceSelect.value;
            
            if (debugConsole) debugConsole.info('æœç´¢', `å¼€å§‹æœç´¢: "${keyword}" (API: ${api}, æº: ${selectedSource})`);
            resultsContainer.innerHTML = '<div class="loading">æœç´¢ä¸­...</div>';
            
            let data;
            if (api === 'gdstudio') {
                // åŸAPIæœç´¢
                data = await apiRequest({
                    types: 'search',
                    source: selectedSource,
                    name: keyword,
                    count: 20,
                    pages: 1
                });
            } else if (api === 'tunehub') {
                // TuneHub APIæœç´¢
                data = await apiRequest({
                    types: 'search',
                    source: selectedSource,
                    name: keyword,
                    count: 20,
                    pages: 1
                });
            }
            
            if (data) {
                if (api === 'gdstudio' && Array.isArray(data) && data.length > 0) {
                    // åŸAPIæœç´¢ç»“æœ - æ·»åŠ å¹³å°ä¿¡æ¯
                    searchResults = data.map(track => ({
                        ...track,
                        platform: selectedSource,
                        api: 'gdstudio'
                    }));
                    if (debugConsole) debugConsole.success('æœç´¢', `æœç´¢æˆåŠŸï¼Œæ‰¾åˆ° ${data.length} ä¸ªç»“æœ`);
                    displaySearchResults(searchResults, api);
                } else if (api === 'tunehub' && data.code === 200 && data.data) {
                    // TuneHubè¿”å›çš„æ•°æ®æ ¼å¼
                    let tracks = [];
                    
                    if (selectedSource === 'aggregate') {
                        // èšåˆæœç´¢è¿”å›çš„æ•°æ®æ ¼å¼
                        if (data.data.results && Array.isArray(data.data.results)) {
                            tracks = data.data.results.map(item => ({
                                id: item.id,
                                name: item.name,
                                artist: item.artist || 'æœªçŸ¥è‰ºæœ¯å®¶',
                                album: item.album || 'æœªçŸ¥ä¸“è¾‘',
                                pic_id: item.id,
                                pic_url: item.pic,
                                lyric_id: item.id,
                                source: item.platform,
                                platform: item.platform,
                                api: 'tunehub'
                            }));
                        }
                    } else {
                        // æ™®é€šæœç´¢è¿”å›çš„æ•°æ®æ ¼å¼
                        if (data.data.results && Array.isArray(data.data.results)) {
                            tracks = data.data.results.map(item => ({
                                id: item.id,
                                name: item.name,
                                artist: item.artist || 'æœªçŸ¥è‰ºæœ¯å®¶',
                                album: item.album || 'æœªçŸ¥ä¸“è¾‘',
                                pic_id: item.id,
                                pic_url: item.pic,
                                lyric_id: item.id,
                                source: selectedSource,
                                platform: selectedSource,
                                api: 'tunehub'
                            }));
                        }
                    }
                    
                    if (tracks.length > 0) {
                        searchResults = tracks;
                        if (debugConsole) debugConsole.success('æœç´¢', `æœç´¢æˆåŠŸï¼Œæ‰¾åˆ° ${tracks.length} ä¸ªç»“æœ`);
                        displaySearchResults(tracks, api);
                    } else {
                        if (debugConsole) debugConsole.warn('æœç´¢', `æœªæ‰¾åˆ°ç›¸å…³ç»“æœï¼Œå…³é”®è¯: "${keyword}"ï¼ŒAPI: ${api}ï¼Œæº: ${selectedSource}`);
                        resultsContainer.innerHTML = '<div class="loading">æœªæ‰¾åˆ°ç»“æœ</div>';
                    }
                } else {
                    if (debugConsole) debugConsole.warn('æœç´¢', `æœªæ‰¾åˆ°ç›¸å…³ç»“æœï¼Œå…³é”®è¯: "${keyword}"ï¼ŒAPI: ${api}ï¼Œæº: ${selectedSource}`);
                    resultsContainer.innerHTML = '<div class="loading">æœªæ‰¾åˆ°ç»“æœ</div>';
                }
            } else {
                if (debugConsole) debugConsole.warn('æœç´¢', `APIè¿”å›ç©ºæ•°æ®ï¼Œå…³é”®è¯: "${keyword}"ï¼ŒAPI: ${api}ï¼Œæº: ${selectedSource}`);
                resultsContainer.innerHTML = '<div class="loading">æœªæ‰¾åˆ°ç»“æœ</div>';
            }
        }

        // ---------- æœç´¢ç»“æœæ˜¾ç¤º ----------
        function displaySearchResults(results, api) {
            resultsContainer.innerHTML = '';
            
            if (results.length === 0) {
                resultsContainer.innerHTML = '<div class="loading">æœªæ‰¾åˆ°ç»“æœ</div>';
                return;
            }
            
            results.forEach((track) => {
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                if (currentTrack && currentTrack.id === track.id && currentTrack.api === track.api) {
                    resultItem.classList.add('active');
                }
                
                // æ ¹æ®APIæ„å»ºä¸“è¾‘å°é¢URL
                let albumArtUrl;
                if (api === 'gdstudio') {
                    albumArtUrl = track.pic_id ? 
                        `/api.php?types=pic&source=${track.source}&id=${track.pic_id}&size=150` : 
                        'data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2250%22%20height%3D%2250%22%3E%3Crect%20width%3D%22100%25%22%20height%3D%22100%25%22%20fill%3D%22%23333%22%2F%3E%3Ctext%20x%3D%2250%25%22%20y%3D%2258%25%22%20font-size%3D%2228%22%20text-anchor%3D%22middle%22%20fill%3D%22%23fff%22%20font-family%3D%22Arial%2C%20sans-serif%22%3E%E2%99%AA%3C%2Ftext%3E%3C%2Fsvg%3E';
                } else if (api === 'tunehub') {
                    // TuneHub: ä¼˜å…ˆä½¿ç”¨pic_urlï¼Œå¦‚æœæ²¡æœ‰åˆ™ç”¨idæ„å»º
                    if (track.pic_url) {
                        albumArtUrl = track.pic_url;
                    } else if (track.pic_id) {
                        albumArtUrl = `https://music-dl.sayqz.com/api/?type=pic&source=${track.source}&id=${track.pic_id}`;
                    } else {
                        albumArtUrl = 'data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2250%22%20height%3D%2250%22%3E%3Crect%20width%3D%22100%25%22%20height%3D%22100%25%22%20fill%3D%22%23333%22%2F%3E%3Ctext%20x%3D%2250%25%22%20y%3D%2258%25%22%20font-size%3D%2228%22%20text-anchor%3D%22middle%22%20fill%3D%22%23fff%22%20font-family%3D%22Arial%2C%20sans-serif%22%3E%E2%99%AA%3C%2Ftext%3E%3C%2Fsvg%3E';
                    }
                }

                // è·å–å¹³å°æ˜¾ç¤ºåç§°
                let platformName = '';
                let platformClass = '';
                if (track.platform) {
                    platformName = track.platform.toUpperCase();
                    platformClass = track.platform;
                }

                resultItem.innerHTML = `
                    <img src="${albumArtUrl}" class="result-album" onerror="this.src='data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2250%22%20height%3D%2250%22%3E%3Crect%20width%3D%22100%25%22%20height%3D%22100%25%22%20fill%3D%22%23333%22%2F%3E%3Ctext%20x%3D%2250%25%22%20y%3D%2258%25%22%20font-size%3D%2228%22%20text-anchor%3D%22middle%22%20fill%3D%22%23fff%22%20font-family%3D%22Arial%2C%20sans-serif%22%3E%E2%99%AA%3C%2Ftext%3E%3C%2Fsvg%3E'">
                    <div class="result-info">
                        <div class="result-title">${track.name || 'æœªçŸ¥æ­Œæ›²'}</div>
                        <div class="result-artist">${track.artist || 'æœªçŸ¥è‰ºæœ¯å®¶'}</div>
                        <div class="result-album-name">${track.album || 'æœªçŸ¥ä¸“è¾‘'}</div>
                        <div class="result-platform-info">
                            <span class="platform-badge ${platformClass}">${platformName}</span>
                            <span class="api-select-label">${track.api === 'tunehub' ? 'å¤‡ç”¨API' : 'åŸAPI'}</span>
                        </div>
                    </div>
                `;
                
                resultItem.__trackData = track;

                // Fix: iOS è§¦æ§/é¼ æ ‡äº‹ä»¶åŒç»‘å®šï¼ˆé¿å… click å»¶è¿Ÿ/ä¸¢å¤±ï¼ŒåŒæ—¶é˜²æ­¢ touch åé‡å¤è§¦å‘ clickï¼‰
                let __riLastTouch = 0;
                const __onSelect = (evt) => {
                    try { markUserGesture(); } catch (_) {}
                    try { unlockIOSAudioOnce('select-track'); } catch (_) {}

                    if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', `ç‚¹å‡»æ’­æ”¾æ­Œæ›²: ${track.name} - ${track.artist} (API: ${track.api || api}, å¹³å°: ${track.platform})`);
                    playTrack(track);
                    document.querySelectorAll('.result-item').forEach(item => item.classList.remove('active'));
                    resultItem.classList.add('active');
                };

                resultItem.addEventListener('touchstart', () => { try { markUserGesture(); } catch (_) {} }, { passive: true });
                // Fix: ç§»é™¤touchendè§¦å‘æ’­æ”¾ï¼Œé¿å…è¯¯è§¦ï¼Œåªä¿ç•™click
                resultItem.addEventListener('touchend', (e) => {
                    __riLastTouch = Date.now();
                    try { markUserGesture(); } catch (_) {}
                    // ä¸å†åœ¨touchendè§¦å‘æ’­æ”¾
                }, { passive: true });

                resultItem.addEventListener('mousedown', () => { try { markUserGesture(); } catch (_) {} }, { passive: true });
                resultItem.addEventListener('mouseup', () => { try { markUserGesture(); } catch (_) {} }, { passive: true });

                resultItem.addEventListener('click', (e) => {
                    // ä½¿ç”¨clickäº‹ä»¶è§¦å‘æ’­æ”¾ï¼Œæ›´ä¸å®¹æ˜“è¯¯è§¦
                    __onSelect(e);
                });
                
                resultsContainer.appendChild(resultItem);
            });
            
            if (debugConsole) debugConsole.success('æœç´¢ç»“æœ', `æˆåŠŸæ¸²æŸ“ ${results.length} ä¸ªæœç´¢ç»“æœ`);
        }

        async function playTrack(track) {
            try {
                currentTrack = track;
                
                // Fix: ç«‹å³æ¸…ç©ºæ—§çš„å°é¢URLï¼Œé¿å…MediaSessionæ˜¾ç¤ºä¸Šä¸€é¦–æ­Œçš„å°é¢
                currentAlbumUrl = '';
                
                if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', `å¼€å§‹æ’­æ”¾æ­Œæ›²: ${track.name} - ${track.artist} (ID: ${track.id}, API: ${track.api || apiSelect.value}, å¹³å°: ${track.platform})`);
                
                songTitle.textContent = track.name || 'æœªçŸ¥æ­Œæ›²';
                songArtist.textContent = `${track.artist || 'æœªçŸ¥è‰ºæœ¯å®¶'}`;
                fullscreenSongTitle.textContent = track.name || 'æœªçŸ¥æ­Œæ›²';
                fullscreenSongArtist.textContent = track.artist || 'æœªçŸ¥è‰ºæœ¯å®¶';
                
                albumArt.style.display = 'none';
                albumArtPlaceholder.style.display = 'flex';
                
                // Fix: ç«‹å³æ›´æ–°MediaSessionæ ‡é¢˜ä¿¡æ¯ï¼ˆå…ˆä¸å¸¦å°é¢ï¼‰
                updateMediaSession(track);
                
                // æ›´æ–° active çŠ¶æ€
                document.querySelectorAll('.result-item').forEach(item => {
                    if(item.__trackData && item.__trackData.id === track.id && item.__trackData.api === track.api) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
                
                lyricsContent.innerHTML = '<div class="loading">åŠ è½½ä¸­...</div>';
                fullscreenLyricsLines.innerHTML = '<div class="loading">åŠ è½½ä¸­...</div>';
                userScrolledLyrics = false;
                
                // æ ¹æ®trackçš„APIè·å–éŸ³é¢‘URL
                const quality = qualitySelect.value;
                const apiToUse = track.api || apiSelect.value;
                
                if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', `è¯·æ±‚éŸ³é¢‘URLï¼ŒéŸ³è´¨: ${quality}, API: ${apiToUse}, å¹³å°: ${track.platform}`);
                
                let urlData;
                if (apiToUse === 'tunehub') {
                    // TuneHub API - ä½¿ç”¨éŸ³ä¹ä¸‹è½½.htmlä¸­çš„æ–¹å¼
                    const apiConfig = API_CONFIG.tunehub;
                    // ç›´æ¥æ„å»ºURLï¼Œä¸éŸ³ä¹ä¸‹è½½.htmlç›¸åŒ
                    const url = new URL(apiConfig.baseUrl, location.origin);
                    url.searchParams.append('source', track.platform || track.source || sourceSelect.value);
                    url.searchParams.append('id', track.id);
                    url.searchParams.append('type', 'url');
                    url.searchParams.append('br', quality);
                    
                    const urlString = url.toString();
                    if (debugConsole) debugConsole.success('æ’­æ”¾æ§åˆ¶', `TuneHubéŸ³é¢‘URL: ${urlString}`);
                    
                    // ç›´æ¥è®¾ç½®éŸ³é¢‘æºï¼Œä¸é€šè¿‡APIè¯·æ±‚
                    urlData = { url: urlString };
                } else {
                    // åŸAPI
                    urlData = await apiRequest({
                        types: 'url',
                        source: track.platform || track.source || sourceSelect.value,
                        id: track.id,
                        br: quality
                    });
                }
                
                if (urlData && urlData.url) {
                    if (debugConsole) debugConsole.success('æ’­æ”¾æ§åˆ¶', `æˆåŠŸè·å–éŸ³é¢‘URL: ${urlData.url.substring(0, 100)}...`);
                    
                    audioPlayer.src = urlData.url;

                    // Fix: iOS/Safari åœ¨å¼‚æ­¥è·å– URL åå¯èƒ½ä¸¢å¤±ç”¨æˆ·æ‰‹åŠ¿ä¸Šä¸‹æ–‡ï¼Œå¯¼è‡´ play() è¢«æ‹¦æˆª
                    const __played = await safePlayAudio('playTrack');
                    if (__played) {
                        playBtn.innerHTML = 'â¸';
                        fullscreenPlayBtn.innerHTML = 'â¸';
                        if (debugConsole) debugConsole.success('æ’­æ”¾æ§åˆ¶', 'éŸ³é¢‘æ’­æ”¾å¼€å§‹');
                    } else {
                        // ä¿æŒæŒ‰é’®ä¸ºâ€œå¯æ’­æ”¾â€çŠ¶æ€ï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡ç”¨æˆ·æ‰‹åŠ¿è§¦å‘é‡è¯•
                        playBtn.innerHTML = 'â–¶';
                        fullscreenPlayBtn.innerHTML = 'â–¶';
                        if (debugConsole) debugConsole.warn('æ’­æ”¾æ§åˆ¶', 'éŸ³é¢‘å·²å°±ç»ªï¼Œä½†éœ€è¦ç”¨æˆ·å†æ¬¡ç‚¹å‡»æ’­æ”¾ä»¥è§£é”ï¼ˆiOSç­–ç•¥ï¼‰');
                    }
// åŠ è½½ä¸“è¾‘å°é¢
                    if (track.pic_url) {
                        // ç›´æ¥ä½¿ç”¨æœç´¢æ—¶å¾—åˆ°çš„å›¾ç‰‡URL
                        if (debugConsole) debugConsole.info('ä¸“è¾‘å°é¢', `ä½¿ç”¨æœç´¢ç»“æœä¸­çš„ä¸“è¾‘å°é¢URL: ${track.pic_url}`);
                        currentAlbumUrl = track.pic_url;
                        albumArt.src = __wrapKuwoIfNeeded(track.pic_url);
                        albumArt.style.display = 'block';
                        albumArtPlaceholder.style.display = 'none';
                        fullscreenAlbumArt.src = __wrapKuwoIfNeeded(track.pic_url);
                        
                        // ä½¿ç”¨é¢œè‰²é‡åŒ–ç®—æ³•æå–ä¸»è¦é¢œè‰²å¹¶æ›´æ–°èƒŒæ™¯
                        updateGradientFromAlbum(track.pic_url);
                        
                        // Fix: å°é¢URLå·²è·å–ï¼Œç«‹å³æ›´æ–°MediaSession
                        updateMediaSession(track);
                    } else if (track.pic_id) {
                        if (debugConsole) debugConsole.info('ä¸“è¾‘å°é¢', `å¼€å§‹åŠ è½½ä¸“è¾‘å°é¢ï¼Œå›¾ç‰‡ID: ${track.pic_id}, API: ${apiToUse}`);
                        loadAlbumCover(track, apiToUse);
                    }
                    
                    // åŠ è½½æ­Œè¯
                    if (track.lyric_id || track.id) {
                        const lyricId = track.lyric_id || track.id;
                        if (debugConsole) debugConsole.info('æ­Œè¯', `å¼€å§‹åŠ è½½æ­Œè¯ï¼Œæ­Œè¯ID: ${lyricId}, API: ${apiToUse}`);
                        loadLyrics(track, apiToUse);
                    }
                } else {
                    const errorMsg = `æ— æ³•æ’­æ”¾æ­¤æ­Œæ›²ï¼Œå¯èƒ½æ²¡æœ‰å¯¹åº”çš„éŸ³è´¨æˆ–é“¾æ¥å¤±æ•ˆã€‚\næ­Œæ›²ID: ${track.id}\néŸ³è´¨: ${quality}\nAPI: ${apiToUse}\nå¹³å°: ${track.platform}`;
                    if (debugConsole) debugConsole.error('æ’­æ”¾æ§åˆ¶', errorMsg);
                }
            } catch (error) {
                const errorMsg = `æ’­æ”¾æ­Œæ›²è¿‡ç¨‹ä¸­å‡ºç°å¼‚å¸¸: ${error.message}\né”™è¯¯å †æ ˆ: ${error.stack}`;
                if (debugConsole) debugConsole.error('æ’­æ”¾æ§åˆ¶', errorMsg);
            }
        }

        // ---------- æµè§ˆå™¨/iOSé”å±ä¸“è¾‘å°é¢éƒ¨åˆ† ----------
        function updateMediaSession(track) {
            if ('mediaSession' in navigator) {
                try {
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: track.name || 'æœªçŸ¥æ­Œæ›²',
                        artist: track.artist || 'æœªçŸ¥è‰ºæœ¯å®¶',
                        album: track.album || 'æœªçŸ¥ä¸“è¾‘',
                        artwork: currentAlbumUrl ? [
                            { src: currentAlbumUrl, sizes: '256x256', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '384x384', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '512x512', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '768x768', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '1024x1024', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '1536x1536', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '2048x2048', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '3000x3000', type: 'image/jpeg' }
                        ] : []
                    });
                    
                    navigator.mediaSession.setActionHandler('play', async () => {
                        // Fix: iOS/Safari åª’ä½“ä¼šè¯ play èµ°ç»Ÿä¸€å®‰å…¨æ’­æ”¾é€»è¾‘
                        const ok = await safePlayAudio('mediaSession-play');
                        if (ok) {
                            playBtn.innerHTML = 'â¸';
                            fullscreenPlayBtn.innerHTML = 'â¸';
                        } else {
                            playBtn.innerHTML = 'â–¶';
                            fullscreenPlayBtn.innerHTML = 'â–¶';
                        }
                    });
                    
                    navigator.mediaSession.setActionHandler('pause', () => {
                        audioPlayer.pause();
                        playBtn.innerHTML = 'â–¶';
                        fullscreenPlayBtn.innerHTML = 'â–¶';
                    });
                    
                    navigator.mediaSession.setActionHandler('previoustrack', () => {
                        prevBtn.click();
                    });
                    
                    navigator.mediaSession.setActionHandler('nexttrack', () => {
                        nextBtn.click();
                    });
                    
                    if (debugConsole) debugConsole.success('åª’ä½“ä¼šè¯', 'æµè§ˆå™¨/iOSé”å±åª’ä½“ä¼šè¯å·²æ›´æ–°');
                } catch (error) {
                    if (debugConsole) debugConsole.error('åª’ä½“ä¼šè¯', `æ›´æ–°åª’ä½“ä¼šè¯å¤±è´¥: ${error.message}`);
                }
            }
        }

        async function loadAlbumCover(track, api) {
            if (!track.pic_id) {
                if (debugConsole) debugConsole.warn('ä¸“è¾‘å°é¢', 'æ— ä¸“è¾‘å°é¢IDï¼Œè·³è¿‡å°é¢åŠ è½½');
                return;
            }
            
            if (debugConsole) debugConsole.info('ä¸“è¾‘å°é¢', `è¯·æ±‚ä¸“è¾‘å°é¢ï¼Œå›¾ç‰‡ID: ${track.pic_id}, API: ${api}`);
            
            let picData;
            if (api === 'tunehub') {
                // TuneHub API - ç›´æ¥æ„å»ºURL
                const apiConfig = API_CONFIG.tunehub;
                const url = new URL(apiConfig.baseUrl, location.origin);
                url.searchParams.append('source', track.platform || track.source || sourceSelect.value);
                url.searchParams.append('id', track.pic_id);
                url.searchParams.append('type', 'pic');
                
                picData = { url: url.toString() };
            } else {
                // åŸAPI
                let sizeParam = '3000';
                if (track.platform === 'joox' || track.source === 'joox') {
                    sizeParam = '';
                    if (debugConsole) debugConsole.info('ä¸“è¾‘å°é¢', 'JOOXéŸ³ä¹æºï¼Œä½¿ç”¨åŸå§‹å°ºå¯¸');
                }
                
                picData = await apiRequest({
                    types: 'pic',
                    source: track.platform || track.source || sourceSelect.value,
                    id: track.pic_id,
                    size: sizeParam
                });
            }
            
            if (picData && picData.url) {
                currentAlbumUrl = picData.url;
                if (debugConsole) debugConsole.success('ä¸“è¾‘å°é¢', `æˆåŠŸåŠ è½½ä¸“è¾‘å°é¢: ${picData.url}`);
                
                albumArt.src = __wrapKuwoIfNeeded(picData.url);
                albumArt.style.display = 'block';
                albumArtPlaceholder.style.display = 'none';
                fullscreenAlbumArt.src = __wrapKuwoIfNeeded(picData.url);
                
                // ä½¿ç”¨é¢œè‰²é‡åŒ–ç®—æ³•æå–ä¸»è¦é¢œè‰²å¹¶æ›´æ–°èƒŒæ™¯
                updateGradientFromAlbum(picData.url);
                
                // Fix: æ›´æ–°mediaSessionçš„artworkï¼Œä½¿ç”¨currentTrackè·å–ä¿¡æ¯
                if ('mediaSession' in navigator && currentTrack) {
                    try {
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: currentTrack.name || 'æœªçŸ¥æ­Œæ›²',
                            artist: currentTrack.artist || 'æœªçŸ¥è‰ºæœ¯å®¶',
                            album: currentTrack.album || 'æœªçŸ¥ä¸“è¾‘',
                            artwork: [
                                { src: picData.url, sizes: '256x256', type: 'image/jpeg' },
                                { src: picData.url, sizes: '384x384', type: 'image/jpeg' },
                                { src: picData.url, sizes: '512x512', type: 'image/jpeg' },
                                { src: picData.url, sizes: '768x768', type: 'image/jpeg' },
                                { src: picData.url, sizes: '1024x1024', type: 'image/jpeg' },
                                { src: picData.url, sizes: '1536x1536', type: 'image/jpeg' },
                                { src: picData.url, sizes: '2048x2048', type: 'image/jpeg' },
                                { src: picData.url, sizes: '3000x3000', type: 'image/jpeg' }
                            ]
                        });
                        if (debugConsole) debugConsole.info('åª’ä½“ä¼šè¯', 'ä¸“è¾‘å°é¢å·²æ›´æ–°åˆ°åª’ä½“ä¼šè¯');
                    } catch (error) {
                        if (debugConsole) debugConsole.error('åª’ä½“ä¼šè¯', `æ›´æ–°ä¸“è¾‘å°é¢åˆ°åª’ä½“ä¼šè¯å¤±è´¥: ${error.message}`);
                    }
                }
                
                albumArt.onerror = () => {
                    const errorMsg = `ä¸“è¾‘å°é¢å›¾ç‰‡åŠ è½½å¤±è´¥: ${picData.url}`;
                    if (debugConsole) debugConsole.error('ä¸“è¾‘å°é¢', errorMsg);
                    albumArt.style.display = 'none';
                    albumArtPlaceholder.style.display = 'flex';
                };
            } else {
                if (debugConsole) debugConsole.error('ä¸“è¾‘å°é¢', `æ— æ³•è·å–ä¸“è¾‘å°é¢æ•°æ®ï¼Œå›¾ç‰‡ID: ${track.pic_id}`);
            }
        }

        // ---------- æ­Œè¯è§£æ ----------
        function parseLRC(lrcText) {
            const lines = [];
            if (!lrcText) return lines;
            
            const lrcLines = lrcText.split('\n');
            
            lrcLines.forEach(line => {
                const timeMatch = line.match(/\[(\d+):(\d+)\.(\d+)\]/);
                if (timeMatch) {
                    const min = parseInt(timeMatch[1]);
                    const sec = parseInt(timeMatch[2]);
                    const ms = parseInt(timeMatch[3]) * 10;
                    let text = line.replace(/\[.*?\]/g, '').trim();

                    let words = [];
                    const wordMatch = text.matchAll(/\(([^)]+?)<(\d+:\d+:\d+)>\)/g);
                    let hasWordTiming = false;

                    for (const match of wordMatch) {
                        const wordText = match[1];
                        const wordTimeStr = match[2].split(':');
                        const wordTime = parseInt(wordTimeStr[0])*60 + parseInt(wordTimeStr[1]) + parseInt(wordTimeStr[2])/1000;
                        words.push({ text: wordText, time: wordTime });
                        hasWordTiming = true;
                    }

                    if (hasWordTiming) {
                         text = words.map(w => w.text).join('');
                    }

                    if (text) {
                        lines.push({
                            time: min * 60 + sec + ms/1000,
                            text: text,
                            words: hasWordTiming ? words : null
                        });
                    }
                }
            });
            return lines;
        }

        async function loadLyrics(track, api) {
            try {
                const lyricId = track.lyric_id || track.id;
                
                if (debugConsole) debugConsole.info('æ­Œè¯', `å¼€å§‹è¯·æ±‚æ­Œè¯æ•°æ®ï¼Œæ­Œè¯ID: ${lyricId}, API: ${api}`);
                
                let lyricData;
                if (api === 'tunehub') {
                    // TuneHub API - ç›´æ¥æ„å»ºURL
                    const apiConfig = API_CONFIG.tunehub;
                    const url = new URL(apiConfig.baseUrl, location.origin);
                    url.searchParams.append('source', track.platform || track.source || sourceSelect.value);
                    url.searchParams.append('id', lyricId);
                    url.searchParams.append('type', 'lrc');
                    
                    const response = await fetch(url.toString());
                    if (response.ok) {
                        const text = await response.text();
                        lyricData = { lyric: text };
                    }
                } else {
                    // åŸAPI
                    lyricData = await apiRequest({
                        types: 'lyric',
                        source: track.platform || track.source || sourceSelect.value,
                        id: lyricId
                    });
                }
                
                mergedLyricsData = null;
                
                if (!lyricData || (!lyricData.lyric && !lyricData.tlyric)) {
                    if (debugConsole) debugConsole.warn('æ­Œè¯', `æœªæ‰¾åˆ°æ­Œè¯æ•°æ®ï¼Œæ­Œè¯ID: ${lyricId}`);
                    const noLyric = '<div class="loading">æš‚æ— æ­Œè¯</div>';
                    lyricsContent.innerHTML = noLyric;
                    fullscreenLyricsLines.innerHTML = noLyric;
                    return;
                }
                
                if (debugConsole) debugConsole.info('æ­Œè¯', `æˆåŠŸè·å–æ­Œè¯æ•°æ®ï¼ŒåŸå§‹æ­Œè¯é•¿åº¦: ${lyricData.lyric ? lyricData.lyric.length : 0}ï¼Œç¿»è¯‘æ­Œè¯é•¿åº¦: ${lyricData.tlyric ? lyricData.tlyric.length : 0}`);
                
                const originalLines = parseLRC(lyricData.lyric);
                const translationLines = parseLRC(lyricData.tlyric);
                
                // åˆå¹¶å¹¶æ’åºæ­Œè¯
                const combinedLines = originalLines.map(o => {
                    const t = translationLines.find(t => t.time === o.time);
                    return {
                        time: o.time,
                        original: o.text,
                        translation: t ? t.text : null,
                        words: o.words
                    };
                }).sort((a, b) => a.time - b.time);

                mergedLyricsData = combinedLines;
                if (debugConsole) debugConsole.success('æ­Œè¯', `æ­Œè¯è§£æå®Œæˆï¼Œå…± ${combinedLines.length} è¡Œæ­Œè¯`);
                displayMergedLyrics(combinedLines);
            } catch (error) {
                const errorMsg = `æ­Œè¯åŠ è½½å¤±è´¥: ${error.message}\næ­Œè¯ID: ${track.lyric_id || track.id}\né”™è¯¯å †æ ˆ: ${error.stack}`;
                if (debugConsole) debugConsole.error('æ­Œè¯', errorMsg);
            }
        }

        function displayMergedLyrics(lines) {
            try {
                lyricsContent.innerHTML = '';
                fullscreenLyricsLines.innerHTML = '';
                
                // æ€§èƒ½ä¼˜åŒ–ï¼šæ­Œè¯æ›´æ–°æ—¶æ¸…é™¤ç¼“å­˜
                if (typeof invalidateLyricsCache === 'function') {
                    invalidateLyricsCache();
                }
                
                if (lines.length === 0) {
                    if (debugConsole) debugConsole.warn('æ­Œè¯', 'æ­Œè¯æ•°æ®ä¸ºç©ºï¼Œæ— æ­Œè¯å¯æ˜¾ç¤º');
                    const noLyric = '<div class="loading">æš‚æ— æ­Œè¯</div>';
                    lyricsContent.innerHTML = noLyric;
                    fullscreenLyricsLines.innerHTML = noLyric;
                    return;
                }

                const fragMini = document.createDocumentFragment();
                const fragFull = document.createDocumentFragment();
                
                lines.forEach(l => {
                    const createLineHtml = (text, isOriginal = true, isFullscreen = false) => {
                        if (l.words && isOriginal) {
                            return l.words.map(w => 
                                `<span class="word-highlight" data-word-time="${w.time}">${w.text}</span>`
                            ).join('');
                        }
                        return text;
                    };

                    // Mini Player Rendering
                    const div = document.createElement('div');
                    div.className = 'lyric-line';
                    div.dataset.time = l.time;
                    div.innerHTML = `
                        <span class="original-text">${createLineHtml(l.original, true, false)}</span>
                        ${l.translation ? `<span class="translation-text">${l.translation}</span>` : ''}
                    `;
                    div.onclick = () => {
                        audioPlayer.currentTime = l.time;
                        userScrolledLyrics = false; // ç‚¹å‡»æ­Œè¯åé‡ç½®æ»šåŠ¨çŠ¶æ€
                        if (debugConsole) debugConsole.info('æ­Œè¯', `ç‚¹å‡»æ­Œè¯è·³è½¬åˆ°: ${l.time} ç§’`);
                    };
                    fragMini.appendChild(div);
                    
                    // Fullscreen Player Rendering
                    const divFull = document.createElement('div');
                    divFull.className = 'fullscreen-lyric-line';
                    divFull.dataset.time = l.time;
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'fullscreen-line-wrapper';
                    
                    const original = document.createElement('span');
                    original.className = 'fullscreen-original-text';
                    original.innerHTML = createLineHtml(l.original, true, true);
                    wrapper.appendChild(original);

                    if (l.translation) {
                        const translation = document.createElement('span');
                        translation.className = 'fullscreen-translation-text';
                        translation.textContent = l.translation;
                        wrapper.appendChild(translation);
                    }

                    divFull.appendChild(wrapper);
                    divFull.onclick = () => {
                        audioPlayer.currentTime = l.time;
                        userScrolledLyrics = false;
                    };
                    fragFull.appendChild(divFull);
                });
                
                lyricsContent.appendChild(fragMini);
                fullscreenLyricsLines.appendChild(fragFull);
                
                if (debugConsole) debugConsole.success('æ­Œè¯æ¸²æŸ“', `æˆåŠŸæ¸²æŸ“ ${lines.length} è¡Œæ­Œè¯`);
            } catch (error) {
                const errorMsg = `æ­Œè¯æ¸²æŸ“å¤±è´¥: ${error.message}\né”™è¯¯å †æ ˆ: ${error.stack}`;
                if (debugConsole) debugConsole.error('æ­Œè¯æ¸²æŸ“', errorMsg);
            }
        }

        // æ€§èƒ½ä¼˜åŒ–ï¼šæ­Œè¯é«˜äº®ç¼“å­˜å’ŒèŠ‚æµ
        let _cachedMiniLines = null;
        let _cachedFullLines = null;
        let _lastActiveIdx = -1;
        let _scrollThrottleTimer = null;
        const SCROLL_THROTTLE_MS = 150; // æ»šåŠ¨èŠ‚æµé—´éš”
        
        // ç¼“å­˜æ­Œè¯è¡ŒDOMå¼•ç”¨ï¼ˆæ­Œè¯æ›´æ–°æ—¶éœ€è¦è°ƒç”¨ invalidateLyricsCacheï¼‰
        function invalidateLyricsCache() {
            _cachedMiniLines = null;
            _cachedFullLines = null;
            _lastActiveIdx = -1;
        }
        
        function highlightCurrentLyric(time) {
            if (!mergedLyricsData) return;
            
            // äºŒåˆ†æŸ¥æ‰¾ä¼˜åŒ–ï¼ˆæ›¿ä»£çº¿æ€§éå†ï¼‰
            let activeIdx = -1;
            let lo = 0, hi = mergedLyricsData.length - 1;
            while (lo <= hi) {
                const mid = (lo + hi) >>> 1;
                if (mergedLyricsData[mid].time <= time + 0.2) {
                    activeIdx = mid;
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
            
            if (activeIdx === -1) return;
            
            // å¦‚æœç´¢å¼•æ²¡å˜ï¼Œè·³è¿‡DOMæ“ä½œ
            if (activeIdx === _lastActiveIdx) return;
            
            // ç¼“å­˜DOMæŸ¥è¯¢ç»“æœï¼ˆåªåœ¨é¦–æ¬¡æˆ–ç¼“å­˜å¤±æ•ˆæ—¶æŸ¥è¯¢ï¼‰
            if (!_cachedMiniLines) {
                _cachedMiniLines = lyricsContent.querySelectorAll('.lyric-line');
            }
            if (!_cachedFullLines) {
                _cachedFullLines = fullscreenLyricsLines.querySelectorAll('.fullscreen-lyric-line');
            }
            
            // åªç§»é™¤ä¸Šä¸€ä¸ªæ¿€æ´»è¡Œçš„ç±»ï¼ˆè€Œééå†æ‰€æœ‰ï¼‰
            if (_lastActiveIdx >= 0) {
                if (_cachedMiniLines[_lastActiveIdx]) {
                    _cachedMiniLines[_lastActiveIdx].classList.remove('active');
                }
                if (_cachedFullLines[_lastActiveIdx]) {
                    _cachedFullLines[_lastActiveIdx].classList.remove('active');
                }
            }
            
            _lastActiveIdx = activeIdx;
            
            // --- Sync Mini Player ---
            if (_cachedMiniLines[activeIdx]) {
                _cachedMiniLines[activeIdx].classList.add('active');
                // èŠ‚æµ scrollIntoViewï¼Œé¿å…é¢‘ç¹è§¦å‘å›æµ
                if (!userScrolledLyrics && !_scrollThrottleTimer) {
                    _scrollThrottleTimer = setTimeout(() => {
                        _scrollThrottleTimer = null;
                        if (_cachedMiniLines[_lastActiveIdx]) {
                            _cachedMiniLines[_lastActiveIdx].scrollIntoView({behavior: 'smooth', block: 'center'});
                        }
                    }, SCROLL_THROTTLE_MS);
                }
            }
            
            // --- Sync Fullscreen Player ---
            if (_cachedFullLines[activeIdx]) {
                _cachedFullLines[activeIdx].classList.add('active');
                // å…¨å±æ­Œè¯ä¹ŸèŠ‚æµæ»šåŠ¨
                if (!_scrollThrottleTimer) {
                    _scrollThrottleTimer = setTimeout(() => {
                        _scrollThrottleTimer = null;
                        if (_cachedFullLines[_lastActiveIdx]) {
                            _cachedFullLines[_lastActiveIdx].scrollIntoView({behavior: 'smooth', block: 'center'});
                        }
                    }, SCROLL_THROTTLE_MS);
                }
            }
            
            // é€è¯é«˜äº®é€»è¾‘ - ä¼˜åŒ–ï¼šä½¿ç”¨ CSS ç±»è€Œéå†…è”æ ·å¼
            if (mergedLyricsData[activeIdx] && mergedLyricsData[activeIdx].words) {
                 const targetLine = _cachedMiniLines[activeIdx] || _cachedFullLines[activeIdx];
                 if (targetLine) {
                     const currentLineWords = targetLine.querySelectorAll('.word-highlight');
                     currentLineWords.forEach(wordSpan => {
                         const wordTime = parseFloat(wordSpan.dataset.wordTime || wordSpan.dataset['word-time'] || 0);
                         // ä½¿ç”¨ classList ä»£æ›¿ç›´æ¥ä¿®æ”¹ style
                         if (wordTime <= time) {
                             wordSpan.classList.add('word-active');
                         } else {
                             wordSpan.classList.remove('word-active');
                         }
                     });
                 }
            }
        }

        function formatTime(s) {
            if(isNaN(s) || s < 0) return '0:00';
            const m = Math.floor(s/60);
            const se = Math.floor(s%60);
            return `${m}:${se<10?'0':''}${se}`;
        }

        // --- Event Listeners ---
        
        searchBtn.onclick = () => {
            if (debugConsole) debugConsole.info('æœç´¢', `æ‰‹åŠ¨è§¦å‘æœç´¢: "${searchInput.value}" (API: ${apiSelect.value}, æº: ${sourceSelect.value})`);
            searchMusic(searchInput.value, sourceSelect.value);
        };
        
        searchInput.onkeypress = (e) => {
            if (e.key === 'Enter') {
                if (debugConsole) debugConsole.info('æœç´¢', `å›è½¦é”®è§¦å‘æœç´¢: "${searchInput.value}"`);
                searchBtn.click();
            }
        };
        
        // æ’­æ”¾æ§åˆ¶
        const togglePlay = async () => {
            try { markUserGesture(); } catch (_) {}
            if(audioPlayer.paused) {
                if(audioPlayer.src) {
                    if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'ç‚¹å‡»æ’­æ”¾æŒ‰é’®ï¼Œå¼€å§‹æ’­æ”¾');
                    // Fix: iOS éœ€ç”¨æˆ·æ‰‹åŠ¿è§£é” + AudioContext resume
                    await safePlayAudio('togglePlay');
                } else {
                    if (debugConsole) debugConsole.warn('æ’­æ”¾æ§åˆ¶', 'ç‚¹å‡»æ’­æ”¾æŒ‰é’®ï¼Œä½†æ— éŸ³é¢‘æºå¯æ’­æ”¾');
                }
            } else {
                if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'ç‚¹å‡»æš‚åœæŒ‰é’®ï¼Œæš‚åœæ’­æ”¾');
                audioPlayer.pause();
            }
        };
        
        playBtn.onclick = togglePlay;
        fullscreenPlayBtn.onclick = togglePlay;

        // Fix: iOS å…³é”®æ’­æ”¾æŒ‰é’®è¡¥å…… touch/mouse äº‹ä»¶ï¼ˆä¸åˆ é™¤åŸ click/onclickï¼‰
        bindUnifiedPress(playBtn, togglePlay, 'playBtn');
        bindUnifiedPress(fullscreenPlayBtn, togglePlay, 'fullscreenPlayBtn');

        
        audioPlayer.onplay = () => {
            playBtn.innerHTML = 'â¸';
            fullscreenPlayBtn.innerHTML = 'â¸';
            if (debugConsole) debugConsole.info('æ’­æ”¾çŠ¶æ€', 'éŸ³é¢‘å¼€å§‹æ’­æ”¾');
        };
        
        audioPlayer.onpause = () => {
            playBtn.innerHTML = 'â–¶';
            fullscreenPlayBtn.innerHTML = 'â–¶';
            if (debugConsole) debugConsole.info('æ’­æ”¾çŠ¶æ€', 'éŸ³é¢‘æš‚åœæ’­æ”¾');
        };
        
        // Fix: æ·»åŠ éŸ³é¢‘é”™è¯¯å¤„ç†
        audioPlayer.onerror = (e) => {
            const error = audioPlayer.error;
            let errorMsg = 'æœªçŸ¥é”™è¯¯';
            if (error) {
                switch(error.code) {
                    case 1: errorMsg = 'MEDIA_ERR_ABORTED - ç”¨æˆ·ä¸­æ­¢'; break;
                    case 2: errorMsg = 'MEDIA_ERR_NETWORK - ç½‘ç»œé”™è¯¯'; break;
                    case 3: errorMsg = 'MEDIA_ERR_DECODE - è§£ç é”™è¯¯'; break;
                    case 4: errorMsg = 'MEDIA_ERR_SRC_NOT_SUPPORTED - æ ¼å¼ä¸æ”¯æŒ'; break;
                }
            }
            if (debugConsole) debugConsole.error('éŸ³é¢‘é”™è¯¯', `æ’­æ”¾å‡ºé”™: ${errorMsg}`);
        };
        
        prevBtn.onclick = fullscreenPrevBtn.onclick = () => {
            if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'ç‚¹å‡»ä¸Šä¸€æ›²æŒ‰é’®');
            if(currentTrack && searchResults.length) {
                const idx = searchResults.findIndex(t => t.id === currentTrack.id && t.api === currentTrack.api);
                const prevIdx = (idx - 1 + searchResults.length) % searchResults.length;
                const prev = searchResults[prevIdx];
                playTrack(prev);
            } else {
                if (debugConsole) debugConsole.warn('æ’­æ”¾æ§åˆ¶', 'æ— æ³•åˆ‡æ¢åˆ°ä¸Šä¸€æ›²ï¼šå½“å‰æ— æ­Œæ›²æˆ–æœç´¢ç»“æœ');
            }
        };

        // Fix: iOS ä¸Šä¸€æ›²æŒ‰é’®è¡¥å…… touch/mouse äº‹ä»¶ï¼ˆä¸åˆ é™¤åŸ click/onclickï¼‰
        bindUnifiedPress(prevBtn, prevBtn.onclick, 'prevBtn');
        bindUnifiedPress(fullscreenPrevBtn, fullscreenPrevBtn.onclick, 'fullscreenPrevBtn');
        
        nextBtn.onclick = fullscreenNextBtn.onclick = () => {
            if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'ç‚¹å‡»ä¸‹ä¸€æ›²æŒ‰é’®');
            if(currentTrack && searchResults.length) {
                const idx = searchResults.findIndex(t => t.id === currentTrack.id && t.api === currentTrack.api);
                const nextIdx = (idx + 1) % searchResults.length;
                const next = searchResults[nextIdx];
                playTrack(next);
            } else {
                if (debugConsole) debugConsole.warn('æ’­æ”¾æ§åˆ¶', 'æ— æ³•åˆ‡æ¢åˆ°ä¸‹ä¸€æ›²ï¼šå½“å‰æ— æ­Œæ›²æˆ–æœç´¢ç»“æœ');
            }
        };

        // Fix: iOS ä¸‹ä¸€æ›²æŒ‰é’®è¡¥å…… touch/mouse äº‹ä»¶ï¼ˆä¸åˆ é™¤åŸ click/onclickï¼‰
        bindUnifiedPress(nextBtn, nextBtn.onclick, 'nextBtn');
        bindUnifiedPress(fullscreenNextBtn, fullscreenNextBtn.onclick, 'fullscreenNextBtn');

        // UI Toggles
        fullscreenLyricsBtn.onclick = () => {
            if (debugConsole) debugConsole.info('ç•Œé¢', 'æ‰“å¼€å…¨å±æ­Œè¯æ¨¡å¼');
            fullscreenLyricsOverlay.classList.add('active');
        };
        
        closeFullscreenBtn.onclick = () => {
            if (debugConsole) debugConsole.info('ç•Œé¢', 'å…³é—­å…¨å±æ­Œè¯æ¨¡å¼');
            fullscreenLyricsOverlay.classList.remove('active');
        };
        
        // Progress Bars - ä¼˜åŒ–ï¼šä½¿ç”¨ RAF èŠ‚æµï¼Œé¿å…å¼ºåˆ¶å›æµ
        let _rafPending = false;
        let _lastPct = -1;
        let _lastFormattedTime = '';
        
        audioPlayer.ontimeupdate = () => {
            if (_rafPending) return; // èŠ‚æµï¼šå¦‚æœä¸Šä¸€å¸§è¿˜æ²¡å¤„ç†å®Œï¼Œè·³è¿‡
            _rafPending = true;
            
            requestAnimationFrame(() => {
                _rafPending = false;
                if (!audioPlayer.duration) return;
                
                const pct = (audioPlayer.currentTime / audioPlayer.duration) * 100;
                const formattedTime = formatTime(audioPlayer.currentTime);
                
                // åªåœ¨å€¼å˜åŒ–æ—¶æ›´æ–° DOMï¼Œå‡å°‘ä¸å¿…è¦çš„æ ·å¼å†™å…¥
                if (Math.abs(pct - _lastPct) > 0.1) {
                    _lastPct = pct;
                    // æ‰¹é‡å†™å…¥æ ·å¼ï¼Œä½¿ç”¨ transform ä»£æ›¿ widthï¼ˆä¸è§¦å‘å›æµï¼‰
                    progress.style.transform = `scaleX(${pct / 100})`;
                    progress.style.transformOrigin = 'left';
                    // progressHandle ä»ä½¿ç”¨ leftï¼ˆå·²æœ‰ will-change ä¼˜åŒ–ï¼‰
                    progressHandle.style.left = pct + '%';
                    fullscreenProgress.style.transform = `scaleX(${pct / 100})`;
                    fullscreenProgress.style.transformOrigin = 'left';
                }
                
                if (formattedTime !== _lastFormattedTime) {
                    _lastFormattedTime = formattedTime;
                    currentTime.textContent = formattedTime;
                }
                
                highlightCurrentLyric(audioPlayer.currentTime);
            });
        };
        
        audioPlayer.onloadedmetadata = () => {
            if (debugConsole) debugConsole.info('éŸ³é¢‘ä¿¡æ¯', `éŸ³é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆï¼Œæ—¶é•¿: ${formatTime(audioPlayer.duration)}`);
            duration.textContent = formatTime(audioPlayer.duration);
        };
        
        audioPlayer.onended = () => {
            if (debugConsole) debugConsole.info('æ’­æ”¾çŠ¶æ€', 'éŸ³é¢‘æ’­æ”¾ç»“æŸï¼Œè‡ªåŠ¨æ’­æ”¾ä¸‹ä¸€æ›²');
            nextBtn.click();
        };

        // Seek - æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜è¿›åº¦æ¡ä½ç½®ä¿¡æ¯
        let _progressBarRect = null;
        let _fullscreenProgressBarRect = null;
        
        const seek = (e, bar) => {
            if(!audioPlayer.duration) return;
            
            // ç¼“å­˜getBoundingClientRectç»“æœï¼Œæ‹–åŠ¨å¼€å§‹æ—¶è·å–ä¸€æ¬¡å³å¯
            let rect;
            if (bar === progressBar) {
                if (!_progressBarRect) _progressBarRect = bar.getBoundingClientRect();
                rect = _progressBarRect;
            } else {
                if (!_fullscreenProgressBarRect) _fullscreenProgressBarRect = bar.getBoundingClientRect();
                rect = _fullscreenProgressBarRect;
            }
            
            const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : undefined);
            if (clientX === undefined) return;

            const p = Math.max(0, Math.min(1, (clientX - rect.left)/rect.width));
            const newTime = p * audioPlayer.duration;
            audioPlayer.currentTime = newTime;
            if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', `è·³è½¬åˆ°: ${formatTime(newTime)} (${(p * 100).toFixed(0)}%)`);
        };
        
        // æ‹–åŠ¨ç»“æŸæ—¶æ¸…é™¤ç¼“å­˜
        const clearSeekCache = () => {
            _progressBarRect = null;
            _fullscreenProgressBarRect = null;
        };

        // Mini player seek
        progressBar.onmousedown = (e) => { 
            isDragging = true;
            clearSeekCache(); // å¼€å§‹æ‹–åŠ¨æ—¶åˆ·æ–°ç¼“å­˜
            if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'å¼€å§‹æ‹–åŠ¨è¿›åº¦æ¡');
            seek(e, progressBar); 
        };
        
        progressBar.ontouchstart = (e) => { 
            isDragging = true;
            clearSeekCache();
            if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'è§¦æ‘¸å¼€å§‹æ‹–åŠ¨è¿›åº¦æ¡');
            seek(e, progressBar); 
        };

        document.addEventListener('mousemove', (e) => { 
            if (isDragging) {
                seek(e, progressBar);
            }
        });
        
        document.addEventListener('touchmove', (e) => { 
            if (isDragging) {
                seek(e, progressBar);
            }
        });
        
        document.addEventListener('mouseup', () => { 
            if (isDragging) {
                if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'ç»“æŸæ‹–åŠ¨è¿›åº¦æ¡');
                isDragging = false; 
            }
        });
        
        document.addEventListener('touchend', () => { 
            if (isDragging) {
                if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'è§¦æ‘¸ç»“æŸæ‹–åŠ¨è¿›åº¦æ¡');
                isDragging = false; 
            }
        });
        
        // Fullscreen seek
        fullscreenProgressBar.onclick = (e) => {
            if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'ç‚¹å‡»å…¨å±è¿›åº¦æ¡');
            seek(e, fullscreenProgressBar);
        };
        
        fullscreenProgressBar.ontouchstart = (e) => {
            if (debugConsole) debugConsole.info('æ’­æ”¾æ§åˆ¶', 'è§¦æ‘¸å…¨å±è¿›åº¦æ¡');
            seek(e, fullscreenProgressBar);
        };

        // Mesh Gradient Speed Control
        speedSlider.oninput = (e) => {
            ANIMATION_SPEED_MULTIPLIER = parseFloat(e.target.value);
            if (debugConsole) debugConsole.info('æ¸å˜èƒŒæ™¯', `æ¸å˜åŠ¨ç”»é€Ÿåº¦è°ƒæ•´ä¸º: ${ANIMATION_SPEED_MULTIPLIER.toFixed(2)}x`);
        };

        // ä¿®å¤æ­Œè¯æ»šåŠ¨ - ç§»é™¤è‡ªåŠ¨è¿”å›é€»è¾‘
        lyricsContainer.addEventListener('wheel', (e) => {
            userScrolledLyrics = true;
            if (debugConsole) debugConsole.info('æ­Œè¯æ»šåŠ¨', 'ç”¨æˆ·æ‰‹åŠ¨æ»šåŠ¨æ­Œè¯ï¼Œç¦ç”¨è‡ªåŠ¨æ»šåŠ¨');
        });
        
        lyricsContainer.addEventListener('touchstart', () => {
            userScrolledLyrics = true;
            if (debugConsole) debugConsole.info('æ­Œè¯æ»šåŠ¨', 'ç”¨æˆ·è§¦æ‘¸æ­Œè¯ï¼Œç¦ç”¨è‡ªåŠ¨æ»šåŠ¨');
        });

        // Resize
        window.onresize = () => {
            if (debugConsole) debugConsole.info('çª—å£', 'çª—å£å¤§å°æ”¹å˜ï¼Œé‡æ–°è°ƒæ•´Canvas');
            resizeCanvas();
        };
        
        // Init
        audioPlayer.volume = 0.7;
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æ‰€æœ‰ç»„ä»¶
        window.onload = () => {
            // åˆå§‹åŒ–è°ƒè¯•æ§åˆ¶å°
            initDebugConsole();
            
            // å¯åŠ¨æ¸å˜åŠ¨ç”»
            startGradientAnimation();
            
            if (debugConsole) debugConsole.info('ç³»ç»Ÿ', 'é¡µé¢åŠ è½½å®Œæˆï¼Œå‡†å¤‡è‡ªåŠ¨æœç´¢æ¼”ç¤º');
            
            // å»¶è¿Ÿæ‰§è¡Œè‡ªåŠ¨æœç´¢ï¼Œç¡®ä¿æ‰€æœ‰ç»„ä»¶å·²åˆå§‹åŒ–
            setTimeout(() => {
                if (debugConsole) debugConsole.info('æœç´¢', 'è‡ªåŠ¨æœç´¢æ¼”ç¤ºï¼šå‘¨æ°ä¼¦ (åŸAPI - é…·æˆ‘éŸ³ä¹)');
                searchMusic('å‘¨æ°ä¼¦', 'kuwo');
            }, 800);
        };

        // é”™è¯¯æ•è·
        window.onerror = function(message, source, lineno, colno, error) {
            const errorMsg = `å…¨å±€JavaScripté”™è¯¯: ${message}\næ¥æº: ${source}\nè¡Œå·: ${lineno}, åˆ—å·: ${colno}\né”™è¯¯å †æ ˆ: ${error ? error.stack : 'æ— å †æ ˆä¿¡æ¯'}`;
            if (debugConsole) debugConsole.error('JavaScripté”™è¯¯', errorMsg);
            return false;
        };

        // æœªå¤„ç†çš„Promiseé”™è¯¯
        window.addEventListener('unhandledrejection', function(event) {
            const errorMsg = `æœªå¤„ç†çš„Promiseæ‹’ç»: ${event.reason}\nPromise: ${event.promise}\né”™è¯¯å †æ ˆ: ${event.reason ? event.reason.stack : 'æ— å †æ ˆä¿¡æ¯'}`;
            if (debugConsole) debugConsole.error('Promiseé”™è¯¯', errorMsg);
        });

    </script>

<script>

/* =========================================================
   å¤šèƒŒæ™¯ç³»ç»Ÿï¼ˆé›†æˆç‰ˆï¼‰- å…³é”®è¯´æ˜
   1) æœ¬è„šæœ¬åœ¨ä¸æ”¹åŠ¨åŸæ’­æ”¾å™¨æ ¸å¿ƒé€»è¾‘çš„å‰æä¸‹ï¼Œæ–°å¢ï¼š
      - Pixi åŠ¨æ€èƒŒæ™¯ï¼ˆçº¯ WebGLï¼Œæ— å¤–éƒ¨åº“ï¼‰
      - Mesh æ¸å˜èƒŒæ™¯ï¼ˆçº¯ WebGLï¼Œæ— å¤–éƒ¨åº“ï¼‰
      - èƒŒæ™¯ç®¡ç†å™¨ + èµ„æºé‡Šæ”¾ + æŠ˜å å¼æ§åˆ¶é¢æ¿
   2) èƒŒæ™¯æ›´æ–°ç­–ç•¥ï¼š
      - é»˜è®¤è·Ÿéšä¸“è¾‘å°é¢ï¼ˆMutationObserver ç›‘å¬ #albumArt.src å˜åŒ–ï¼‰
      - è‹¥ç”¨æˆ·åœ¨èƒŒæ™¯æ§åˆ¶é¢æ¿ä¸­æ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶/URLï¼Œå°†è‡ªåŠ¨å…³é—­â€œè·Ÿéšä¸“è¾‘å°é¢â€
   ========================================================= */

(() => {
    // 1. åˆå§‹åŒ–æ—¥å¿—ï¼ˆæŒ‰éœ€æ±‚å¿…é¡»åŒ…å«ï¼‰
    console.log("=== éŸ³ä¹æ’­æ”¾å™¨èƒŒæ™¯ç³»ç»Ÿå¯åŠ¨ ===");
    console.log("æ—¶é—´:", new Date().toISOString());
    console.log("å¯ç”¨åŠŸèƒ½:", ["å–è‰²å™¨", "æ’­æ”¾æ§åˆ¶", "KMeans", "APIè”åŠ¨"]);

    // 3. é”™è¯¯ç›‘æ§ï¼ˆæŒ‰éœ€æ±‚å¿…é¡»åŒ…å«ï¼‰
    window.addEventListener('error', (e) => {
        // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.error ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
        try { console.error("[å…¨å±€é”™è¯¯]", {
            æ¶ˆæ¯: e.message,
            æ–‡ä»¶: e.filename,
            è¡Œå·: e.lineno,
            åˆ—å·: e.colno,
            æ—¶é—´: new Date().toLocaleTimeString()
        }); } catch (e) { try { console.log("[å…¨å±€é”™è¯¯]", {
            æ¶ˆæ¯: e.message,
            æ–‡ä»¶: e.filename,
            è¡Œå·: e.lineno,
            åˆ—å·: e.colno,
            æ—¶é—´: new Date().toLocaleTimeString()
        }); } catch (_) {} }
    });

    window.addEventListener('unhandledrejection', (event) => {
        // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.error ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
        try { console.error("[æœªå¤„ç†Promiseæ‹’ç»]", {
            åŸå› : event.reason,
            æ—¶é—´: new Date().toLocaleTimeString()
        }); } catch (e) { try { console.log("[æœªå¤„ç†Promiseæ‹’ç»]", {
            åŸå› : event.reason,
            æ—¶é—´: new Date().toLocaleTimeString()
        }); } catch (_) {} }
    });

    // 4. çŠ¶æ€æŠ¥å‘Šå‡½æ•°ï¼ˆæŒ‰éœ€æ±‚å¿…é¡»æä¾›ï¼‰
    window.reportPlayerStatus = function() {
        const bgType = window.__bgManager ? window.__bgManager.getCurrentType() : 'æœªçŸ¥';
        const hasAlbumArt = !!document.getElementById('albumArt')?.src;
        const audio = document.getElementById('audioPlayer');
        const audioReady = !!audio;
        const hasKMeans = typeof window.kMeansQuantize === 'function' || typeof kMeansQuantize === 'function';
        const hasApi = typeof window.apiRequest === 'function' || typeof apiRequest === 'function';

        console.table({
            "åŠŸèƒ½æ¨¡å—": ["èƒŒæ™¯ç³»ç»Ÿ", "å–è‰²å™¨", "éŸ³é¢‘æ’­æ”¾", "APIè¿æ¥", "KMeansç®—æ³•"],
            "è¿è¡ŒçŠ¶æ€": [
                bgType ? `âœ“æ­£å¸¸ï¼ˆ${bgType}ï¼‰` : "âœ—å¼‚å¸¸",
                hasAlbumArt ? "âœ“æ­£å¸¸" : "âš æœªåŠ è½½å°é¢",
                audioReady ? "âœ“æ­£å¸¸" : "âœ—ç¼ºå°‘audioå…ƒç´ ",
                hasApi ? "âœ“æ­£å¸¸" : "âš æœªæ£€æµ‹åˆ°apiRequestï¼ˆå¯èƒ½åœ¨é—­åŒ…å†…ï¼‰",
                hasKMeans ? "âœ“æ­£å¸¸" : "âš æœªæ£€æµ‹åˆ°kMeansQuantizeï¼ˆå¯èƒ½åœ¨é—­åŒ…å†…ï¼‰"
            ],
            "æœ€åæ£€æµ‹": [new Date().toLocaleTimeString()]
        });
    };

    // =========================================================
    // å°å·¥å…·ï¼šå®‰å…¨æ—¥å¿—ï¼ˆåŒæ—¶è¾“å‡ºåˆ°æ§åˆ¶å°ä¸åŸè°ƒè¯•æ§åˆ¶å°ï¼‰
    // =========================================================
    function dcInfo(tag, msg) {
        try {
            // æ³¨æ„ï¼šåŸæ–‡ä»¶ä¸­ debugConsole æ˜¯ global lexicalï¼ˆletï¼‰ï¼Œè¿™é‡Œç›´æ¥è®¿é—®
            if (typeof debugConsole !== 'undefined' && debugConsole && typeof debugConsole.info === 'function') {
                debugConsole.info(tag, msg);
            }
        } catch (_) {}
    }
    function dcWarn(tag, msg) {
        try {
            if (typeof debugConsole !== 'undefined' && debugConsole && typeof debugConsole.warn === 'function') {
                debugConsole.warn(tag, msg);
            }
        } catch (_) {}
    }
    function dcError(tag, msg) {
        try {
            if (typeof debugConsole !== 'undefined' && debugConsole && typeof debugConsole.error === 'function') {
                debugConsole.error(tag, msg);
            }
        } catch (_) {}
    }

    // =========================================================
    // é»˜è®¤èƒŒæ™¯å°è£…ï¼ˆå¤ç”¨åŸæ’­æ”¾å™¨æ¸å˜èƒŒæ™¯ï¼‰
    // =========================================================
    class DefaultBackgroundSystem {
        constructor() {
            this.type = 'default';
            this.canvas = null;
        }

        init() {
            console.log("[é»˜è®¤èƒŒæ™¯] åˆå§‹åŒ–/æ¢å¤...");
            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'é»˜è®¤èƒŒæ™¯ï¼šåˆå§‹åŒ–/æ¢å¤');
            this.canvas = document.getElementById('gradientCanvas');
            if (this.canvas) this.canvas.style.display = 'block';
            const host = document.getElementById('bgHost');
            if (host) host.style.display = 'none';

            // Fix: ä½¿ç”¨ window æš´éœ²çš„å‡½æ•°æ¥å¯åŠ¨æ¸å˜åŠ¨ç”»
            try {
                if (typeof window.startGradientAnimation === 'function') {
                    window.startGradientAnimation();
                    console.log("[é»˜è®¤èƒŒæ™¯] é€šè¿‡ window.startGradientAnimation å¯åŠ¨æˆåŠŸ");
                } else {
                    console.warn("[é»˜è®¤èƒŒæ™¯] window.startGradientAnimation ä¸å¯ç”¨");
                }
            } catch (e) {
                console.warn("[é»˜è®¤èƒŒæ™¯] å¯åŠ¨å¤±è´¥:", e);
            }
            return '';
        }

        destroy() {
            console.log("[é»˜è®¤èƒŒæ™¯] åœæ­¢åŠ¨ç”»...");
            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'é»˜è®¤èƒŒæ™¯ï¼šåœæ­¢åŠ¨ç”»');
            // Fix: ä½¿ç”¨ window æš´éœ²çš„å‡½æ•°æ¥å–æ¶ˆåŠ¨ç”»
            try {
                if (typeof window.cancelGradientAnimation === 'function') {
                    window.cancelGradientAnimation();
                    console.log("[é»˜è®¤èƒŒæ™¯] é€šè¿‡ window.cancelGradientAnimation åœæ­¢æˆåŠŸ");
                }
            } catch (e) {
                console.warn("[é»˜è®¤èƒŒæ™¯] åœæ­¢å¤±è´¥:", e);
            }
            if (this.canvas) this.canvas.style.display = 'none';
        }

        async updateFromAlbum(url) {
            // Fix: ä½¿ç”¨ window æš´éœ²çš„å‡½æ•°æ¥æ›´æ–°ä¸“è¾‘å°é¢é¢œè‰²
            try {
                if (typeof window.updateGradientFromAlbum === 'function' && url) {
                    window.updateGradientFromAlbum(url);
                }
            } catch (e) {
                console.warn("[é»˜è®¤èƒŒæ™¯] updateFromAlbum å¼‚å¸¸:", e);
            }
        }

        getControlsHTML() {
            return '';
        }

        bindControls() {}
    }

    // =========================================================
    // === PixièƒŒæ™¯å®Œæ•´å°è£… ===
    // ï¼ˆä»¥ä¸‹æ ¸å¿ƒæ¸²æŸ“é€»è¾‘å®Œæ•´å¤åˆ¶è‡ª pixi-dynamic-background 2.htmlï¼Œ
    //  ä»…å¯¹ resize/RAF å¢åŠ å¯é‡Šæ”¾èƒ½åŠ›ï¼Œå¹¶åŠ å…¥ destroy() åšèµ„æºæ¸…ç†ï¼‰
    // =========================================================
    class PixiBackgroundSystem {
        constructor() {
            // åŒ…å«pixi-dynamic-background 2.htmlçš„æ‰€æœ‰å˜é‡å’Œå‡½æ•°ï¼ˆå®Œæ•´å¤åˆ¶ï¼‰
            // ============================================
            // é…ç½® - ä¿®æ”¹è¿™é‡Œå¯ä»¥æ›´æ¢é»˜è®¤å›¾ç‰‡
            // ============================================
            this.DEFAULT_IMAGE_URL = 'https://imge.kugou.com/stdmusic/orig/20150718/20150718214459760936.jpg';
            // ============================================

            // =============== WebGL åŠ¨æ€èƒŒæ™¯æ¸²æŸ“å™¨ ===============
            // å®Œå…¨ä¸ä¾èµ–å¤–éƒ¨åº“ï¼Œçº¯WebGLå®ç° - ç›´æ¥ä»html-music-mainé¡¹ç›®æŠ„è¿‡æ¥çš„é€»è¾‘

            const vertexShaderSource = `
                attribute vec2 a_position;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                    v_texCoord = a_texCoord;
                }
            `;

            // Kawaseæ¨¡ç³Š - ä»pixi-filtersçš„KawaseBlurFilteræŠ„è¿‡æ¥
            const kawaseBlurFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                uniform vec2 u_resolution;
                uniform float u_offset;

                void main() {
                    vec2 texelSize = 1.0 / u_resolution;
                    vec2 uv = v_texCoord;

                    vec4 color = texture2D(u_texture, uv) * 0.2;
                    color += texture2D(u_texture, uv + vec2(-u_offset - 0.5, -u_offset - 0.5) * texelSize) * 0.2;
                    color += texture2D(u_texture, uv + vec2( u_offset + 0.5, -u_offset - 0.5) * texelSize) * 0.2;
                    color += texture2D(u_texture, uv + vec2(-u_offset - 0.5,  u_offset + 0.5) * texelSize) * 0.2;
                    color += texture2D(u_texture, uv + vec2( u_offset + 0.5,  u_offset + 0.5) * texelSize) * 0.2;

                    gl_FragColor = color;
                }
            `;

            // æ‰­æ›²æ•ˆæœ - ä»pixi-filtersçš„TwistFilteræŠ„è¿‡æ¥
            const twistFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                uniform vec2 u_center;
                uniform float u_radius;
                uniform float u_angle;
                uniform vec2 u_resolution;

                void main() {
                    vec2 coord = v_texCoord - u_center;

                    float aspect = u_resolution.x / u_resolution.y;
                    coord.x *= aspect;

                    float dist = length(coord);

                    if (dist < u_radius) {
                        float percent = (u_radius - dist) / u_radius;
                        float theta = percent * percent * u_angle;
                        float s = sin(theta);
                        float c = cos(theta);
                        coord = vec2(
                            coord.x * c - coord.y * s,
                            coord.x * s + coord.y * c
                        );
                    }

                    coord.x /= aspect;
                    vec2 uv = coord + u_center;

                    gl_FragColor = texture2D(u_texture, uv);
                }
            `;

            // é¥±å’Œåº¦è°ƒæ•´ - ä»pixi-filtersçš„AdjustmentFilteræŠ„è¿‡æ¥
            const saturationFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                uniform float u_saturation;

                void main() {
                    vec4 color = texture2D(u_texture, v_texCoord);
                    float gray = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
                    color.rgb = mix(vec3(gray), color.rgb, u_saturation);
                    gl_FragColor = color;
                }
            `;

            // åˆæˆç€è‰²å™¨ - å°†å¤šä¸ªç²¾çµå åŠ æ¸²æŸ“
            const compositeFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                uniform vec2 u_position;
                uniform float u_rotation;
                uniform float u_scale;
                uniform vec2 u_resolution;

                void main() {
                    vec2 uv = v_texCoord;
                    vec2 center = u_position;
                    vec2 coord = uv - center;

                    float aspect = u_resolution.x / u_resolution.y;
                    coord.x *= aspect;

                    float s = sin(u_rotation);
                    float c = cos(u_rotation);
                    coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);
                    coord /= u_scale;
                    coord.x /= aspect;

                    uv = coord + vec2(0.5);

                    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                        gl_FragColor = vec4(0.0);
                    } else {
                        gl_FragColor = texture2D(u_texture, uv);
                    }
                }
            `;

            const copyFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                void main() {
                    gl_FragColor = texture2D(u_texture, v_texCoord);
                }
            `;

            // ä»LyricsScene.tsæŠ„è¿‡æ¥çš„ç²¾çµé…ç½®
            const self = this;
            this.LyricsScene = class LyricsScene {
                constructor(container) {
                    this.container = container;
                    this.paused = false;
                    this._destroyed = false;
                    this._rafId = null;
                    this._onResize = null;

                    // ç²¾çµé…ç½® - ç›´æ¥ä»LyricsScene.tsæŠ„è¿‡æ¥
                    this.sprites = [
                        { x: 0.5, y: 0.5, rotation: 0, scale: 1.25, rotSpeed: 0.003 },
                        { x: 0.4, y: 0.4, rotation: 0, scale: 0.8, rotSpeed: -0.008 },
                        { x: 0.5, y: 0.5, rotation: 0, scale: 0.5, rotSpeed: -0.006, orbit: true, orbitRadius: 0.25, orbitMult: 0.75 },
                        { x: 0.5, y: 0.5, rotation: 0, scale: 0.25, rotSpeed: 0.004, orbit: true, orbitRadius: 0.25, orbitOffset: 0.05, orbitMult: 0.75 }
                    ];

                    // æ»¤é•œè®¾ç½® - ç›´æ¥ä»LyricsScene.tsæŠ„è¿‡æ¥çš„bluré…ç½®
                    this.filters = {
                        twist: true,
                        blur: [false, false, false, false, false],
                        saturation: true
                    };
                    // KawaseBlurFilterçš„é…ç½®ï¼š[blur, quality]
                    // new KawaseBlurFilter(5, 1), new KawaseBlurFilter(10, 1), new KawaseBlurFilter(20, 2), new KawaseBlurFilter(40, 2), new KawaseBlurFilter(80, 2)
                    this.blurConfigs = [
                        { blur: 5, quality: 1 },
                        { blur: 10, quality: 1 },
                        { blur: 20, quality: 2 },
                        { blur: 40, quality: 2 },
                        { blur: 80, quality: 2 }
                    ];

                    this.initWebGL();
                    this.createShaders();
                    this.createBuffers();
                    this.createFramebuffers();

                    // â˜… ä¸ºäº†å¯é”€æ¯ï¼Œä¿å­˜ resize handlerï¼ˆåŸæ–‡ä»¶ä¸ºåŒ¿åå‡½æ•°ï¼Œè¿™é‡Œåªåšç­‰ä»·å¢å¼ºï¼‰
                    this._onResize = () => this.resize();
                    window.addEventListener('resize', this._onResize);
                    this.animate();
                }

                initWebGL() {
                    this.canvas = document.createElement('canvas');
                    this.canvas.width = this.container.clientWidth;
                    this.canvas.height = this.container.clientHeight;
                    this.container.appendChild(this.canvas);

                    this.gl = this.canvas.getContext('webgl', { 
                        alpha: false,
                        premultipliedAlpha: false,
                        preserveDrawingBuffer: false,
                        powerPreference: 'low-power'
                    });

                    if (!this.gl) throw new Error('WebGL not supported');

                    this.gl.enable(this.gl.BLEND);
                    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                }

                createShader(type, source) {
                    const gl = this.gl;
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.error ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
                        try { console.error('Shader error:', gl.getShaderInfoLog(shader)); } catch (e) { try { console.log('Shader error:', gl.getShaderInfoLog(shader)); } catch (_) {} }
                        return null;
                    }
                    // è®°å½• shader ä¾¿äº destroy
                    if (!this._shaders) this._shaders = [];
                    this._shaders.push(shader);
                    return shader;
                }

                createProgram(vertexSource, fragmentSource) {
                    const gl = this.gl;
                    const program = gl.createProgram();
                    const vs = this.createShader(gl.VERTEX_SHADER, vertexSource);
                    const fs = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);
                    gl.attachShader(program, vs);
                    gl.attachShader(program, fs);
                    gl.linkProgram(program);
                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                        // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.error ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
                        try { console.error('Program error:', gl.getProgramInfoLog(program)); } catch (e) { try { console.log('Program error:', gl.getProgramInfoLog(program)); } catch (_) {} }
                        return null;
                    }
                    if (!this._programs) this._programs = [];
                    this._programs.push(program);
                    return program;
                }

                createShaders() {
                    this.copyProgram = this.createProgram(vertexShaderSource, copyFragmentShader);
                    this.compositeProgram = this.createProgram(vertexShaderSource, compositeFragmentShader);
                    this.twistProgram = this.createProgram(vertexShaderSource, twistFragmentShader);
                    this.blurProgram = this.createProgram(vertexShaderSource, kawaseBlurFragmentShader);
                    this.saturationProgram = this.createProgram(vertexShaderSource, saturationFragmentShader);
                }

                createBuffers() {
                    const gl = this.gl;
                    const positions = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
                    const texCoords = new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]);

                    this.positionBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

                    this.texCoordBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
                }

                createFramebuffers() {
                    const gl = this.gl;
                    const w = this.canvas.width;
                    const h = this.canvas.height;

                    if (this.framebuffers) {
                        this.framebuffers.forEach(fb => gl.deleteFramebuffer(fb));
                        this.fbTextures.forEach(tex => gl.deleteTexture(tex));
                    }

                    this.framebuffers = [];
                    this.fbTextures = [];

                    for (let i = 0; i < 3; i++) {
                        const fb = gl.createFramebuffer();
                        const tex = gl.createTexture();

                        gl.bindTexture(gl.TEXTURE_2D, tex);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);

                        this.framebuffers.push(fb);
                        this.fbTextures.push(tex);
                    }
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }

                // çº¹ç†ä¿æŠ¤ï¼šé˜²æ­¢ WebGL è¯»å†™å†²çªï¼ˆFeedback loopï¼‰
                // - è‹¥æŸä¸ªçº¹ç†æ—¢ä½œä¸º framebuffer çš„é™„ç€çº¹ç†ï¼Œåˆä»ç»‘å®šåœ¨ä»»æ„ texture unit ä¸Šï¼ŒæŸäº›é©±åŠ¨ä¼šç›´æ¥æŠ¥é”™ã€‚
                // - è¿™é‡Œåœ¨è¿›å…¥æ¯ä¸ª pass å‰ï¼Œä¸»åŠ¨æŠŠâ€œè¾“å‡ºçº¹ç†â€ä»å¸¸ç”¨çš„ texture unit ä¸Šè§£ç»‘ï¼Œç¡®ä¿è¯»å†™å½»åº•è§£è€¦ã€‚
                detachTextureFromUnits(texture) {
                    const gl = this.gl;
                    if (!gl || !texture) return;

                    // WebGL ä¸æä¾›æšä¸¾å…¨éƒ¨ç»‘å®šçŠ¶æ€çš„é«˜æ•ˆ APIï¼Œè¿™é‡Œå¯¹å‰ 8 ä¸ª unit åšä¿æŠ¤å³å¯ï¼ˆè¶³å¤Ÿè¦†ç›–æœ¬åœºæ™¯ï¼‰ã€‚
                    const maxUnits = Math.min(8, gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS) || 8);
                    for (let u = 0; u < maxUnits; u++) {
                        gl.activeTexture(gl.TEXTURE0 + u);
                        const bound = gl.getParameter(gl.TEXTURE_BINDING_2D);
                        if (bound === texture) gl.bindTexture(gl.TEXTURE_2D, null);
                    }
                    gl.activeTexture(gl.TEXTURE0);
                }

                setupProgram(program) {
                    const gl = this.gl;
                    gl.useProgram(program);

                    const posLoc = gl.getAttribLocation(program, 'a_position');
                    const texLoc = gl.getAttribLocation(program, 'a_texCoord');

                    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                    gl.enableVertexAttribArray(texLoc);
                    gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
                }

                async loadImage(source) {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        img.onload = () => { this.uploadTexture(img); resolve(); };
                        img.onerror = () => { this.createFallbackTexture(); resolve(); };

                        if (source instanceof File) {
                            const reader = new FileReader();
                            reader.onload = (e) => { img.src = e.target.result; };
                            reader.readAsDataURL(source);
                        } else {
                            img.src = source;
                        }
                    });
                }
                createFallbackTexture() {
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = 512;
                    const ctx = canvas.getContext('2d');

                    // Deep Nebulaï¼ˆApple Music é£æ ¼æ·±è‰²æµå…‰ï¼‰ï¼šé»‘åº• + éœ“è™¹å½©æ–‘ + è½»å¾®æ˜Ÿå°˜
                    ctx.fillStyle = '#0B0B0B';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // è½»å¾®æš—è§’ï¼Œè®©ç”»é¢æ›´â€œæ·±â€
                    const vignette = ctx.createRadialGradient(256, 256, 40, 256, 256, 420);
                    vignette.addColorStop(0, 'rgba(11,11,11,0)');
                    vignette.addColorStop(1, 'rgba(0,0,0,0.85)');
                    ctx.fillStyle = vignette;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    const neon = ['#921E58', '#1989FA', '#9C27B0', '#00E5FF', '#FF2EC4'];
                    const hexToRgb = (hex) => {
                        const h = (hex || '#000000').replace('#', '');
                        const n = parseInt(h.length === 3 ? h.split('').map(ch => ch + ch).join('') : h, 16);
                        return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
                    };
                    const rand = (a, b) => a + Math.random() * (b - a);

                    // å½©æ–‘ï¼ˆå¸¦ alpha ä¸ blur/glowï¼‰
                    ctx.globalCompositeOperation = 'lighter';
                    for (let i = 0; i < 18; i++) {
                        const color = neon[i % neon.length];
                        const rgb = hexToRgb(color);
                        const x = rand(-40, 552);
                        const y = rand(-40, 552);
                        const r = rand(70, 220);

                        ctx.globalAlpha = rand(0.08, 0.22);
                        ctx.shadowBlur = r * 0.55;
                        ctx.shadowColor = `rgba(${rgb.r},${rgb.g},${rgb.b},0.9)`;

                        const g = ctx.createRadialGradient(x, y, 0, x, y, r);
                        g.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0.75)`);
                        g.addColorStop(0.45, `rgba(${rgb.r},${rgb.g},${rgb.b},0.22)`);
                        g.addColorStop(1, 'rgba(0,0,0,0)');

                        ctx.fillStyle = g;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // è½»å¾®æµå…‰çº¿æ¡ï¼ˆæ›´åƒâ€œæ¶²æ€ç»ç’ƒâ€çš„åŠ¨åŠ¿åº•çº¹ï¼‰
                    ctx.globalAlpha = 0.12;
                    ctx.shadowBlur = 18;
                    ctx.shadowColor = 'rgba(25,137,250,0.8)';
                    for (let i = 0; i < 8; i++) {
                        const y = rand(40, 472);
                        const h = rand(6, 16);
                        const rgb = hexToRgb(neon[(i + 1) % neon.length]);
                        const g = ctx.createLinearGradient(0, y, 512, y + h);
                        g.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
                        g.addColorStop(0.5, `rgba(${rgb.r},${rgb.g},${rgb.b},0.55)`);
                        g.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
                        ctx.fillStyle = g;
                        ctx.fillRect(0, y, 512, h);
                    }

                    // æ˜Ÿå°˜
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.shadowBlur = 0;
                    for (let i = 0; i < 140; i++) {
                        const x = Math.random() * 512;
                        const y = Math.random() * 512;
                        const s = Math.random() < 0.92 ? 1 : 2;
                        ctx.globalAlpha = rand(0.05, 0.14);
                        ctx.fillStyle = 'rgba(255,255,255,1)';
                        ctx.fillRect(x, y, s, s);
                    }

                    // æ”¶å°¾å¤ä½
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                    ctx.globalCompositeOperation = 'source-over';

                    this.uploadTexture(canvas);
                }

                uploadTexture(source) {
                    const gl = this.gl;
                    if (this.imageTexture) gl.deleteTexture(this.imageTexture);

                    this.imageTexture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, this.imageTexture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                }

                renderSprites() {
                    const gl = this.gl;
                    const w = this.canvas.width, h = this.canvas.height;

                    // å°†æ¸²æŸ“åˆ° framebufferï¼Œå¹¶å°†æ¸…å±é¢œè‰²è®¾ç½®ä¸ºå®Œå…¨é€æ˜ï¼Œé¿å…å‡ºç°é»‘è‰²èƒŒæ™¯
                    // çº¹ç†ä¿æŠ¤ï¼šç¡®ä¿è¾“å‡ºçº¹ç†ï¼ˆfbTextures[0]ï¼‰æœªç»‘å®šåˆ°ä»»ä½• texture unit
                    this.detachTextureFromUnits(this.fbTextures[0]);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[0]);
                    gl.viewport(0, 0, w, h);
                    // ä½¿ç”¨é€æ˜çš„æ¸…é™¤è‰²ï¼Œä»¥ä¾¿é€šè¿‡æ··åˆçœ‹åˆ°ä¸‹æ–¹èƒŒæ™¯
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);

                    if (!this.imageTexture) return;

                    this.setupProgram(this.compositeProgram);
                    gl.uniform2f(gl.getUniformLocation(this.compositeProgram, 'u_resolution'), w, h);

                    // æ ¹æ®ç”»å¸ƒçš„å®½é«˜æ¯”è°ƒæ•´ç²¾çµçš„ç¼©æ”¾ï¼Œç¡®ä¿åœ¨ä»»ä½•å±å¹•å°ºå¯¸ä¸‹æ²¡æœ‰é»‘è¾¹
                    const aspectRatio = Math.max(w, h) / Math.min(w, h);
                    const baseScales = [1.25, 0.8, 0.5, 0.25];
                    for (let idx = 0; idx < this.sprites.length; idx++) {
                        const sprite = this.sprites[idx];
                        sprite.scale = baseScales[idx] * aspectRatio;
                        gl.bindTexture(gl.TEXTURE_2D, this.imageTexture);
                        gl.uniform2f(gl.getUniformLocation(this.compositeProgram, 'u_position'), sprite.x, sprite.y);
                        gl.uniform1f(gl.getUniformLocation(this.compositeProgram, 'u_rotation'), sprite.rotation);
                        gl.uniform1f(gl.getUniformLocation(this.compositeProgram, 'u_scale'), sprite.scale);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                }
                applyTwist(inputIdx, outputFb) {
                    const gl = this.gl;
                    const w = this.canvas.width, h = this.canvas.height;

                    // çº¹ç†ä¿æŠ¤ï¼šé¿å…é‡‡æ ·ä¸å†™å…¥åŒä¸€çº¹ç†ï¼ˆFeedback loop formed between Framebuffer and active Textureï¼‰
                    let outputIdx = outputFb === this.framebuffers[1] ? 1 : 2;
                    if (inputIdx === outputIdx) {
                        outputIdx = outputIdx === 1 ? 2 : 1;
                        outputFb = this.framebuffers[outputIdx];
                    }
                    this.detachTextureFromUnits(this.fbTextures[outputIdx]);

                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFb);
                    gl.clearColor(0, 0, 0, 0);
                    gl.viewport(0, 0, w, h);
                    gl.clear(gl.COLOR_BUFFER_BIT);

                    this.setupProgram(this.twistProgram);
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, this.fbTextures[inputIdx]);

                    // TwistFilteré…ç½® - ä»LyricsScene.tsæŠ„è¿‡æ¥: angle: -3.25, radius: 900
                    gl.uniform2f(gl.getUniformLocation(this.twistProgram, 'u_center'), 0.5, 0.5);
                    gl.uniform1f(gl.getUniformLocation(this.twistProgram, 'u_radius'), 900.0 / Math.min(w, h));
                    gl.uniform1f(gl.getUniformLocation(this.twistProgram, 'u_angle'), -3.25);
                    gl.uniform2f(gl.getUniformLocation(this.twistProgram, 'u_resolution'), w, h);

                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }
                // Kawaseæ¨¡ç³Šéœ€è¦å¤šæ¬¡è¿­ä»£
                applyKawaseBlur(inputIdx, outputFb, blurConfig) {
                    const gl = this.gl;
                    const w = this.canvas.width, h = this.canvas.height;

                    let currentInput = inputIdx;
                    let currentOutputFb = outputFb;
                    let currentOutputIdx = outputFb === this.framebuffers[1] ? 1 : 2;

                    // çº¹ç†ä¿æŠ¤ï¼šåˆå§‹è¾“å‡ºä¸è¾“å…¥åŒ index æ—¶ï¼Œå…ˆåˆ‡åˆ°å¦ä¸€å— ping-pong ç¼“å†²
                    if (currentInput === currentOutputIdx) {
                        currentOutputIdx = currentOutputIdx === 1 ? 2 : 1;
                        currentOutputFb = this.framebuffers[currentOutputIdx];
                    }

                    // æ ¹æ®qualityè¿›è¡Œå¤šæ¬¡è¿­ä»£
                    const kernels = this.getKawaseKernels(blurConfig.blur, blurConfig.quality);

                    for (let i = 0; i < kernels.length; i++) {
                        // çº¹ç†ä¿æŠ¤ï¼šç¡®ä¿â€œå†™å…¥ç›®æ ‡çº¹ç†â€ä¸åœ¨ä»»ä½• texture unit ä¸Šä¿æŒç»‘å®š
                        this.detachTextureFromUnits(this.fbTextures[currentOutputIdx]);

                        gl.bindFramebuffer(gl.FRAMEBUFFER, currentOutputFb);
                        gl.clearColor(0, 0, 0, 0);
                        gl.viewport(0, 0, w, h);
                        gl.clear(gl.COLOR_BUFFER_BIT);

                        this.setupProgram(this.blurProgram);
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, this.fbTextures[currentInput]);
                        gl.uniform2f(gl.getUniformLocation(this.blurProgram, 'u_resolution'), w, h);
                        gl.uniform1f(gl.getUniformLocation(this.blurProgram, 'u_offset'), kernels[i]);

                        gl.drawArrays(gl.TRIANGLES, 0, 6);

                        // äº¤æ¢ç¼“å†²åŒº
                        if (i < kernels.length - 1) {
                            currentInput = currentOutputIdx;
                            currentOutputIdx = currentOutputIdx === 1 ? 2 : 1;
                            currentOutputFb = this.framebuffers[currentOutputIdx];
                        }
                    }

                    return currentOutputIdx;
                }

                // ä»pixi-filtersçš„KawaseBlurFilteræŠ„è¿‡æ¥çš„kernelè®¡ç®—
                getKawaseKernels(blur, quality) {
                    const kernels = [];
                    if (blur > 0) {
                        let k = blur;
                        const q = quality;
                        for (let i = 0; i < q; i++) {
                            kernels.push(k);
                            k *= 0.5;
                        }
                    }
                    return kernels.length > 0 ? kernels : [0];
                }
                applySaturation(inputIdx, outputFb) {
                    const gl = this.gl;
                    const w = this.canvas.width, h = this.canvas.height;

                    // çº¹ç†ä¿æŠ¤ï¼šé¿å…é‡‡æ ·ä¸å†™å…¥åŒä¸€çº¹ç†
                    let outputIdx = outputFb === this.framebuffers[1] ? 1 : 2;
                    if (inputIdx === outputIdx) {
                        outputIdx = outputIdx === 1 ? 2 : 1;
                        outputFb = this.framebuffers[outputIdx];
                    }
                    this.detachTextureFromUnits(this.fbTextures[outputIdx]);

                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFb);
                    gl.clearColor(0, 0, 0, 0);
                    gl.viewport(0, 0, w, h);
                    gl.clear(gl.COLOR_BUFFER_BIT);

                    this.setupProgram(this.saturationProgram);
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, this.fbTextures[inputIdx]);
                    // AdjustmentFilteré…ç½® - ä»LyricsScene.tsæŠ„è¿‡æ¥: saturation: 2.75
                    gl.uniform1f(gl.getUniformLocation(this.saturationProgram, 'u_saturation'), 2.75);

                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }

                copyToScreen(inputIdx) {
                    const gl = this.gl;
                    // æ¸…ç©ºé»˜è®¤å¸§ç¼“å†²åŒºï¼Œä½¿ç”¨é€æ˜èƒŒæ™¯ï¼Œè¿™æ ·å¦‚æœå†…å®¹æ²¡æœ‰å®Œå…¨è¦†ç›–åˆ™æ˜¾ç¤ºåé¢çš„æ¸å˜èƒŒæ™¯
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);

                    this.setupProgram(this.copyProgram);
                    gl.bindTexture(gl.TEXTURE_2D, this.fbTextures[inputIdx]);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }
                render() {
                    this.renderSprites();

                    let currentIdx = 0;

                    // é€‰æ‹©ä¸€ä¸ªä¸å½“å‰è¾“å…¥ä¸åŒçš„è¾“å‡ºç¼“å†²ï¼ˆåªåœ¨ 1/2 ä¹‹é—´ ping-pongï¼Œé¿å… 0 å·è¢«é‡å¤ç»‘å®šé€ æˆé©±åŠ¨æŠ¥é”™ï¼‰
                    const pickOutIdx = () => (currentIdx === 1 ? 2 : 1);

                    // æ‰­æ›²
                    if (this.filters.twist) {
                        const outIdx = pickOutIdx();
                        this.applyTwist(currentIdx, this.framebuffers[outIdx]);
                        currentIdx = outIdx;
                    }

                    // æ¨¡ç³Šå±‚ï¼ˆKawaseBlur å†…éƒ¨ä¼šæ ¹æ®è¿­ä»£æ¬¡æ•°å†³å®šæœ€ç»ˆè¾“å‡º idxï¼Œå› æ­¤è¿™é‡Œä»¥è¿”å›å€¼ä¸ºå‡†ï¼‰
                    for (let i = 0; i < 5; i++) {
                        if (this.filters.blur[i]) {
                            const outIdx = pickOutIdx();
                            currentIdx = this.applyKawaseBlur(currentIdx, this.framebuffers[outIdx], this.blurConfigs[i]);
                        }
                    }

                    // é¥±å’Œåº¦
                    if (this.filters.saturation) {
                        const outIdx = pickOutIdx();
                        this.applySaturation(currentIdx, this.framebuffers[outIdx]);
                        currentIdx = outIdx;
                    }

                    this.copyToScreen(currentIdx);
                }

                // ç²¾çµåŠ¨ç”» - ç›´æ¥ä»LyricsScene.tsçš„tickeræŠ„è¿‡æ¥
                updateSprites(deltaMS) {
                    const n = deltaMS / 33.333333;
                    // sprite 0
                    this.sprites[0].rotation += 0.003 * n;

                    // sprite 1
                    this.sprites[1].rotation -= 0.008 * n;

                    // sprite 2 - åœ†å‘¨è¿åŠ¨
                    this.sprites[2].rotation -= 0.006 * n;
                    this.sprites[2].x = 0.5 + 0.25 * Math.cos(this.sprites[2].rotation * 0.75);
                    this.sprites[2].y = 0.5 + 0.25 * Math.sin(this.sprites[2].rotation * 0.75);

                    // sprite 3 - åœ†å‘¨è¿åŠ¨å¸¦åç§»
                    this.sprites[3].rotation += 0.004 * n;
                    this.sprites[3].x = 0.5 + 0.05 + 0.25 * Math.cos(this.sprites[3].rotation * 0.75);
                    this.sprites[3].y = 0.5 + 0.05 + 0.25 * Math.sin(this.sprites[3].rotation * 0.75);
                }

                animate() {
                    if (this._destroyed) return;

                    if (!this.paused) {
                        const now = performance.now();
                        const delta = this.lastTime ? now - this.lastTime : 16.67;
                        this.lastTime = now;

                        this.updateSprites(delta);
                        this.render();
                    }
                    // â˜… ä¸ºäº†å¯é”€æ¯ï¼Œä¿å­˜ RAF id
                    this._rafId = requestAnimationFrame(() => this.animate());
                }

                updateFilters(options) {
                    this.filters.twist = options.twist;
                    this.filters.blur = options.blur;
                    this.filters.saturation = options.sat;
                }

                resize() {
                    this.canvas.width = this.container.clientWidth;
                    this.canvas.height = this.container.clientHeight;
                    this.createFramebuffers();
                }

                pause() { this.paused = true; }
                resume() { this.paused = false; this.lastTime = null; }

                // â˜… æ–°å¢ï¼šå®Œæ•´æ¸…ç†æ‰€æœ‰èµ„æº
                destroy() {
                    this._destroyed = true;

                    try {
                        if (this._rafId) cancelAnimationFrame(this._rafId);
                    } catch (_) {}

                    try {
                        if (this._onResize) window.removeEventListener('resize', this._onResize);
                    } catch (_) {}

                    const gl = this.gl;
                    if (!gl) return;

                    try {
                        if (this.imageTexture) gl.deleteTexture(this.imageTexture);
                    } catch (_) {}

                    try {
                        if (this.fbTextures) this.fbTextures.forEach(tex => { try { gl.deleteTexture(tex); } catch(_){} });
                        if (this.framebuffers) this.framebuffers.forEach(fb => { try { gl.deleteFramebuffer(fb); } catch(_){} });
                    } catch (_) {}

                    try { if (this.positionBuffer) gl.deleteBuffer(this.positionBuffer); } catch (_) {}
                    try { if (this.texCoordBuffer) gl.deleteBuffer(this.texCoordBuffer); } catch (_) {}

                    try {
                        if (this._programs) this._programs.forEach(p => { try { gl.deleteProgram(p); } catch(_){} });
                        if (this._shaders) this._shaders.forEach(s => { try { gl.deleteShader(s); } catch(_){} });
                    } catch (_) {}

                    try {
                        const ext = gl.getExtension('WEBGL_lose_context');
                        if (ext && ext.loseContext) ext.loseContext();
                    } catch (_) {}

                    try {
                        if (this.canvas && this.canvas.parentNode) this.canvas.parentNode.removeChild(this.canvas);
                    } catch (_) {}

                    this.gl = null;
                }
            };

            // è¿è¡Œæ€å˜é‡
            this.scene = null;
            this.layerEl = null;
            this._controlsAbort = null;
            this._isPlaying = true;
            this._lastImageSource = null;
        }

        async init(container) { 
            console.log("[PixièƒŒæ™¯] åˆå§‹åŒ–å¼€å§‹...");
            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'PixièƒŒæ™¯ï¼šåˆå§‹åŒ–å¼€å§‹...');
            const host = document.getElementById('bgHost');
            if (host) host.style.display = 'block';

            // åˆ›å»ºå›¾å±‚
            this.layerEl = document.createElement('div');
            this.layerEl.className = 'bg-layer';
            this.layerEl.style.position = 'absolute';
            this.layerEl.style.inset = '0';
            container.appendChild(this.layerEl);

            // åˆå§‹åŒ–åœºæ™¯
            this.scene = new this.LyricsScene(this.layerEl);

            // åˆæ¬¡åŠ è½½ï¼šè‹¥å·²æœ‰ä¸“è¾‘å°é¢åˆ™ç”¨ä¹‹ï¼Œå¦åˆ™ç”¨é»˜è®¤
            const firstUrl = window.__bgManager?.lastAlbumUrl || this.DEFAULT_IMAGE_URL;
            this._lastImageSource = firstUrl;
            await this.scene.loadImage(firstUrl);

            return this.getControlsHTML();
        }

        destroy() { 
            console.log("[PixièƒŒæ™¯] æ¸…ç†èµ„æº...");
            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'PixièƒŒæ™¯ï¼šæ¸…ç†èµ„æº...');
            try { if (this._controlsAbort) this._controlsAbort.abort(); } catch (_) {}

            try { if (this.scene && typeof this.scene.destroy === 'function') this.scene.destroy(); } catch (e) {
                console.warn("[PixièƒŒæ™¯] scene.destroy å¤±è´¥:", e);
            }
            this.scene = null;

            try {
                if (this.layerEl && this.layerEl.parentNode) this.layerEl.parentNode.removeChild(this.layerEl);
            } catch (_) {}
            this.layerEl = null;

            this._isPlaying = true;
        }

        getControlsHTML() {
            // ç”Ÿæˆè¿™ä¸ªèƒŒæ™¯ä¸“ç”¨çš„æ§åˆ¶é¢æ¿HTMLï¼ˆåŒ…å«åŸå§‹æ–‡ä»¶ä¸­çš„æ‰€æœ‰æ§åˆ¶é€‰é¡¹ï¼‰
            return `
                <div class="control-group-title">Pixi åŠ¨æ€èƒŒæ™¯</div>

                <div class="bg-ctrl-row">
                    <label class="bg-file-btn" title="é€‰æ‹©æœ¬åœ°å›¾ç‰‡æ–‡ä»¶">
                        é€‰æ‹©æ–‡ä»¶
                        <input type="file" id="fileInput" accept="image/*" style="display:none">
                    </label>
                    <button id="stopBtn" title="æš‚åœ/æ’­æ”¾èƒŒæ™¯åŠ¨ç”»">æš‚åœ</button>
                </div>

                <div class="bg-file-name" id="fileName">é»˜è®¤å›¾ç‰‡</div>

                <div class="bg-ctrl-row" style="width:100%">
                    <input type="text" id="urlInput" placeholder="è¾“å…¥å›¾ç‰‡URL..." />
                    <button id="loadUrlBtn" title="åŠ è½½URLå›¾ç‰‡">åŠ è½½URLå›¾ç‰‡</button>
                </div>

                <div class="bg-sep"></div>

                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="twistEffect" checked> æ‰­æ›²æ•ˆæœ</label>
                </div>

                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blurEffect"> æ¨¡ç³Š</label>
                </div>

                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur1"> æ¨¡ç³Šå±‚1ï¼ˆ5åƒç´ ï¼‰</label>
                </div>
                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur2"> æ¨¡ç³Šå±‚2ï¼ˆ10åƒç´ ï¼‰</label>
                </div>
                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur3"> æ¨¡ç³Šå±‚3ï¼ˆ20åƒç´ ï¼‰</label>
                </div>
                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur4"> æ¨¡ç³Šå±‚4ï¼ˆ40åƒç´ ï¼‰</label>
                </div>
                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur5"> æ¨¡ç³Šå±‚5ï¼ˆ80åƒç´ ï¼‰</label>
                </div>

                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="saturation" checked> é¥±å’Œåº¦</label>
                </div>

                <div class="bg-hint" style="margin-top:10px;">
                    æç¤ºï¼šæ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶/URL åï¼Œå°†è‡ªåŠ¨å…³é—­â€œè·Ÿéšä¸“è¾‘å°é¢â€ï¼Œä»¥ä¿ç•™ä½ çš„è‡ªå®šä¹‰å›¾ç‰‡ã€‚
                </div>
            `;
        }

        bindControls(rootEl, { onUserOverride } = {}) {
            if (!rootEl) return;
            if (!this.scene) return;

            // ä½¿ç”¨ AbortController ä¾¿äº destroy æ—¶ä¸€é”®å¸è½½äº‹ä»¶
            this._controlsAbort = new AbortController();
            const sig = { signal: this._controlsAbort.signal };

            const $ = (id) => rootEl.querySelector(`#${id}`);

            const fileInput = $('fileInput');
            const fileName = $('fileName');
            const urlInput = $('urlInput');
            const loadUrlBtn = $('loadUrlBtn');
            const stopBtn = $('stopBtn');

            const twistEffect = $('twistEffect');
            const blurEffect = $('blurEffect');
            const blurIds = ['blur1','blur2','blur3','blur4','blur5'];
            const saturation = $('saturation');

            const updateFilters = () => {
                try {
                    this.scene.updateFilters({
                        twist: !!twistEffect?.checked,
                        blur: blurIds.map(id => !!$(id)?.checked),
                        sat: !!saturation?.checked,
                    });
                } catch (e) {
                    console.warn("[PixièƒŒæ™¯] updateFilters å¼‚å¸¸:", e);
                }
            };

            if (fileInput) fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    if (fileName) fileName.textContent = file.name;
                    this._lastImageSource = file;
                    try { await this.scene.loadImage(file); } catch (err) {}
                    if (typeof onUserOverride === 'function') onUserOverride();
                }
            }, sig);

            if (loadUrlBtn) loadUrlBtn.addEventListener('click', async () => {
                const url = (urlInput?.value || '').trim();
                if (url) {
                    if (fileName) fileName.textContent = url.split('/').pop();
                    this._lastImageSource = url;
                    try { await this.scene.loadImage(url); } catch (err) {}
                    if (typeof onUserOverride === 'function') onUserOverride();
                }
            }, sig);

            // æš‚åœ/æ’­æ”¾
            if (stopBtn) stopBtn.addEventListener('click', () => {
                this._isPlaying = !this._isPlaying;
                try {
                    if (this._isPlaying) {
                        this.scene.resume();
                        stopBtn.textContent = 'æš‚åœ';
                    } else {
                        this.scene.pause();
                        stopBtn.textContent = 'æ’­æ”¾';
                    }
                } catch (e) {}
            }, sig);

            // æ»¤é•œç›‘å¬
            if (twistEffect) twistEffect.addEventListener('change', updateFilters, sig);
            if (blurEffect) blurEffect.addEventListener('change', (e) => {
                blurIds.forEach(id => { const el = $(id); if (el) el.checked = e.target.checked; });
                updateFilters();
            }, sig);
            blurIds.concat(['saturation']).forEach(id => {
                const el = $(id);
                if (el) el.addEventListener('change', updateFilters, sig);
            });

            updateFilters();
        }

        async updateFromAlbum(url) {
            if (!this.scene || !url) return;
            this._lastImageSource = url;
            try { await this.scene.loadImage(url); } catch (e) {}
            // å°½é‡åŒæ­¥æ˜¾ç¤º
            const fileNameEl = document.getElementById('fileName');
            if (fileNameEl) fileNameEl.textContent = `[ä¸“è¾‘å°é¢] ${url.split('/').pop()}`;
        }
    }

    // =========================================================
    // === MeshèƒŒæ™¯å®Œæ•´å°è£… ===
    // ï¼ˆä»¥ä¸‹æ ¸å¿ƒæ¸²æŸ“é€»è¾‘å®Œæ•´å¤åˆ¶è‡ª mesh-gradient-background-fixed.htmlï¼Œ
    //  ä»…å¯¹ resize/RAF å¢åŠ å¯é‡Šæ”¾èƒ½åŠ›ï¼Œå¹¶åŠ å…¥ destroy() åšèµ„æºæ¸…ç†ï¼‰
    // =========================================================
    
    // =========================================================
    // === MeshèƒŒæ™¯å®Œæ•´å°è£… ===
    // ï¼ˆä»¥ä¸‹æ ¸å¿ƒæ¸²æŸ“é€»è¾‘å®Œæ•´å¤åˆ¶è‡ª mesh-gradient-background-fixed.htmlï¼Œ
    //  ä»…å¯¹ resize/RAF å¢åŠ å¯é‡Šæ”¾èƒ½åŠ›ï¼Œå¹¶åŠ å…¥ destroy() åšèµ„æºæ¸…ç†ï¼‰
    // =========================================================
    class MeshBackgroundSystem {
        constructor() {
            // åŒ…å«mesh-gradient-background-fixed.htmlçš„æ‰€æœ‰ä»£ç ï¼ˆå®Œæ•´å¤åˆ¶ï¼‰
                        // ============================================
                // é…ç½®
                // ============================================
                const DEFAULT_IMAGE_URL = 'https://imge.kugou.com/stdmusic/orig/20150718/20150718214459760936.jpg';

                // ============================================
                // æ•°å­¦åº“ - å‘é‡å’ŒçŸ©é˜µ (ä» gl-matrix ç®€åŒ–ç§»æ¤)
                // ============================================
                class Vec2 {
                    constructor(x = 0, y = 0) { this.x = x; this.y = y; }
                    static create() { return new Vec2(); }
                    static fromValues(x, y) { return new Vec2(x, y); }
                    copy(v) { this.x = v.x; this.y = v.y; return this; }
                    set(x, y) { this.x = x; this.y = y; return this; }
                    get 0() { return this.x; }
                    set 0(v) { this.x = v; }
                    get 1() { return this.y; }
                    set 1(v) { this.y = v; }
                }

                class Vec3 {
                    constructor(r = 0, g = 0, b = 0) { this.r = r; this.g = g; this.b = b; }
                    static create() { return new Vec3(); }
                    static fromValues(r, g, b) { return new Vec3(r, g, b); }
                    get x() { return this.r; }
                    set x(v) { this.r = v; }
                    get y() { return this.g; }
                    set y(v) { this.g = v; }
                    get z() { return this.b; }
                    set z(v) { this.b = v; }
                }

                class Vec4 {
                    constructor() { this.data = new Float32Array(4); }
                    static create() { return new Vec4(); }
                    get 0() { return this.data[0]; }
                    set 0(v) { this.data[0] = v; }
                    get 1() { return this.data[1]; }
                    set 1(v) { this.data[1] = v; }
                    get 2() { return this.data[2]; }
                    set 2(v) { this.data[2] = v; }
                    get 3() { return this.data[3]; }
                    set 3(v) { this.data[3] = v; }
                    copy(v) { for(let i=0;i<4;i++) this.data[i] = v.data[i]; return this; }
                    dot(v) { return this.data[0]*v.data[0] + this.data[1]*v.data[1] + this.data[2]*v.data[2] + this.data[3]*v.data[3]; }
                    static transformMat4(out, a, m) {
                        const x=a.data[0], y=a.data[1], z=a.data[2], w=a.data[3];
                        out.data[0] = m.data[0]*x + m.data[4]*y + m.data[8]*z + m.data[12]*w;
                        out.data[1] = m.data[1]*x + m.data[5]*y + m.data[9]*z + m.data[13]*w;
                        out.data[2] = m.data[2]*x + m.data[6]*y + m.data[10]*z + m.data[14]*w;
                        out.data[3] = m.data[3]*x + m.data[7]*y + m.data[11]*z + m.data[15]*w;
                        return out;
                    }
                }

                class Mat4 {
                    constructor() { this.data = new Float32Array(16); }
                    static create() { return new Mat4(); }
                    static fromValues(...args) { const m = new Mat4(); for(let i=0;i<16;i++) m.data[i] = args[i] || 0; return m; }
                    static clone(m) { const n = new Mat4(); for(let i=0;i<16;i++) n.data[i] = m.data[i]; return n; }
                    copy(m) { for(let i=0;i<16;i++) this.data[i] = m.data[i]; return this; }
                    fill(v) { for(let i=0;i<16;i++) this.data[i] = v; return this; }
                    transpose() {
                        const d = this.data;
                        const t = (i,j) => { const tmp = d[i*4+j]; d[i*4+j] = d[j*4+i]; d[j*4+i] = tmp; };
                        t(0,1); t(0,2); t(0,3); t(1,2); t(1,3); t(2,3);
                        return this;
                    }
                    static mul(out, a, b) {
                        // æŒ‰ gl-matrix(mat4.multiply) çš„åˆ—ä¸»åºè§„åˆ™å®ç°
                        const outd = out.data, ad = a.data, bd = b.data;

                        const a00 = ad[0],  a01 = ad[1],  a02 = ad[2],  a03 = ad[3];
                        const a10 = ad[4],  a11 = ad[5],  a12 = ad[6],  a13 = ad[7];
                        const a20 = ad[8],  a21 = ad[9],  a22 = ad[10], a23 = ad[11];
                        const a30 = ad[12], a31 = ad[13], a32 = ad[14], a33 = ad[15];

                        const b00 = bd[0],  b01 = bd[1],  b02 = bd[2],  b03 = bd[3];
                        const b10 = bd[4],  b11 = bd[5],  b12 = bd[6],  b13 = bd[7];
                        const b20 = bd[8],  b21 = bd[9],  b22 = bd[10], b23 = bd[11];
                        const b30 = bd[12], b31 = bd[13], b32 = bd[14], b33 = bd[15];

                        outd[0]  = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
                        outd[1]  = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
                        outd[2]  = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
                        outd[3]  = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;

                        outd[4]  = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
                        outd[5]  = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
                        outd[6]  = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
                        outd[7]  = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;

                        outd[8]  = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
                        outd[9]  = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
                        outd[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
                        outd[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;

                        outd[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
                        outd[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
                        outd[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
                        outd[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;

                        return out;
                    }
                }

                // ============================================
                // å›¾åƒå¤„ç†å‡½æ•° (ä» applemusic-like-lyrics å®Œæ•´å¤åˆ¶)
                // ============================================
                function blurImage(imageData, radius, quality) {
                    const pixels = imageData.data;
                    const width = imageData.width;
                    const height = imageData.height;
                    let rsum, gsum, bsum, asum, x, y, i, p, p1, p2, yp, yi, yw;
                    const wm = width - 1, hm = height - 1;
                    const rad1x = radius + 1, divx = radius + rad1x;
                    const rad1y = radius + 1, divy = radius + rad1y;
                    const div2 = 1 / (divx * divy);
                    const r = [], g = [], b = [], a = [], vmin = [], vmax = [];

                    while (quality-- > 0) {
                        yw = yi = 0;
                        for (y = 0; y < height; y++) {
                            rsum = pixels[yw] * rad1x; gsum = pixels[yw + 1] * rad1x;
                            bsum = pixels[yw + 2] * rad1x; asum = pixels[yw + 3] * rad1x;
                            for (i = 1; i <= radius; i++) {
                                p = yw + ((i > wm ? wm : i) << 2);
                                rsum += pixels[p++]; gsum += pixels[p++]; bsum += pixels[p++]; asum += pixels[p];
                            }
                            for (x = 0; x < width; x++) {
                                r[yi] = rsum; g[yi] = gsum; b[yi] = bsum; a[yi] = asum;
                                if (y === 0) { vmin[x] = Math.min(x + rad1x, wm) << 2; vmax[x] = Math.max(x - radius, 0) << 2; }
                                p1 = yw + vmin[x]; p2 = yw + vmax[x];
                                rsum += pixels[p1++] - pixels[p2++]; gsum += pixels[p1++] - pixels[p2++];
                                bsum += pixels[p1++] - pixels[p2++]; asum += pixels[p1] - pixels[p2];
                                yi++;
                            }
                            yw += width << 2;
                        }
                        for (x = 0; x < width; x++) {
                            yp = x;
                            rsum = r[yp] * rad1y; gsum = g[yp] * rad1y; bsum = b[yp] * rad1y; asum = a[yp] * rad1y;
                            for (i = 1; i <= radius; i++) { yp += i > hm ? 0 : width; rsum += r[yp]; gsum += g[yp]; bsum += b[yp]; asum += a[yp]; }
                            yi = x << 2;
                            for (y = 0; y < height; y++) {
                                pixels[yi] = (rsum * div2 + 0.5) | 0; pixels[yi + 1] = (gsum * div2 + 0.5) | 0;
                                pixels[yi + 2] = (bsum * div2 + 0.5) | 0; pixels[yi + 3] = (asum * div2 + 0.5) | 0;
                                if (x === 0) { vmin[y] = Math.min(y + rad1y, hm) * width; vmax[y] = Math.max(y - radius, 0) * width; }
                                p1 = x + vmin[y]; p2 = x + vmax[y];
                                rsum += r[p1] - r[p2]; gsum += g[p1] - g[p2]; bsum += b[p1] - b[p2]; asum += a[p1] - a[p2];
                                yi += width << 2;
                            }
                        }
                    }
                }

                function saturateImage(imageData, saturation) {
                    const pixels = imageData.data;
                    for (let i = 0; i < pixels.length; i += 4) {
                        const r = pixels[i], g = pixels[i + 1], b = pixels[i + 2];
                        const gray = r * 0.3 + g * 0.59 + b * 0.11;
                        pixels[i] = gray * (1 - saturation) + r * saturation;
                        pixels[i + 1] = gray * (1 - saturation) + g * saturation;
                        pixels[i + 2] = gray * (1 - saturation) + b * saturation;
                    }
                }

                function brightnessImage(imageData, brightness) {
                    const pixels = imageData.data;
                    for (let i = 0; i < pixels.length; i += 4) {
                        pixels[i] *= brightness; pixels[i + 1] *= brightness; pixels[i + 2] *= brightness;
                    }
                }

                function contrastImage(imageData, contrast) {
                    const pixels = imageData.data;
                    for (let i = 0; i < pixels.length; i += 4) {
                        pixels[i] = (pixels[i] - 128) * contrast + 128;
                        pixels[i + 1] = (pixels[i + 1] - 128) * contrast + 128;
                        pixels[i + 2] = (pixels[i + 2] - 128) * contrast + 128;
                    }
                }

                // ============================================
                // Bicubic Hermite Patch è´å¡å°”æ›²é¢æ ¸å¿ƒå®ç°
                // (ä» applemusic-like-lyrics å®Œæ•´ç§»æ¤)
                // ============================================
    
                // Hermite åŸºå‡½æ•°çŸ©é˜µ
                const H = Mat4.fromValues(2, -2, 1, 1, -3, 3, -2, -1, 0, 0, 1, 0, 1, 0, 0, 0);
                const H_T = Mat4.clone(H); H_T.transpose();

                // æ§åˆ¶ç‚¹ç±»
                class ControlPoint {
                    constructor() {
                        this.color = Vec3.fromValues(1, 1, 1);
                        this.location = Vec2.fromValues(0, 0);
                        this.uTangent = Vec2.fromValues(0, 0);
                        this.vTangent = Vec2.fromValues(0, 0);
                        this._uRot = 0; this._vRot = 0;
                        this._uScale = 1; this._vScale = 1;
                    }
                    get uRot() { return this._uRot; }
                    set uRot(value) { this._uRot = value; this.updateUTangent(); }
                    get vRot() { return this._vRot; }
                    set vRot(value) { this._vRot = value; this.updateVTangent(); }
                    get uScale() { return this._uScale; }
                    set uScale(value) { this._uScale = value; this.updateUTangent(); }
                    get vScale() { return this._vScale; }
                    set vScale(value) { this._vScale = value; this.updateVTangent(); }
                    updateUTangent() { this.uTangent.x = Math.cos(this._uRot) * this._uScale; this.uTangent.y = Math.sin(this._uRot) * this._uScale; }
                    updateVTangent() { this.vTangent.x = -Math.sin(this._vRot) * this._vScale; this.vTangent.y = Math.cos(this._vRot) * this._vScale; }
                }

                // æ›²é¢ç‚¹è®¡ç®— - æ ¸å¿ƒè´å¡å°”ç®—æ³•
                const spUx = Vec4.create(), spUy = Vec4.create(), spV = Vec4.create();
                const spxAcc = Mat4.create(), spyAcc = Mat4.create();
    
                function surfacePoint(u, v, X, Y, output = Vec2.create()) {
                    spUx[0] = u ** 3; spUx[1] = u ** 2; spUx[2] = u; spUx[3] = 1;
                    spUy.copy(spUx);
                    spV[0] = v ** 3; spV[1] = v ** 2; spV[2] = v; spV[3] = 1;

                    spxAcc.copy(X).transpose();
                    Mat4.mul(spxAcc, spxAcc, H);
                    Mat4.mul(spxAcc, H_T, spxAcc);
                    Vec4.transformMat4(spUx, spUx, spxAcc);
                    const x = spV.dot(spUx);

                    spyAcc.copy(Y).transpose();
                    Mat4.mul(spyAcc, spyAcc, H);
                    Mat4.mul(spyAcc, H_T, spyAcc);
                    Vec4.transformMat4(spUy, spUy, spyAcc);
                    const y = spV.dot(spUy);

                    output.x = x; output.y = y;
                    return output;
                }

                // ç½‘æ ¼ç³»æ•°çŸ©é˜µ
                function meshCoefficients(p00, p01, p10, p11, axis, output = Mat4.create()) {
                    const l = p => p.location[axis];
                    const u = p => p.uTangent[axis];
                    const v = p => p.vTangent[axis];

                    output.data[0] = l(p00); output.data[1] = l(p01); output.data[2] = v(p00); output.data[3] = v(p01);
                    output.data[4] = l(p10); output.data[5] = l(p11); output.data[6] = v(p10); output.data[7] = v(p11);
                    output.data[8] = u(p00); output.data[9] = u(p01); output.data[10] = 0; output.data[11] = 0;
                    output.data[12] = u(p10); output.data[13] = u(p11); output.data[14] = 0; output.data[15] = 0;
                    return output;
                }

                // é¢œè‰²ç³»æ•°çŸ©é˜µ
                function colorCoefficients(p00, p01, p10, p11, axis, output = Mat4.create()) {
                    const c = p => p.color[axis];
                    output.fill(0);
                    output.data[0] = c(p00); output.data[1] = c(p01);
                    output.data[4] = c(p10); output.data[5] = c(p11);
                    return output;
                }

                const cpUx = Vec4.create(), cpUy = Vec4.create(), cpUz = Vec4.create(), cpV = Vec4.create();
                const cprAcc = Mat4.create(), cpgAcc = Mat4.create(), cpbAcc = Mat4.create();
                const cpResult = Vec3.create();
    
                function colorPoint(u, v, R, G, B) {
                    cpUx[0] = u ** 3; cpUx[1] = u ** 2; cpUx[2] = u; cpUx[3] = 1;
                    cpUy.copy(cpUx); cpUz.copy(cpUx);
                    cpV[0] = v ** 3; cpV[1] = v ** 2; cpV[2] = v; cpV[3] = 1;

                    cprAcc.copy(R).transpose(); Mat4.mul(cprAcc, cprAcc, H); Mat4.mul(cprAcc, H_T, cprAcc);
                    Vec4.transformMat4(cpUx, cpUx, cprAcc); cpResult.r = cpV.dot(cpUx);

                    cpgAcc.copy(G).transpose(); Mat4.mul(cpgAcc, cpgAcc, H); Mat4.mul(cpgAcc, H_T, cpgAcc);
                    Vec4.transformMat4(cpUy, cpUy, cpgAcc); cpResult.g = cpV.dot(cpUy);

                    cpbAcc.copy(B).transpose(); Mat4.mul(cpbAcc, cpbAcc, H); Mat4.mul(cpbAcc, H_T, cpbAcc);
                    Vec4.transformMat4(cpUz, cpUz, cpbAcc); cpResult.b = cpV.dot(cpUz);

                    return cpResult;
                }

                // 2D Map æ•°æ®ç»“æ„
                class Map2D {
                    constructor(width, height) { this._width = width; this._height = height; this._data = new Array(width * height).fill(null); }
                    resize(width, height) { this._width = width; this._height = height; this._data = new Array(width * height).fill(null); }
                    set(x, y, value) { this._data[x + y * this._width] = value; }
                    get(x, y) { return this._data[x + y * this._width]; }
                    get width() { return this._width; }
                    get height() { return this._height; }
                }

                // ============================================
                // Bicubic Hermite Patch Mesh ç±»
                // ============================================
                class BHPMesh {
                    constructor() {
                        this._subDivisions = 15;
                        this._controlPoints = new Map2D(3, 3);
                        this.vertexData = null;
                        this.indexData = null;
                        this.vertexWidth = 0;
                        this.vertexHeight = 0;
                        this.tempX = Mat4.create(); this.tempY = Mat4.create();
                        this.tempR = Mat4.create(); this.tempG = Mat4.create(); this.tempB = Mat4.create();
                        this.tmpV2 = Vec2.create();
                        this.resizeControlPoints(3, 3);
                    }

                    resetSubdivision(subDivisions) {
                        this._subDivisions = subDivisions;
                        this.vertexWidth = (this._controlPoints.width - 1) * subDivisions;
                        this.vertexHeight = (this._controlPoints.height - 1) * subDivisions;
                        const vertexCount = this.vertexWidth * this.vertexHeight;
                        this.vertexData = new Float32Array(vertexCount * 7); // pos(2) + color(3) + uv(2)
                        this.indexData = new Uint16Array((this.vertexWidth - 1) * (this.vertexHeight - 1) * 6);
            
                        // ç”Ÿæˆç´¢å¼•
                        let idx = 0;
                        for (let y = 0; y < this.vertexHeight - 1; y++) {
                            for (let x = 0; x < this.vertexWidth - 1; x++) {
                                const i = y * this.vertexWidth + x;
                                this.indexData[idx++] = i;
                                this.indexData[idx++] = i + 1;
                                this.indexData[idx++] = i + this.vertexWidth;
                                this.indexData[idx++] = i + 1;
                                this.indexData[idx++] = i + this.vertexWidth + 1;
                                this.indexData[idx++] = i + this.vertexWidth;
                            }
                        }
                    }

                    resizeControlPoints(width, height) {
                        if (width < 2 || height < 2) throw new Error("Control points must be at least 2x2");
                        this._controlPoints.resize(width, height);
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                const point = new ControlPoint();
                                point.location.x = (x / (width - 1)) * 2 - 1;
                                point.location.y = (y / (height - 1)) * 2 - 1;
                                point.uTangent.x = 2 / (width - 1);
                                point.vTangent.y = 2 / (height - 1);
                                this._controlPoints.set(x, y, point);
                            }
                        }
                        this.resetSubdivision(this._subDivisions);
                    }

                    getControlPoint(x, y) { return this._controlPoints.get(x, y); }

                    setVertexData(vx, vy, px, py, pr, pg, pb, uvX, uvY) {
                        const idx = (vx + vy * this.vertexWidth) * 7;
                        this.vertexData[idx] = px; this.vertexData[idx + 1] = py;
                        this.vertexData[idx + 2] = pr; this.vertexData[idx + 3] = pg; this.vertexData[idx + 4] = pb;
                        this.vertexData[idx + 5] = uvX; this.vertexData[idx + 6] = uvY;
                    }

                    // æ ¸å¿ƒï¼šæ›´æ–°ç½‘æ ¼é¡¶ç‚¹æ•°æ®
                    updateMesh() {
                        const subDivM1 = this._subDivisions - 1;
                        const tW = subDivM1 * (this._controlPoints.height - 1);
                        const tH = subDivM1 * (this._controlPoints.width - 1);
                        const cpW = this._controlPoints.width;
                        const cpH = this._controlPoints.height;
                        const subDiv = this._subDivisions;
                        const invSubDivM1 = 1 / subDivM1;
                        const invTH = 1 / tH;
                        const invTW = 1 / tW;

                        for (let x = 0; x < cpW - 1; x++) {
                            for (let y = 0; y < cpH - 1; y++) {
                                const p00 = this._controlPoints.get(x, y);
                                const p01 = this._controlPoints.get(x, y + 1);
                                const p10 = this._controlPoints.get(x + 1, y);
                                const p11 = this._controlPoints.get(x + 1, y + 1);

                                meshCoefficients(p00, p01, p10, p11, 'x', this.tempX);
                                meshCoefficients(p00, p01, p10, p11, 'y', this.tempY);
                                colorCoefficients(p00, p01, p10, p11, 'r', this.tempR);
                                colorCoefficients(p00, p01, p10, p11, 'g', this.tempG);
                                colorCoefficients(p00, p01, p10, p11, 'b', this.tempB);

                                const sX = x / (cpW - 1);
                                const sY = y / (cpH - 1);
                                const baseVx = y * subDiv;
                                const baseVy = x * subDiv;

                                for (let u = 0; u < subDiv; u++) {
                                    const uNorm = u * invSubDivM1;
                                    const vxOffset = baseVx + u;

                                    for (let v = 0; v < subDiv; v++) {
                                        const vNorm = v * invSubDivM1;
                                        const vy = baseVy + v;

                                        const pos = surfacePoint(uNorm, vNorm, this.tempX, this.tempY, this.tmpV2);
                                        const col = colorPoint(uNorm, vNorm, this.tempR, this.tempG, this.tempB);
                                        const uvX = sX + v * invTH;
                                        const uvY = 1 - sY - u * invTW;

                                        this.setVertexData(vxOffset, vy, pos.x, pos.y, col.r, col.g, col.b, uvX, uvY);
                                    }
                                }
                            }
                        }
                    }
                }

                // ============================================
                // ç½‘æ ¼é¢„è®¾ (ä»é¡¹ç›®å®Œæ•´å¤åˆ¶)
                // ============================================
                const CONTROL_POINT_PRESETS = [
                    { width: 4, height: 4, conf: [
                        {cx:0,cy:0,x:-1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:0,x:-0.33,y:-1,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:0,x:0.33,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:0,x:1,y:-1,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:1,x:-1,y:-0.04,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:1,x:-0.24,y:-0.22,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:1,x:0.33,y:-0.005,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:1,x:0.99,y:-0.34,ur:8,vr:0,up:0.566,vp:1.792},
                        {cx:0,cy:2,x:-1,y:0.33,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:2,x:-0.34,y:0,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:2,x:0.33,y:0.2,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:2,x:1,y:0.08,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:3,x:-1,y:1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:3,x:-0.33,y:1,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:3,x:0.33,y:1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:3,x:1,y:1,ur:0,vr:0,up:1,vp:1},
                    ]},
                    { width: 5, height: 5, conf: [
                        {cx:0,cy:0,x:-1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:0,x:-0.5,y:-1,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:0,x:0,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:0,x:0.5,y:-1,ur:0,vr:0,up:1,vp:1},
                        {cx:4,cy:0,x:1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:0,cy:1,x:-1,y:-0.5,ur:0,vr:0,up:1,vp:1},
                        {cx:1,cy:1,x:-0.5,y:-0.5,ur:0,vr:0,up:1,vp:1}, {cx:2,cy:1,x:-0.005,y:-0.61,ur:0,vr:0,up:1,vp:1},
                        {cx:3,cy:1,x:0.59,y:-0.4,ur:0,vr:0,up:1,vp:1}, {cx:4,cy:1,x:1,y:-0.5,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:2,x:-1,y:0,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:2,x:-0.42,y:-0.12,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:2,x:-0.1,y:-0.02,ur:0,vr:-47,up:0.629,vp:0.849}, {cx:3,cy:2,x:0.4,y:-0.06,ur:0,vr:0,up:1,vp:1},
                        {cx:4,cy:2,x:1,y:0,ur:0,vr:0,up:1,vp:1}, {cx:0,cy:3,x:-1,y:0.5,ur:0,vr:0,up:1,vp:1},
                        {cx:1,cy:3,x:0.07,y:0.52,ur:-31,vr:-45,up:1,vp:1}, {cx:2,cy:3,x:0.21,y:0.29,ur:6,vr:-56,up:0.566,vp:1.321},
                        {cx:3,cy:3,x:0.5,y:0.5,ur:0,vr:0,up:1,vp:1}, {cx:4,cy:3,x:1,y:0.5,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:4,x:-1,y:1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:4,x:-0.31,y:1,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:4,x:0.26,y:1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:4,x:0.5,y:1,ur:0,vr:0,up:1,vp:1},
                        {cx:4,cy:4,x:1,y:1,ur:0,vr:0,up:1,vp:1},
                    ]},
                    { width: 5, height: 5, conf: [
                        {cx:0,cy:0,x:-1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:0,x:-0.45,y:-1,ur:0,vr:55,up:1,vp:2.075},
                        {cx:2,cy:0,x:0.2,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:0,x:0.46,y:-1,ur:0,vr:-25,up:1,vp:1},
                        {cx:4,cy:0,x:1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:0,cy:1,x:-1,y:-0.25,ur:-16,vr:0,up:2.327,vp:0.943},
                        {cx:1,cy:1,x:-0.56,y:-0.66,ur:47,vr:0,up:2.358,vp:0.377}, {cx:2,cy:1,x:0.23,y:-0.52,ur:-66,vr:-25,up:1.855,vp:1.164},
                        {cx:3,cy:1,x:0.69,y:-0.38,ur:0,vr:0,up:1,vp:1}, {cx:4,cy:1,x:1,y:-0.67,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:2,x:-1,y:0.04,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:2,x:-0.49,y:0.01,ur:90,vr:23,up:1,vp:1.981},
                        {cx:2,cy:2,x:0.02,y:-0.14,ur:0,vr:42,up:1,vp:1}, {cx:3,cy:2,x:0.48,y:0.06,ur:-30,vr:0,up:1.95,vp:0.44},
                        {cx:4,cy:2,x:1,y:0.25,ur:0,vr:0,up:1,vp:1}, {cx:0,cy:3,x:-1,y:0.7,ur:-68,vr:0,up:1,vp:0.786},
                        {cx:1,cy:3,x:-0.69,y:0.59,ur:-68,vr:0,up:1,vp:1}, {cx:2,cy:3,x:0.18,y:0.39,ur:61,vr:0,up:1,vp:1},
                        {cx:3,cy:3,x:0.61,y:0.46,ur:-47,vr:-59,up:0.849,vp:1.73}, {cx:4,cy:3,x:1,y:0.62,ur:-33,vr:0,up:0.377,vp:1.604},
                        {cx:0,cy:4,x:-1,y:1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:4,x:-0.5,y:1,ur:0,vr:-73,up:1,vp:1},
                        {cx:2,cy:4,x:-0.33,y:1,ur:0,vr:-24,up:0.314,vp:2.704}, {cx:3,cy:4,x:0.5,y:1,ur:0,vr:0,up:1,vp:1},
                        {cx:4,cy:4,x:1,y:1,ur:0,vr:0,up:1,vp:1},
                    ]}
                ];

                function generateRandomPreset(w, h) {
                    const conf = [];
                    for (let y = 0; y < h; y++) {
                        for (let x = 0; x < w; x++) {
                            const baseX = (x / (w - 1)) * 2 - 1;
                            const baseY = (y / (h - 1)) * 2 - 1;
                            const isEdge = x === 0 || x === w - 1 || y === 0 || y === h - 1;
                            conf.push({
                                cx: x, cy: y,
                                x: isEdge ? baseX : baseX + (Math.random() - 0.5) * 0.6,
                                y: isEdge ? baseY : baseY + (Math.random() - 0.5) * 0.6,
                                ur: isEdge ? 0 : (Math.random() - 0.5) * 120,
                                vr: isEdge ? 0 : (Math.random() - 0.5) * 120,
                                up: 0.3 + Math.random() * 1.7,
                                vp: 0.3 + Math.random() * 1.7
                            });
                        }
                    }
                    return { width: w, height: h, conf };
                }

                // ============================================
                // WebGL æ¸²æŸ“å™¨
                // ============================================
                const vertexShaderSource = `
                    precision highp float;

                    attribute vec2 a_pos;
                    attribute vec3 a_color;
                    attribute vec2 a_uv;

                    varying vec3 v_color;
                    varying vec2 v_uv;

                    uniform float u_aspect;

                    void main() {
                        v_color = a_color;
                        v_uv = a_uv;

                        vec2 pos = a_pos;
                        if (u_aspect > 1.0) {
                            pos.y *= u_aspect;
                        } else {
                            pos.x /= u_aspect;
                        }

                        gl_Position = vec4(pos, 0.0, 1.0);
                    }
                `;


                const fragmentShaderSource = `
                    precision highp float;

                    varying vec3 v_color;
                    varying vec2 v_uv;

                    uniform sampler2D u_texture;
                    uniform float u_time;
                    uniform float u_alpha;
                    uniform float u_volume;

                    const float INV_255 = 1.0 / 255.0;
                    const float GRADIENT_NOISE_A = 52.9829189;
                    const vec2 GRADIENT_NOISE_B = vec2(0.06711056, 0.00583715);

                    float gradientNoise(vec2 uv) {
                        return fract(GRADIENT_NOISE_A * fract(dot(uv, GRADIENT_NOISE_B)));
                    }

                    vec2 rot(vec2 v, float angle) {
                        float s = sin(angle);
                        float c = cos(angle);
                        return vec2(c * v.x - s * v.y, s * v.x + c * v.y);
                    }

                    void main() {
                        // Dithering. NOTE: This may look weird in some videos, so comment it out in your projects if you don't like it.
                        float dither = INV_255 * gradientNoise(gl_FragCoord.xy) - 0.5 * INV_255;

                        float timeVolume = u_time + u_volume;

                        vec2 centeredUV = v_uv - vec2(0.2);
                        vec2 rotatedUV = rot(centeredUV, timeVolume * 2.0);
                        vec2 finalUV = rotatedUV + vec2(0.5);

                        vec4 result = texture2D(u_texture, finalUV);
                        result.rgb *= v_color * u_alpha;
                        result.a *= u_alpha;
                        result.rgb += vec3(dither);

                        float dist = distance(v_uv, vec2(0.5));
                        float vignette = smoothstep(0.8, 0.3, dist);
                        result.rgb *= 0.6 + vignette * 0.4;

                        gl_FragColor = result;
                    }
                `;


                class MeshGradientRenderer {
                    constructor(canvas) {
                        this.canvas = canvas;
                        this.gl = canvas.getContext('webgl');
                        if (!this.gl) throw new Error('WebGL not supported');
            
                        this.paused = false;
                        this.time = 0;
                        this.speed = 1;
                        this.subdivisions = 15;
                        this.imageSettings = { contrast: 0.4, saturation: 3.0, brightness: 0.75, blur: 2 };
                        this.mesh = new BHPMesh();
                        this.preset = CONTROL_POINT_PRESETS[0];
            
                        // â˜… é›†æˆå¢å¼ºï¼šå¯é”€æ¯æ ‡è®°/RAF/resize-handler
                        this._destroyed = false;
                        this._rafId = null;
                        this._onResize = null;

                        this.init();
                        this.resize();
                        this.animate();
            
                        this._onResize = () => this.resize();
                        window.addEventListener('resize', this._onResize);
                    }
        
                    init() {
                        const gl = this.gl;
            
                        const vs = gl.createShader(gl.VERTEX_SHADER);
                        gl.shaderSource(vs, vertexShaderSource);
                        gl.compileShader(vs);
            
                        const fs = gl.createShader(gl.FRAGMENT_SHADER);
                        gl.shaderSource(fs, fragmentShaderSource);
                        gl.compileShader(fs);

                        // â˜… é›†æˆå¢å¼ºï¼šä¿å­˜ shader å¼•ç”¨ï¼Œä¾¿äº destroy æ—¶é‡Šæ”¾
                        this._vs = vs;
                        this._fs = fs;
            
                        this.program = gl.createProgram();
                        gl.attachShader(this.program, vs);
                        gl.attachShader(this.program, fs);
                        gl.linkProgram(this.program);
            
                        this.posAttr = gl.getAttribLocation(this.program, 'a_pos');
                        this.colorAttr = gl.getAttribLocation(this.program, 'a_color');
                        this.uvAttr = gl.getAttribLocation(this.program, 'a_uv');
                        this.timeUniform = gl.getUniformLocation(this.program, 'u_time');
                        this.alphaUniform = gl.getUniformLocation(this.program, 'u_alpha');
                        this.textureUniform = gl.getUniformLocation(this.program, 'u_texture');
            
            
                        this.aspectUniform = gl.getUniformLocation(this.program, 'u_aspect');
                        this.volumeUniform = gl.getUniformLocation(this.program, 'u_volume');
            this.vertexBuffer = gl.createBuffer();
                        this.indexBuffer = gl.createBuffer();
            
                        gl.enable(gl.BLEND);
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                        gl.enable(gl.DEPTH_TEST);
                        gl.depthFunc(gl.ALWAYS);
            
                        this.applyPreset(this.preset);
                    }
        
                    applyPreset(preset) {
                        this.preset = preset;
                        this.mesh.resizeControlPoints(preset.width, preset.height);
                        const uPower = 2 / (preset.width - 1);
                        const vPower = 2 / (preset.height - 1);
            
                        for (const cp of preset.conf) {
                            const p = this.mesh.getControlPoint(cp.cx, cp.cy);
                            p.location.x = cp.x;
                            p.location.y = cp.y;
                            p.uRot = (cp.ur * Math.PI) / 180;
                            p.vRot = (cp.vr * Math.PI) / 180;
                            p.uScale = uPower * cp.up;
                            p.vScale = vPower * cp.vp;
                        }
            
                        this.mesh.resetSubdivision(this.subdivisions);
                        this.mesh.updateMesh();
                        this.uploadMesh();
                    }
        
                    uploadMesh() {
                        const gl = this.gl;
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, this.mesh.vertexData, gl.DYNAMIC_DRAW);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.mesh.indexData, gl.STATIC_DRAW);
                    }
        
                    async loadImage(source) {
                        return new Promise((resolve) => {
                            const img = new Image();
                            img.crossOrigin = 'anonymous';
                            img.onload = () => { this.processImage(img); resolve(); };
                            img.onerror = () => { this.createFallbackTexture(); resolve(); };
                
                            if (source instanceof File) {
                                const reader = new FileReader();
                                reader.onload = (e) => { img.src = e.target.result; };
                                reader.readAsDataURL(source);
                            } else {
                                img.src = source;
                            }
                        });
                    }
        
                    processImage(img) {
                        const size = 32;
                        const canvas = document.createElement('canvas');
                        canvas.width = size; canvas.height = size;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, size, size);
                        const imageData = ctx.getImageData(0, 0, size, size);
            
                        contrastImage(imageData, this.imageSettings.contrast);
                        saturateImage(imageData, this.imageSettings.saturation);
                        contrastImage(imageData, 1.7);
                        brightnessImage(imageData, this.imageSettings.brightness);
                        if (this.imageSettings.blur > 0) blurImage(imageData, this.imageSettings.blur, 4);
            
                        ctx.putImageData(imageData, 0, 0);
                        this.uploadTexture(canvas);
                    }
                    createFallbackTexture() {
                        const canvas = document.createElement('canvas');
                        canvas.width = 32; canvas.height = 32;
                        const ctx = canvas.getContext('2d');

                        // Deep Nebulaï¼ˆç¼©ç•¥çº¹ç†ç‰ˆï¼‰ï¼šé»‘åº• + éœ“è™¹å½©æ–‘ + è½»å¾®æ˜Ÿå°˜
                        ctx.fillStyle = '#0B0B0B';
                        ctx.fillRect(0, 0, 32, 32);

                        const neon = ['#921E58', '#1989FA', '#9C27B0', '#00E5FF', '#FF2EC4'];
                        const hexToRgb = (hex) => {
                            const h = (hex || '#000000').replace('#', '');
                            const n = parseInt(h.length === 3 ? h.split('').map(ch => ch + ch).join('') : h, 16);
                            return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
                        };
                        const rand = (a, b) => a + Math.random() * (b - a);

                        ctx.globalCompositeOperation = 'lighter';
                        for (let i = 0; i < 7; i++) {
                            const color = neon[i % neon.length];
                            const rgb = hexToRgb(color);
                            const x = rand(-6, 38);
                            const y = rand(-6, 38);
                            const r = rand(8, 20);

                            ctx.globalAlpha = rand(0.10, 0.28);
                            ctx.shadowBlur = r * 0.55;
                            ctx.shadowColor = `rgba(${rgb.r},${rgb.g},${rgb.b},0.9)`;

                            const g = ctx.createRadialGradient(x, y, 0, x, y, r);
                            g.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0.75)`);
                            g.addColorStop(0.55, `rgba(${rgb.r},${rgb.g},${rgb.b},0.20)`);
                            g.addColorStop(1, 'rgba(0,0,0,0)');

                            ctx.fillStyle = g;
                            ctx.beginPath();
                            ctx.arc(x, y, r, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // æ˜Ÿå°˜
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.shadowBlur = 0;
                        for (let i = 0; i < 55; i++) {
                            const x = Math.random() * 32;
                            const y = Math.random() * 32;
                            ctx.globalAlpha = rand(0.05, 0.16);
                            ctx.fillStyle = 'rgba(255,255,255,1)';
                            ctx.fillRect(x, y, 1, 1);
                        }

                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                        ctx.shadowColor = 'transparent';
                        ctx.globalCompositeOperation = 'source-over';

                        this.uploadTexture(canvas);
                    }
        
                    uploadTexture(canvas) {
                        const gl = this.gl;
                        if (this.texture) gl.deleteTexture(this.texture);
                        this.texture = gl.createTexture();
                        gl.bindTexture(gl.TEXTURE_2D, this.texture);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
                    }
        
                    resize() {
                        const dpr = Math.max(1, window.devicePixelRatio || 1);
                        const cssW = Math.max(1, window.innerWidth);
                        const cssH = Math.max(1, window.innerHeight);

                        this.canvas.width = Math.max(1, Math.round(cssW * dpr));
                        this.canvas.height = Math.max(1, Math.round(cssH * dpr));
                        this.canvas.style.width = cssW + 'px';
                        this.canvas.style.height = cssH + 'px';

                        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    }
        
                    render() {
                        const gl = this.gl;
                        gl.clearColor(0, 0, 0, 1);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        if (!this.texture) return;
            
                        gl.useProgram(this.program);
                        gl.uniform1f(this.timeUniform, this.time / 10000);
                        gl.uniform1f(this.alphaUniform, 1.0);
                        gl.uniform1f(this.aspectUniform, this.canvas.width / this.canvas.height);
                        gl.uniform1f(this.volumeUniform, 0.0);
            
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, this.texture);
                        gl.uniform1i(this.textureUniform, 0);
            
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            
                        const stride = 7 * 4;
                        gl.enableVertexAttribArray(this.posAttr);
                        gl.vertexAttribPointer(this.posAttr, 2, gl.FLOAT, false, stride, 0);
                        gl.enableVertexAttribArray(this.colorAttr);
                        gl.vertexAttribPointer(this.colorAttr, 3, gl.FLOAT, false, stride, 8);
                        gl.enableVertexAttribArray(this.uvAttr);
                        gl.vertexAttribPointer(this.uvAttr, 2, gl.FLOAT, false, stride, 20);
            
                        gl.drawElements(gl.TRIANGLES, this.mesh.indexData.length, gl.UNSIGNED_SHORT, 0);
                    }
        
                    animate() {
                        if (this._destroyed) return;
                        if (!this.paused) this.time += 16.67 * this.speed;
                        this.render();
                        this._rafId = requestAnimationFrame(() => this.animate());
                    }
        
                    pause() { this.paused = true; }
                    resume() { this.paused = false; }
        
                    randomizePreset() {
                        const w = 4 + Math.floor(Math.random() * 3);
                        const h = 4 + Math.floor(Math.random() * 3);
                        this.applyPreset(generateRandomPreset(w, h));
                    }
        
                    setSubdivisions(value) {
                        this.subdivisions = value;
                        this.mesh.resetSubdivision(value);
                        this.mesh.updateMesh();
                        this.uploadMesh();
                    }

                    // â˜… é›†æˆå¢å¼ºï¼šå®Œæ•´æ¸…ç†èµ„æºï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
                    destroy() {
                        this._destroyed = true;

                        try { if (this._rafId) cancelAnimationFrame(this._rafId); } catch (_) {}
                        try { if (this._onResize) window.removeEventListener('resize', this._onResize); } catch (_) {}

                        const gl = this.gl;
                        if (!gl) return;

                        try { if (this.texture) gl.deleteTexture(this.texture); } catch (_) {}
                        try { if (this.vertexBuffer) gl.deleteBuffer(this.vertexBuffer); } catch (_) {}
                        try { if (this.indexBuffer) gl.deleteBuffer(this.indexBuffer); } catch (_) {}

                        try { if (this.program) gl.deleteProgram(this.program); } catch (_) {}
                        try { if (this._vs) gl.deleteShader(this._vs); } catch (_) {}
                        try { if (this._fs) gl.deleteShader(this._fs); } catch (_) {}

                        try {
                            const ext = gl.getExtension('WEBGL_lose_context');
                            if (ext && ext.loseContext) ext.loseContext();
                        } catch (_) {}

                        this.gl = null;
                    }
                }

                // ============================================
                // åˆå§‹åŒ–
                // ============================================
                let renderer = null;
                let lastImageSource = null;

                async function init() {
                    const canvas = document.getElementById('canvas');
                    renderer = new MeshGradientRenderer(canvas);
                    renderer.createFallbackTexture();
        
                    try {
                        lastImageSource = DEFAULT_IMAGE_URL;
                        await renderer.loadImage(DEFAULT_IMAGE_URL);
                        document.getElementById('fileName').textContent = DEFAULT_IMAGE_URL.split('/').pop();
                    } catch (e) {
                        console.log('Using fallback');
                    }
        
                    bindControls();
                }

                function bindControls() {
                    document.getElementById('fileInput').addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            document.getElementById('fileName').textContent = file.name;
                            lastImageSource = file;
                            await renderer.loadImage(file);
                        }
                    });
        
                    document.getElementById('loadUrlBtn').addEventListener('click', async () => {
                        const url = document.getElementById('urlInput').value.trim();
                        if (url) {
                            document.getElementById('fileName').textContent = url.split('/').pop();
                            lastImageSource = url;
                            await renderer.loadImage(url);
                        }
                    });
        
                    let isPaused = false;
                    document.getElementById('pauseBtn').addEventListener('click', () => {
                        isPaused = !isPaused;
                        if (isPaused) { renderer.pause(); document.getElementById('pauseBtn').textContent = 'æ’­æ”¾'; }
                        else { renderer.resume(); document.getElementById('pauseBtn').textContent = 'æš‚åœ'; }
                    });
        
                    const reloadImage = async () => { if (lastImageSource) await renderer.loadImage(lastImageSource); };
        
                    document.getElementById('contrast').addEventListener('input', async (e) => {
                        renderer.imageSettings.contrast = e.target.value / 100;
                        await reloadImage();
                    });
                    document.getElementById('saturation').addEventListener('input', async (e) => {
                        renderer.imageSettings.saturation = e.target.value / 100;
                        await reloadImage();
                    });
                    document.getElementById('brightness').addEventListener('input', async (e) => {
                        renderer.imageSettings.brightness = e.target.value / 100;
                        await reloadImage();
                    });
                    document.getElementById('blur').addEventListener('input', async (e) => {
                        renderer.imageSettings.blur = parseInt(e.target.value);
                        await reloadImage();
                    });
                    document.getElementById('speed').addEventListener('input', (e) => {
                        renderer.speed = e.target.value / 100;
                    });
                    document.getElementById('subdivisions').addEventListener('input', (e) => {
                        renderer.setSubdivisions(parseInt(e.target.value));
                    });
                    document.getElementById('randomPreset').addEventListener('click', () => {
                        renderer.randomizePreset();
                    });
                }

                // window.addEventListener('DOMContentLoaded', init);  // å·²ç”±é›†æˆç‰ˆèƒŒæ™¯ç®¡ç†å™¨æ¥ç®¡åˆå§‹åŒ–

            // è¿è¡Œæ€å˜é‡ï¼ˆå¤–å±‚å°è£…ä½¿ç”¨ï¼‰
            this.renderer = null;
            this.canvas = null;
            this.layerEl = null;
            this.lastImageSource = null;
            this._controlsAbort = null;

            // ä»åŸè„šæœ¬ä¸­æŠ½å–çš„æ ¸å¿ƒç±»ï¼šMeshGradientRenderer
            // ï¼ˆæ³¨æ„ï¼šMeshGradientRenderer åœ¨ä¸Šé¢çš„åŸè„šæœ¬ä¸­ä»¥ class å½¢å¼å®šä¹‰ï¼‰
            this._MeshGradientRenderer = (typeof MeshGradientRenderer !== 'undefined') ? MeshGradientRenderer : null;

            // å…œåº•ï¼šå¦‚æœåŸè„šæœ¬ DEFAULT_IMAGE_URL å­˜åœ¨ï¼Œåˆ™åŒæ­¥
            try {
                if (typeof DEFAULT_IMAGE_URL !== 'undefined') this.DEFAULT_IMAGE_URL = DEFAULT_IMAGE_URL;
            } catch (_) {}
        }

        async init(container) {
            console.log("[MeshèƒŒæ™¯] åˆå§‹åŒ–å¼€å§‹...");
            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'MeshèƒŒæ™¯ï¼šåˆå§‹åŒ–å¼€å§‹...');
            const host = document.getElementById('bgHost');
            if (host) host.style.display = 'block';

            // åˆ›å»ºå›¾å±‚ä¸ canvas
            this.layerEl = document.createElement('div');
            this.layerEl.className = 'bg-layer';
            this.layerEl.style.position = 'absolute';
            this.layerEl.style.inset = '0';

            this.canvas = document.createElement('canvas');
            // ä¸ºäº†å°½é‡è´´è¿‘åŸæ–‡ä»¶ï¼Œè¿™é‡Œä¿ç•™ id="canvas"
            this.canvas.id = 'canvas';
            this.canvas.style.width = '100%';
            this.canvas.style.height = '100%';
            this.layerEl.appendChild(this.canvas);

            container.appendChild(this.layerEl);

            if (!this._MeshGradientRenderer) throw new Error('MeshGradientRenderer æœªå°±ç»ª');

            this.renderer = new this._MeshGradientRenderer(this.canvas);
            // åŸæ–‡ä»¶åˆå§‹åŒ–é€»è¾‘
            try { this.renderer.createFallbackTexture(); } catch (_) {}

            const firstUrl = window.__bgManager?.lastAlbumUrl || this.DEFAULT_IMAGE_URL;
            this.lastImageSource = firstUrl;
            try { await this.renderer.loadImage(firstUrl); } catch (e) {}

            return this.getControlsHTML();
        }

        destroy() {
            console.log("[MeshèƒŒæ™¯] æ¸…ç†èµ„æº...");
            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'MeshèƒŒæ™¯ï¼šæ¸…ç†èµ„æº...');
            try { if (this._controlsAbort) this._controlsAbort.abort(); } catch (_) {}

            try { if (this.renderer && typeof this.renderer.destroy === 'function') this.renderer.destroy(); } catch (e) {
                console.warn("[MeshèƒŒæ™¯] renderer.destroy å¤±è´¥:", e);
            }
            this.renderer = null;

            try {
                if (this.layerEl && this.layerEl.parentNode) this.layerEl.parentNode.removeChild(this.layerEl);
            } catch (_) {}
            this.layerEl = null;
            this.canvas = null;
            this.lastImageSource = null;
        }

        getControlsHTML() {
            // åŸå§‹æ§åˆ¶é¡¹å®Œæ•´ä¿ç•™ï¼šæ–‡ä»¶/URLã€æš‚åœã€å¯¹æ¯”åº¦/é¥±å’Œåº¦/äº®åº¦/æ¨¡ç³Š/é€Ÿåº¦/ç»†åˆ†/éšæœºé¢„è®¾
            return `
                <div class="control-group-title">Mesh æ¸å˜èƒŒæ™¯</div>

                <div class="bg-ctrl-row">
                    <label class="bg-file-btn">
                        é€‰æ‹©æ–‡ä»¶
                        <input type="file" id="fileInput" accept="image/*" style="display:none">
                    </label>
                    <button id="pauseBtn">æš‚åœ</button>
                </div>

                <div class="bg-file-name" id="fileName">ç‚¹å‡»é€‰æ‹©å›¾ç‰‡æˆ–è¾“å…¥URL</div>

                <div class="bg-ctrl-row" style="width:100%">
                    <input type="text" id="urlInput" placeholder="è¾“å…¥å›¾ç‰‡ URLâ€¦">
                    <button id="loadUrlBtn">åŠ è½½URLå›¾ç‰‡</button>
                </div>

                <div class="bg-sep"></div>

                <div class="bg-ctrl-row">
                    <label>å¯¹æ¯”åº¦</label>
                    <input type="range" id="contrast" min="0" max="200" value="40">
                </div>

                <div class="bg-ctrl-row">
                    <label>é¥±å’Œåº¦</label>
                    <input type="range" id="saturation" min="0" max="500" value="300">
                </div>

                <div class="bg-ctrl-row">
                    <label>äº®åº¦</label>
                    <input type="range" id="brightness" min="0" max="200" value="75">
                </div>

                <div class="bg-ctrl-row">
                    <label>æ¨¡ç³Š</label>
                    <input type="range" id="blur" min="0" max="10" value="2">
                </div>

                <div class="bg-ctrl-row">
                    <label>æ—‹è½¬é€Ÿåº¦</label>
                    <input type="range" id="speed" min="0" max="200" value="100">
                </div>

                <div class="bg-ctrl-row">
                    <label>ç»†åˆ†çº§åˆ«</label>
                    <input type="range" id="subdivisions" min="5" max="30" value="15">
                </div>

                <div class="bg-ctrl-row" style="width:100%">
                    <button id="randomPreset" style="width:100%">éšæœºç½‘æ ¼é¢„è®¾</button>
                </div>

                <div class="bg-hint" style="margin-top:10px;">
                    æç¤ºï¼šæ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶/URL åï¼Œå°†è‡ªåŠ¨å…³é—­â€œè·Ÿéšä¸“è¾‘å°é¢â€ï¼Œä»¥ä¿ç•™ä½ çš„è‡ªå®šä¹‰å›¾ç‰‡ã€‚
                </div>
            `;
        }

        bindControls(rootEl, { onUserOverride } = {}) {
            if (!rootEl || !this.renderer) return;

            this._controlsAbort = new AbortController();
            const sig = { signal: this._controlsAbort.signal };
            const $ = (id) => rootEl.querySelector(`#${id}`);

            const fileInput = $('fileInput');
            const fileName = $('fileName');
            const urlInput = $('urlInput');
            const loadUrlBtn = $('loadUrlBtn');
            const pauseBtn = $('pauseBtn');

            const contrast = $('contrast');
            const saturation = $('saturation');
            const brightness = $('brightness');
            const blur = $('blur');
            const speed = $('speed');
            const subdivisions = $('subdivisions');
            const randomPreset = $('randomPreset');

            // è®°å½•å½“å‰å›¾ç‰‡æºï¼Œä¾›æ»¤é•œè°ƒå‚åé‡è½½
            const reloadImage = async () => {
                if (this.lastImageSource) {
                    try { await this.renderer.loadImage(this.lastImageSource); } catch (_) {}
                }
            };

            if (fileInput) fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    if (fileName) fileName.textContent = file.name;
                    this.lastImageSource = file;
                    try { await this.renderer.loadImage(file); } catch (_) {}
                    if (typeof onUserOverride === 'function') onUserOverride();
                }
            }, sig);

            if (loadUrlBtn) loadUrlBtn.addEventListener('click', async () => {
                const url = (urlInput?.value || '').trim();
                if (url) {
                    if (fileName) fileName.textContent = url.split('/').pop();
                    this.lastImageSource = url;
                    try { await this.renderer.loadImage(url); } catch (_) {}
                    if (typeof onUserOverride === 'function') onUserOverride();
                }
            }, sig);

            // æš‚åœ/æ’­æ”¾
            let isPaused = false;
            if (pauseBtn) pauseBtn.addEventListener('click', () => {
                isPaused = !isPaused;
                if (isPaused) { this.renderer.pause(); pauseBtn.textContent = 'æ’­æ”¾'; }
                else { this.renderer.resume(); pauseBtn.textContent = 'æš‚åœ'; }
            }, sig);

            if (contrast) contrast.addEventListener('input', async (e) => {
                this.renderer.imageSettings.contrast = e.target.value / 100;
                await reloadImage();
            }, sig);

            if (saturation) saturation.addEventListener('input', async (e) => {
                this.renderer.imageSettings.saturation = e.target.value / 100;
                await reloadImage();
            }, sig);

            if (brightness) brightness.addEventListener('input', async (e) => {
                this.renderer.imageSettings.brightness = e.target.value / 100;
                await reloadImage();
            }, sig);

            if (blur) blur.addEventListener('input', async (e) => {
                this.renderer.imageSettings.blur = parseInt(e.target.value);
                await reloadImage();
            }, sig);

            if (speed) speed.addEventListener('input', (e) => {
                this.renderer.speed = e.target.value / 100;
            }, sig);

            if (subdivisions) subdivisions.addEventListener('input', (e) => {
                this.renderer.setSubdivisions(parseInt(e.target.value));
            }, sig);

            if (randomPreset) randomPreset.addEventListener('click', () => {
                this.renderer.randomizePreset();
            }, sig);
        }

        async updateFromAlbum(url) {
            if (!this.renderer || !url) return;
            this.lastImageSource = url;
            try { await this.renderer.loadImage(url); } catch (e) {}

            const fileNameEl = document.getElementById('fileName');
            if (fileNameEl) fileNameEl.textContent = `[ä¸“è¾‘å°é¢] ${
                (url.split('/').pop() || url).slice(0, 80)
            }`;
        }
    }


    // =========================================================
    // === èƒŒæ™¯ç®¡ç†å™¨ ===
    // =========================================================
    class BackgroundManager {
        constructor({ hostEl, controlsMountEl, badgeEl, followAlbumEl }) {
            console.log("[èƒŒæ™¯ç®¡ç†å™¨] åˆå§‹åŒ–...");
            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'èƒŒæ™¯ç®¡ç†å™¨åˆå§‹åŒ–...');
            this.currentBg = null;
            this.bgTypes = ['default', 'pixi', 'mesh'];
            this.currentIndex = 0;

            this.hostEl = hostEl;
            this.controlsMountEl = controlsMountEl;
            this.badgeEl = badgeEl;
            this.followAlbumEl = followAlbumEl;

            this.lastAlbumUrl = null;

            // é»˜è®¤èƒŒæ™¯ç³»ç»Ÿ
            this.defaultSystem = new DefaultBackgroundSystem();
        }

        getCurrentType() {
            return this.bgTypes[this.currentIndex] || 'default';
        }

        _setBadge(type) {
            if (!this.badgeEl) return;
            const map = { default: 'é»˜è®¤', pixi: 'Pixi', mesh: 'Mesh' };
            this.badgeEl.textContent = map[type] || type;
        }

        _clearControlsUI() {
            if (!this.controlsMountEl) return;
            this.controlsMountEl.innerHTML = `
                <div class="bg-hint">
                    å½“å‰èƒŒæ™¯æ— é¢å¤–æ§åˆ¶é¡¹ã€‚<br>
                    æç¤ºï¼šåˆ‡æ¢åˆ° Pixi / Mesh èƒŒæ™¯åï¼Œè¿™é‡Œä¼šå‡ºç°å¯¹åº”çš„å®Œæ•´æ§åˆ¶é¢æ¿ã€‚
                </div>
            `;
        }

        _mountControls(bg) {
            if (!this.controlsMountEl) return;

            if (!bg || typeof bg.getControlsHTML !== 'function') {
                this._clearControlsUI();
                return;
            }

            const html = bg.getControlsHTML();
            if (!html) {
                this._clearControlsUI();
                return;
            }

            this.controlsMountEl.innerHTML = html;

            // ç»‘å®šäº‹ä»¶ & æ‰‹åŠ¨è¦†ç›–é€»è¾‘
            const onUserOverride = () => {
                // ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶/URLï¼Œåˆ™å…³é—­è·Ÿéšå°é¢
                const followEl = this.followAlbumEl;
                if (followEl && followEl.checked) {
                    followEl.checked = false;
                    console.log("[èƒŒæ™¯ç³»ç»Ÿ] æ£€æµ‹åˆ°ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹©å›¾ç‰‡ï¼Œå·²è‡ªåŠ¨å…³é—­ï¼šè·Ÿéšä¸“è¾‘å°é¢");
                    dcInfo('èƒŒæ™¯ç³»ç»Ÿ', 'ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹©å›¾ç‰‡ï¼šè‡ªåŠ¨å…³é—­â€œè·Ÿéšä¸“è¾‘å°é¢â€');
                }
            };

            if (typeof bg.bindControls === 'function') {
                bg.bindControls(this.controlsMountEl, { onUserOverride });
            }
        }

        async switchBackground(type) {
            // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.group ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
            try { console.group(`[èƒŒæ™¯åˆ‡æ¢] åˆ‡æ¢åˆ° ${type}`); } catch (e) { try { console.log(`[èƒŒæ™¯åˆ‡æ¢] åˆ‡æ¢åˆ° ${type}`); } catch (_) {} }
            console.log("å½“å‰èƒŒæ™¯:", this.currentBg?.constructor?.name || 'æ— ');
            console.log("å¼€å§‹æ¸…ç†æ—§èµ„æº...");

            // æ¸…ç†æ—§èƒŒæ™¯
            try {
                if (this.currentBg && typeof this.currentBg.destroy === 'function') {
                    this.currentBg.destroy();
                }
            } catch (e) {
                console.warn("[èƒŒæ™¯åˆ‡æ¢] æ¸…ç†æ—§èƒŒæ™¯å¼‚å¸¸:", e);
                dcWarn('èƒŒæ™¯ç³»ç»Ÿ', `æ¸…ç†æ—§èƒŒæ™¯å¼‚å¸¸ï¼š${e.message || e}`);
            }

            // æ¸…ç©ºå®¿ä¸»å±‚
            try {
                if (this.hostEl) this.hostEl.innerHTML = '';
            } catch (_) {}

            console.log("æ—§èµ„æºæ¸…ç†å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–æ–°èƒŒæ™¯...");

            // æ ¹æ®ç±»å‹åˆå§‹åŒ–æ–°èƒŒæ™¯
            let newBg = null;
            try {
                if (type === 'default') {
                    newBg = this.defaultSystem;
                    newBg.init();
                    // é»˜è®¤èƒŒæ™¯æ— ä¸“ç”¨æ§åˆ¶
                    this._clearControlsUI();
                } else if (type === 'pixi') {
                    // å…³é—­é»˜è®¤èƒŒæ™¯
                    this.defaultSystem.destroy();
                    document.getElementById('gradientCanvas')?.style && (document.getElementById('gradientCanvas').style.display = 'none');

                    newBg = new PixiBackgroundSystem();
                    await newBg.init(this.hostEl);
                    this._mountControls(newBg);
                } else if (type === 'mesh') {
                    // å…³é—­é»˜è®¤èƒŒæ™¯
                    this.defaultSystem.destroy();
                    document.getElementById('gradientCanvas')?.style && (document.getElementById('gradientCanvas').style.display = 'none');

                    newBg = new MeshBackgroundSystem();
                    await newBg.init(this.hostEl);
                    this._mountControls(newBg);
                } else {
                    console.warn("[èƒŒæ™¯åˆ‡æ¢] æœªçŸ¥èƒŒæ™¯ç±»å‹ï¼Œå›é€€ default:", type);
                    newBg = this.defaultSystem;
                    newBg.init();
                    this._clearControlsUI();
                }
            } catch (e) {
// Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.error ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
                try { console.error("[èƒŒæ™¯åˆ‡æ¢] æ–°èƒŒæ™¯åˆå§‹åŒ–å¤±è´¥ï¼Œå›é€€é»˜è®¤èƒŒæ™¯:", e); } catch (e) { try { console.log("[èƒŒæ™¯åˆ‡æ¢] æ–°èƒŒæ™¯åˆå§‹åŒ–å¤±è´¥ï¼Œå›é€€é»˜è®¤èƒŒæ™¯:", e); } catch (_) {} }
                dcError('èƒŒæ™¯ç³»ç»Ÿ', `æ–°èƒŒæ™¯åˆå§‹åŒ–å¤±è´¥ï¼š${e.message || e}ï¼Œå·²å›é€€é»˜è®¤èƒŒæ™¯`);
                newBg = this.defaultSystem;
                try { newBg.init(); } catch (_) {}
                this._clearControlsUI();
                type = 'default';
            }

            this.currentBg = newBg;
            this._setBadge(type);

            // è‹¥å¼€å¯è·Ÿéšå°é¢ï¼Œä¸”æœ‰ lastAlbumUrlï¼Œåˆ™ç«‹å³åˆ·æ–°èƒŒæ™¯
            try {
                const follow = !!this.followAlbumEl?.checked;
                if (follow && this.lastAlbumUrl && this.currentBg && typeof this.currentBg.updateFromAlbum === 'function') {
                    await this.currentBg.updateFromAlbum(this.lastAlbumUrl);
                }
            } catch (_) {}

            console.log("æ–°èƒŒæ™¯åˆå§‹åŒ–å®Œæˆ");
            // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.groupEnd ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
            try { console.groupEnd(); } catch (e) { try { console.log('[èƒŒæ™¯åˆ‡æ¢] groupEnd'); } catch (_) {} }
        }

        async cycle() {
            this.currentIndex = (this.currentIndex + 1) % this.bgTypes.length;
            const type = this.bgTypes[this.currentIndex];
            await this.switchBackground(type);
        }

        async handleAlbumArtChanged(url) {
            if (!url) return;
            this.lastAlbumUrl = url;

            const follow = !!this.followAlbumEl?.checked;
            if (!follow) return;

            if (this.currentBg && typeof this.currentBg.updateFromAlbum === 'function') {
                try {
                    await this.currentBg.updateFromAlbum(url);
                } catch (e) {
                    console.warn("[èƒŒæ™¯ç³»ç»Ÿ] updateFromAlbum å¤±è´¥:", e);
                }
            }
        }
    }

    // =========================================================
    // æ§åˆ¶é¢æ¿æ™ºèƒ½é€‚é…ï¼šè¿è¡Œæ—¶åˆ†æç°æœ‰å¸ƒå±€ç©ºé—´ï¼ˆæŒ‰éœ€æ±‚å¿…é¡»åˆ†æï¼‰
    // =========================================================
    function analyzeExistingLayout() {
        try {
            const container = document.querySelector('.container');
            const searchSection = document.querySelector('.search-section');
            const controls = document.querySelector('.controls');

            const report = {
                containerWidth: container ? container.clientWidth : null,
                searchSectionWidth: searchSection ? searchSection.clientWidth : null,
                controlsWidth: controls ? controls.clientWidth : null,
                viewport: { w: window.innerWidth, h: window.innerHeight }
            };

            console.log("[å¸ƒå±€åˆ†æ] ç°æœ‰æ§åˆ¶é¢æ¿ç©ºé—´è¯„ä¼°:", report);

            // æ–¹æ¡ˆé€‰æ‹©ï¼šæŠ˜å å¼æ§åˆ¶é¢æ¿ï¼ˆæœ¬å®ç°ï¼‰
            console.log("[å¸ƒå±€æ–¹æ¡ˆ] å·²å¯ç”¨ï¼šæ–¹æ¡ˆAï¼ˆæŠ˜å å¼æ§åˆ¶é¢æ¿ï¼‰ï¼Œé¿å…ç›´æ¥å †å æ§ä»¶ã€‚");
        } catch (e) {
            console.warn("[å¸ƒå±€åˆ†æ] å¤±è´¥:", e);
        }
    }

    // =========================================================
    // èƒŒæ™¯é¢æ¿ï¼šæ‹–æ‹½ï¼ˆå¯é€‰å¢å¼ºï¼Œæ»¡è¶³â€œæ™ºèƒ½é€‚é…/å¯ç”¨ç©ºé—´â€éœ€æ±‚ï¼‰
    // =========================================================
    function enablePanelDrag(panelEl, handleEl) {
        if (!panelEl || !handleEl) return;

        let dragging = false;
        let startX = 0, startY = 0;
        let startLeft = 0, startBottom = 0;

        const onDown = (e) => {
            // ä»…é¼ æ ‡/è§¦æ§ä¸»é”®
            if (e.type === 'mousedown' && e.button !== 0) return;

            dragging = true;
            const rect = panelEl.getBoundingClientRect();
            startLeft = rect.left;
            startBottom = window.innerHeight - rect.bottom;

            const pt = e.touches ? e.touches[0] : e;
            startX = pt.clientX;
            startY = pt.clientY;

            e.preventDefault();
        };

        const onMove = (e) => {
            if (!dragging) return;
            const pt = e.touches ? e.touches[0] : e;
            const dx = pt.clientX - startX;
            const dy = pt.clientY - startY;

            // left å¢åŠ  dxï¼Œbottom å‡å°‘ dyï¼ˆå› ä¸ºå‘ä¸‹ dy>0ï¼‰
            let newLeft = startLeft + dx;
            let newBottom = startBottom - dy;

            // è¾¹ç•Œé™åˆ¶
            const maxLeft = window.innerWidth - panelEl.offsetWidth - 8;
            const maxBottom = window.innerHeight - panelEl.offsetHeight - 8;
            newLeft = Math.max(8, Math.min(maxLeft, newLeft));
            newBottom = Math.max(8, Math.min(maxBottom, newBottom));

            panelEl.style.left = newLeft + 'px';
            panelEl.style.bottom = newBottom + 'px';
        };

        const onUp = () => { dragging = false; };

        handleEl.addEventListener('mousedown', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);

        handleEl.addEventListener('touchstart', onDown, { passive: false });
        window.addEventListener('touchmove', onMove, { passive: false });
        window.addEventListener('touchend', onUp);
        window.addEventListener('touchcancel', onUp);
    }

    // =========================================================
    // æµ‹è¯•æ¸…å•ï¼ˆæ§åˆ¶å°è¾“å‡ºï¼‰
    // =========================================================
    async function runIntegrationTests(bgManager) {
        const results = [];

        const ok = (name, pass, detail='') => {
            results.push({ æµ‹è¯•é¡¹: name, ç»“æœ: pass ? 'âœ…é€šè¿‡' : 'âŒå¤±è´¥', è¯´æ˜: detail });
        };

        // åŸºç¡€åŠŸèƒ½æµ‹è¯•ï¼ˆå°½é‡ä¸å¹²æ‰°åŸæ’­æ”¾å™¨ï¼‰
        ok('1. æ’­æ”¾/æš‚åœ/éŸ³é‡æ§åˆ¶å…ƒç´ å­˜åœ¨', !!document.getElementById('audioPlayer') && !!document.getElementById('playBtn') && !!document.getElementById('volumeSlider'));
        ok('2. å–è‰²å™¨/å°é¢å…ƒç´ å­˜åœ¨', !!document.getElementById('albumArt'));
        ok('3. KMeansæŒ‰é’®å­˜åœ¨', !!document.getElementById('algoToggleBtn') || !!document.querySelector('#algoToggleBtn'));
        ok('4. APIé€‰æ‹©å™¨å­˜åœ¨', !!document.getElementById('apiSelect'));

        // Fix: ç¦ç”¨è‡ªåŠ¨èƒŒæ™¯åˆ‡æ¢æµ‹è¯•ï¼Œé¿å…å¹²æ‰°åˆå§‹çŠ¶æ€å’Œç”¨æˆ·ä½“éªŒ
        // æ”¹ä¸ºé™æ€æ£€æŸ¥ï¼Œæ‰‹åŠ¨æµ‹è¯•å¯è°ƒç”¨ window.testBackgroundSwitch()
        ok('5. PixièƒŒæ™¯ç±»å·²åŠ è½½', typeof PixiBackgroundSystem === 'function');
        ok('6. MeshèƒŒæ™¯ç±»å·²åŠ è½½', typeof MeshBackgroundSystem === 'function');
        ok('7. èƒŒæ™¯ç®¡ç†å™¨å·²åˆå§‹åŒ–', !!bgManager && typeof bgManager.switchBackground === 'function');

        // ç®€æ˜“å†…å­˜é‡Šæ”¾æ£€æµ‹
        ok('8. èƒŒæ™¯å®¿ä¸»DOMçŠ¶æ€æ­£å¸¸', document.getElementById('bgHost')?.style.display === 'none', 'default æ¨¡å¼ä¸‹ bgHost åº”éšè—');

        // Fix: æ·»åŠ æ¸å˜åŠ¨ç”»è¿è¡ŒçŠ¶æ€æµ‹è¯•
        ok('8.1 æ¸å˜åŠ¨ç”»å‡½æ•°å·²æš´éœ²', typeof window.startGradientAnimation === 'function');
        ok('8.2 æ¸å˜åŠ¨ç”»æ­£åœ¨è¿è¡Œ', typeof window.getGradientAnimationId === 'function' && window.getGradientAnimationId() !== null, 'åŠ¨ç”» ID åº”ä¸ä¸º null');
        ok('8.3 gradientCanvaså¯è§', document.getElementById('gradientCanvas')?.style.display !== 'none');

        // æ§åˆ¶é¢æ¿æµ‹è¯•
        ok('9. èƒŒæ™¯é¢æ¿æŒ‰é’®å­˜åœ¨', !!document.getElementById('bgToggleBtn'));
        ok('10. èƒŒæ™¯é¢æ¿ç»“æ„å­˜åœ¨', !!document.getElementById('bgPanel') && !!document.getElementById('bgSwitchBtn'));
        ok('11. å“åº”å¼ï¼ˆæ— æ³•å¼ºæµ‹ï¼‰', true, 'è¯·åœ¨ä¸åŒçª—å£å°ºå¯¸ä¸‹è§‚å¯Ÿå¸ƒå±€æ˜¯å¦é‡å ');

        // è°ƒè¯•ç³»ç»Ÿæµ‹è¯•
        ok('12. æ§åˆ¶å°å¯åŠ¨æ—¥å¿—å·²è¾“å‡º', true, 'è¯·æ£€æŸ¥æ§åˆ¶å°é¡¶éƒ¨æ˜¯å¦å‡ºç°â€œéŸ³ä¹æ’­æ”¾å™¨èƒŒæ™¯ç³»ç»Ÿå¯åŠ¨â€');
        ok('13. å…¨å±€é”™è¯¯æ•è·å·²æ³¨å†Œ', true, 'å·²é€šè¿‡ window.addEventListener(error/unhandledrejection) æ³¨å†Œ');
        ok('14. reportPlayerStatus å¯è°ƒç”¨', typeof window.reportPlayerStatus === 'function');

        // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.group ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
        try { console.group("=== é›†æˆæµ‹è¯•æŠ¥å‘Šï¼ˆå¤šèƒŒæ™¯ç³»ç»Ÿï¼‰==="); } catch (e) { try { console.log("=== é›†æˆæµ‹è¯•æŠ¥å‘Šï¼ˆå¤šèƒŒæ™¯ç³»ç»Ÿï¼‰==="); } catch (_) {} }
        console.table(results);
        // Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.groupEnd ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
        try { console.groupEnd(); } catch (e) { try { console.log('=== é›†æˆæµ‹è¯•æŠ¥å‘Šç»“æŸ ==='); } catch (_) {} }

        dcInfo('æµ‹è¯•', 'å·²è¾“å‡ºå¤šèƒŒæ™¯ç³»ç»Ÿé›†æˆæµ‹è¯•æŠ¥å‘Šï¼ˆæ§åˆ¶å°ï¼‰');
        
        // Fix: æš´éœ²æ‰‹åŠ¨èƒŒæ™¯åˆ‡æ¢æµ‹è¯•å‡½æ•°ï¼Œé¿å…è‡ªåŠ¨æµ‹è¯•å¹²æ‰°åˆå§‹çŠ¶æ€
        window.testBackgroundSwitch = async function() {
            console.log("=== å¼€å§‹èƒŒæ™¯åˆ‡æ¢æµ‹è¯• ===");
            try {
                console.log("åˆ‡æ¢åˆ° Pixi èƒŒæ™¯...");
                await bgManager.switchBackground('pixi');
                console.log("âœ… Pixi èƒŒæ™¯åˆå§‹åŒ–æˆåŠŸ");
                await new Promise(r => setTimeout(r, 1500));
                
                console.log("åˆ‡æ¢åˆ° Mesh èƒŒæ™¯...");
                await bgManager.switchBackground('mesh');
                console.log("âœ… Mesh èƒŒæ™¯åˆå§‹åŒ–æˆåŠŸ");
                await new Promise(r => setTimeout(r, 1500));
                
                console.log("åˆ‡å›é»˜è®¤èƒŒæ™¯...");
                await bgManager.switchBackground('default');
                console.log("âœ… é»˜è®¤èƒŒæ™¯æ¢å¤æˆåŠŸ");
                
                console.log("=== èƒŒæ™¯åˆ‡æ¢æµ‹è¯•å®Œæˆ ===");
            } catch (e) {
                console.error("âŒ èƒŒæ™¯åˆ‡æ¢æµ‹è¯•å¤±è´¥:", e);
            }
        };
        console.log("ğŸ’¡ æç¤ºï¼šå¯åœ¨æ§åˆ¶å°è¿è¡Œ testBackgroundSwitch() è¿›è¡ŒèƒŒæ™¯åˆ‡æ¢æµ‹è¯•");
    }

    // =========================================================
    // åˆå§‹åŒ–å…¥å£
    // =========================================================
    function initBackgroundSystem() {
        analyzeExistingLayout();

        const bgHost = document.getElementById('bgHost');
        const bgPanel = document.getElementById('bgPanel');
        const bgToggleBtn = document.getElementById('bgToggleBtn');
        const bgSwitchBtn = document.getElementById('bgSwitchBtn');
        const bgControlsMount = document.getElementById('bgControlsMount');
        const bgStatusBadge = document.getElementById('bgStatusBadge');
        const bgFollowAlbum = document.getElementById('bgFollowAlbum');
        const bgPanelCloseBtn = document.getElementById('bgPanelCloseBtn');
        const bgPanelMinBtn = document.getElementById('bgPanelMinBtn');
        const bgPanelHeader = document.getElementById('bgPanelHeader');

        if (!bgHost || !bgPanel || !bgToggleBtn || !bgSwitchBtn || !bgControlsMount || !bgStatusBadge || !bgFollowAlbum) {
            console.warn("[èƒŒæ™¯ç³»ç»Ÿ] å¿…è¦DOMç¼ºå¤±ï¼Œåˆå§‹åŒ–ä¸­æ­¢ã€‚");
            return;
        }

        // åˆ›å»ºèƒŒæ™¯ç®¡ç†å™¨
        const bgManager = new BackgroundManager({
            hostEl: bgHost,
            controlsMountEl: bgControlsMount,
            badgeEl: bgStatusBadge,
            followAlbumEl: bgFollowAlbum
        });
        window.__bgManager = bgManager;
        window.PixiBackgroundSystem = PixiBackgroundSystem;
        window.MeshBackgroundSystem = MeshBackgroundSystem;
        window.BackgroundManager = BackgroundManager;

        // é»˜è®¤èƒŒæ™¯ä½œä¸ºåˆå§‹çŠ¶æ€
        bgManager.switchBackground('default');

        // é¢æ¿å¼€å…³
        const openPanel = () => { bgPanel.classList.add('show'); };
        const closePanel = () => { bgPanel.classList.remove('show'); };
        const togglePanel = () => { bgPanel.classList.toggle('show'); };

        bgToggleBtn.addEventListener('click', togglePanel);
        if (bgPanelCloseBtn) bgPanelCloseBtn.addEventListener('click', closePanel);
        if (bgPanelMinBtn) bgPanelMinBtn.addEventListener('click', closePanel);

        // Fix: iOS è§¦æ§/é¼ æ ‡äº‹ä»¶åŒç»‘å®šï¼ˆtouchstart/touchend + mousedown/mouseup + clickï¼‰
        const bindBgBtn = (el, handler) => {
            if (!el || typeof handler !== 'function') return;
            let lastTouch = 0;

            el.addEventListener('touchstart', () => {}, { passive: true });
            el.addEventListener('touchend', (e) => {
                lastTouch = Date.now();
                try { if (e && e.cancelable) e.preventDefault(); } catch (_) {}
                try { handler(e); } catch (_) {}
            }, { passive: false });

            el.addEventListener('mousedown', () => {}, { passive: true });
            el.addEventListener('mouseup', () => {}, { passive: true });

            // æŠ‘åˆ¶ touchend åçš„åˆæˆ clickï¼Œé¿å…åŒè§¦å‘
            el.addEventListener('click', (e) => {
                if (Date.now() - lastTouch < 800) {
                    try { e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation(); } catch (_) {}
                }
            }, true);

            try { el.dataset.compatBound = '1'; } catch (_) {}
        };

        bindBgBtn(bgToggleBtn, togglePanel);
        if (bgPanelCloseBtn) bindBgBtn(bgPanelCloseBtn, closePanel);
        if (bgPanelMinBtn) bindBgBtn(bgPanelMinBtn, closePanel);

        // åˆ‡æ¢èƒŒæ™¯
        const handleBgSwitch = async () => {
            try { await bgManager.cycle(); } catch (e) { console.warn('[èƒŒæ™¯ç³»ç»Ÿ] cycle å¤±è´¥:', e); }
        };
        bgSwitchBtn.addEventListener('click', handleBgSwitch);
        bindBgBtn(bgSwitchBtn, () => { handleBgSwitch(); });

        // æ‹–æ‹½
        enablePanelDrag(bgPanel, bgPanelHeader);

        // ç›‘å¬ä¸“è¾‘å°é¢å˜åŒ–ï¼šç¡®ä¿â€œåŠ è½½æ–°çš„ä¸“è¾‘å°é¢åï¼ŒåŠ¨æ€èƒŒæ™¯ç«‹å³æ›´æ–°â€
        const albumArtEl = document.getElementById('albumArt');
        if (albumArtEl) {
            let last = albumArtEl.src || '';
            if (last) bgManager.lastAlbumUrl = last;

            const mo = new MutationObserver(async (mutations) => {
                for (const m of mutations) {
                    if (m.type === 'attributes' && m.attributeName === 'src') {
                        const url = albumArtEl.src || '';
                        if (url && url !== last) {
                            last = url;
                            console.log("[èƒŒæ™¯ç³»ç»Ÿ] ä¾¦æµ‹åˆ°ä¸“è¾‘å°é¢æ›´æ–°ï¼Œæ¨é€åˆ°èƒŒæ™¯:", url);
                            dcInfo('èƒŒæ™¯ç³»ç»Ÿ', `ä¾¦æµ‹åˆ°ä¸“è¾‘å°é¢æ›´æ–°ï¼š${url}`);
                            await bgManager.handleAlbumArtChanged(url);
                        }
                    }
                }
            });
            mo.observe(albumArtEl, { attributes: true, attributeFilter: ['src'] });
        } else {
            console.warn("[èƒŒæ™¯ç³»ç»Ÿ] æœªæ‰¾åˆ° albumArt å…ƒç´ ï¼Œæ— æ³•è‡ªåŠ¨è·Ÿéšå°é¢ã€‚");
        }

        // æä¾›å¿«æ·æ¥å£ï¼ˆä¾¿äºè°ƒè¯•ï¼‰
        window.switchBackground = async (type) => {
            const allowed = ['default','pixi','mesh'];
            if (!allowed.includes(type)) {
                console.warn("[switchBackground] ä¸æ”¯æŒçš„èƒŒæ™¯ç±»å‹:", type);
                return;
            }
            bgManager.currentIndex = allowed.indexOf(type);
            await bgManager.switchBackground(type);
            openPanel();
        };

        // è¾“å‡ºæµ‹è¯•æŠ¥å‘Šï¼ˆæŒ‰éœ€æ±‚å¿…é¡»å…ˆæµ‹è¯•ï¼‰
        runIntegrationTests(bgManager);
    }

    // ä½¿ç”¨ window.loadï¼Œç¡®ä¿åŸæ’­æ”¾å™¨ window.onload å·²æ‰§è¡Œä¸”ä¸è¢«è¦†ç›–
    window.addEventListener('load', () => {
        try {
            initBackgroundSystem();
        } catch (e) {
// Fix: å…¼å®¹ iOS / PWA åœºæ™¯ console.error ç¼ºå¤±å¯¼è‡´çš„å´©æºƒ
            try { console.error("[èƒŒæ™¯ç³»ç»Ÿ] åˆå§‹åŒ–å¼‚å¸¸:", e); } catch (e) { try { console.log("[èƒŒæ™¯ç³»ç»Ÿ] åˆå§‹åŒ–å¼‚å¸¸:", e); } catch (_) {} }
            dcError('èƒŒæ™¯ç³»ç»Ÿ', `åˆå§‹åŒ–å¼‚å¸¸ï¼š${e.message || e}`);
        }
    });
})();

</script>

<script>
// Fix: è‡ªæ£€å‡½æ•° â€”â€” åœ¨æ§åˆ¶å°è°ƒç”¨ checkCompatibility() è¾“å‡ºå…³é”®ä¿®å¤é¡¹çŠ¶æ€
window.checkCompatibility = function() {
    const r = {};

    try {
        r.consoleShim = !!window.console && ['log','error','warn','info','debug','group','groupCollapsed','groupEnd','table']
            .every(m => typeof console[m] === 'function');
    } catch (_) { r.consoleShim = false; }

    r.meta = {
        appleWebAppCapable: !!document.querySelector('meta[name="apple-mobile-web-app-capable"][content="yes"]'),
        appleStatusBarStyle: !!document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]'),
        appleTouchIcon: !!document.querySelector('link[rel="apple-touch-icon"]')
    };

    const audio = document.getElementById('audioPlayer');
    r.audio = {
        exists: !!audio,
        playsinlineAttr: !!audio && audio.hasAttribute('playsinline'),
        webkitPlaysinlineAttr: !!audio && audio.hasAttribute('webkit-playsinline'),
        preload: !!audio && audio.getAttribute('preload'),
        srcSet: !!audio && !!audio.src
    };

    try {
        const vh = getComputedStyle(document.documentElement).getPropertyValue('--vh').trim();
        r.vhFix = { hasVar: !!vh, value: vh };
    } catch (_) { r.vhFix = { hasVar: false }; }

    try {
        r.safeAreaSupported = !!(window.CSS && CSS.supports && (CSS.supports('padding-top: env(safe-area-inset-top)') || CSS.supports('padding-top: constant(safe-area-inset-top)')));
    } catch (_) { r.safeAreaSupported = false; }

    // å…³é”®ç»‘å®šæ ‡è®°ï¼ˆç”± bindUnifiedPress / bindBgBtn è®¾ç½®ï¼‰
    const ids = ['playBtn','prevBtn','nextBtn','fullscreenPlayBtn','fullscreenPrevBtn','fullscreenNextBtn','bgSwitchBtn','bgToggleBtn'];
    r.bindings = {};
    ids.forEach(id => {
        const el = document.getElementById(id);
        r.bindings[id] = !!el && !!(el.dataset && el.dataset.compatBound === '1');
    });

    r.fixState = window.__compatFix ? window.__compatFix.flags : undefined;

    // è¾“å‡º
    try { console.groupCollapsed('checkCompatibility()'); } catch (_) {}
    try {
        // å…ˆè¾“å‡ºä¸€ä»½æ›´æ‰å¹³çš„æ‘˜è¦ï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥çœ‹
        console.table({
            consoleShim: r.consoleShim,
            appleWebAppCapable: r.meta.appleWebAppCapable,
            appleStatusBarStyle: r.meta.appleStatusBarStyle,
            appleTouchIcon: r.meta.appleTouchIcon,
            audioPlaysinline: r.audio.playsinlineAttr,
            audioWebkitPlaysinline: r.audio.webkitPlaysinlineAttr,
            vhVar: r.vhFix.hasVar,
            safeAreaSupported: r.safeAreaSupported
        });
    } catch (_) {}

    try { console.log('è¯¦ç»†ç»“æœ:', r); } catch (_) {}
    try { console.log('window.__compatFix:', window.__compatFix); } catch (_) {}
    try { console.groupEnd(); } catch (_) {}

    return r;
};

// =========================================================
// æ€§èƒ½ä¼˜åŒ–æ€»ç»“ (Performance Optimizations Summary)
// =========================================================
// 1. ontimeupdate: ä½¿ç”¨ requestAnimationFrame èŠ‚æµï¼Œå‡å°‘DOMæ“ä½œé¢‘ç‡
// 2. highlightCurrentLyric: ç¼“å­˜DOMå¼•ç”¨ï¼ŒäºŒåˆ†æŸ¥æ‰¾ï¼ŒèŠ‚æµscrollIntoView
// 3. progress bar: ä½¿ç”¨ CSS transform (scaleX) ä»£æ›¿ width å±æ€§
// 4. è°ƒè¯•æ§åˆ¶å°: RAF å»¶è¿Ÿæ»šåŠ¨é¿å…è¯»å†™äº¤é”™
// 5. seek å‡½æ•°: ç¼“å­˜ getBoundingClientRect ç»“æœ
// 6. CSS will-change: ä¸ºé¢‘ç¹å˜åŒ–çš„å…ƒç´ å¯ç”¨GPUåŠ é€Ÿ
// =========================================================

// iOS ç‰¹å®šä¼˜åŒ–ï¼šå‡å°‘ passive event listener çš„æ€§èƒ½å¼€é”€
if (typeof window !== 'undefined') {
    // æ£€æµ‹æ˜¯å¦æ”¯æŒ passive
    let passiveSupported = false;
    try {
        const options = {
            get passive() {
                passiveSupported = true;
                return false;
            }
        };
        window.addEventListener('test', null, options);
        window.removeEventListener('test', null, options);
    } catch (e) {}
    
    // æš´éœ²ç»™è°ƒè¯•
    window.__performanceOptimizations = {
        version: '2.1-perf',
        rafThrottling: true,
        domCaching: true,
        cssTransforms: true,
        scrollThrottling: true,
        passiveEvents: passiveSupported,
        timestamp: new Date().toISOString()
    };
    
    // æ€§èƒ½æ£€æµ‹å‡½æ•°
    window.checkPerformance = function() {
        const perf = window.__performanceOptimizations || {};
        console.log('=== æ€§èƒ½ä¼˜åŒ–çŠ¶æ€ ===');
        console.table(perf);
        
        // æ£€æµ‹æ˜¯å¦æœ‰é•¿ä»»åŠ¡
        if (window.PerformanceObserver) {
            console.log('æç¤ºï¼šå¯ä»¥ä½¿ç”¨ PerformanceObserver ç›‘æ§é•¿ä»»åŠ¡');
        }
        return perf;
    };
}
</script>

<!-- å•æ–‡ä»¶ç‰ˆï¼šå·²ç§»é™¤ Cloudflare challenge-platform æ³¨å…¥è„šæœ¬ï¼ˆæœ¬åœ° file:// ä¼šå¯¼è‡´ /C:/cdn-cgi... 404ï¼‰ --></body>
</html>