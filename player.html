<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <!-- Fix: iOS/PWA 元信息增强 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- 单文件版：已移除外部 apple-touch-icon 依赖（如需图标可改为 data: URI） -->
<!-- 可根据需要补充更多尺寸的图标链接 -->

    <!-- Fix: 兼容 iOS / PWA 场景下 console 缺失导致的崩溃（必须置于所有脚本之前） -->
    <script>
    // === CONSOLE 安全兼容层 (必须置于所有脚本之前) ===
    (function() {
        if (!window.console) window.console = {};
        const methods = ['log', 'error', 'warn', 'info', 'debug', 'group', 'groupCollapsed', 'groupEnd', 'table'];
        methods.forEach(m => {
            if (typeof console[m] !== 'function') console[m] = function() {};
        });
    })();
    // === 结束 ===

    // Fix: 视口高度 --vh（替代 100vh，避免 iOS 地址栏/工具栏遮挡）
    (function() {
        function setVhVar() {
            try {
                const h = (window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight;
                document.documentElement.style.setProperty('--vh', (h * 0.01) + 'px');
            } catch (_) {}
        }
        setVhVar();
        window.addEventListener('resize', setVhVar);
        window.addEventListener('orientationchange', setVhVar);
        window.addEventListener('pageshow', setVhVar);
        if (window.visualViewport && typeof window.visualViewport.addEventListener === 'function') {
            window.visualViewport.addEventListener('resize', setVhVar);
        }
        // 暴露给自检使用
        window.__compatFix = window.__compatFix || {};
        window.__compatFix.setVhVar = setVhVar;
    })();
    </script>

    <title>音乐播放器 - Apple Liquid Glass 风格</title>
    <style>
        /* 只添加必要的CSS修改，其他CSS保持不变 */
        
        /* API选择器样式 */
        .api-select {
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
            min-width: 180px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .api-select:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .api-select option {
            background: #333;
            color: white;
        }
        
        

/* 颜色算法切换按钮样式 */
.algo-toggle-btn {
    padding: 15px 20px;
    border: none;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    font-size: 1rem;
    backdrop-filter: blur(10px);
    min-width: 180px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.algo-toggle-btn:hover {
    background: rgba(255, 255, 255, 0.2);
}

        /* API选择器提示标签 */
        .api-select-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
            margin-left: 5px;
            font-weight: normal;
        }
        
        @media (max-width: 768px) {
            .search-section {
                flex-direction: column;
            }
            
            .api-select, .algo-toggle-btn, .source-select, .quality-select {
                width: 100%;
            }
        }
        
        /* 搜索结果中的平台标签 */
        .result-item .platform-badge {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 2px;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .result-item .platform-badge.kuwo {
            background: rgba(255, 87, 34, 0.2);
            color: #ff5722;
        }
        
        .result-item .platform-badge.netease {
            background: rgba(216, 30, 6, 0.2);
            color: #d81e06;
        }
        
        .result-item .platform-badge.qq {
            background: rgba(25, 137, 250, 0.2);
            color: #1989fa;
        }
        
        .result-item .platform-badge.joox {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
        
        .result-item .platform-badge.aggregate {
            background: rgba(156, 39, 176, 0.2);
            color: #9c27b0;
        }
        
        /* 性能优化：逐词高亮使用CSS类而非内联样式 */
        .word-highlight {
            transition: color 0.15s ease;
        }
        .word-highlight.word-active {
            color: #ffcc00 !important;
        }
        
        /* 性能优化：进度条使用transform代替width */
        #progress, #fullscreenProgress {
            width: 100% !important;
            transform-origin: left;
            transform: scaleX(0);
        }
        
        /* 性能优化：启用GPU加速 */
        .lyric-line, .fullscreen-lyric-line {
            will-change: transform, opacity;
        }
        
        /* 原有的所有CSS保持不变 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-overflow-scrolling: touch; 
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', 'Inter', sans-serif;
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
            position: relative;
            overflow-x: hidden; 
            background-color: #000;
            -webkit-font-smoothing: antialiased;
        }

        #gradientCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            transform: scale(1.05);
            filter: blur(15px);
            opacity: 0.9;
            transition: opacity 0.5s ease;
        }

        .liquid-glass-effect {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(35px) saturate(180%);
            -webkit-backdrop-filter: blur(35px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4), 
                        inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 20px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        .search-section {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .search-box {
            flex: 1;
            min-width: 300px;
            position: relative;
        }
        
        .search-input {
            width: 100%;
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(255,255,255,0.1);
        }
        
        .source-select, .quality-select {
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
            min-width: 150px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .source-select option, .quality-select option {
            background: #333;
            color: white;
        }

        .source-select:hover, .quality-select:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .search-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .search-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .player-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            .player-container {
                grid-template-columns: 1fr;
            }
        }
        
        .now-playing {
            border-radius: 20px;
            padding: 30px;
            position: relative;
        }
        
        .album-art {
            width: 100%;
            border-radius: 20px;
            margin-bottom: 25px;
            aspect-ratio: 1;
            object-fit: cover;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4);
            display: none;
            transition: transform 0.3s ease;
        }
        
        .album-art-placeholder {
            width: 100%;
            border-radius: 20px;
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 4rem;
            margin-bottom: 25px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
        }
        
        .song-info {
            margin-bottom: 25px;
        }
        
        .song-title {
            font-size: 1.8rem;
            margin-bottom: 8px;
            font-weight: 700;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .song-artist {
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.1rem;
            font-weight: 500;
        }
        
        .progress-container {
            margin-bottom: 25px;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
            margin-bottom: 12px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: white;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .progress-handle {
            position: absolute;
            top: 50%;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            will-change: left; /* 性能优化：提示浏览器准备GPU加速 */
        }
        
        .progress-bar:hover .progress-handle {
            opacity: 1;
        }
        
        .time-info {
            display: flex;
            justify-content: space-between;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 25px;
            margin-bottom: 25px;
        }
        
        .control-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }
        
        .play-btn {
            background: rgba(255, 255, 255, 0.2);
            width: 70px;
            height: 70px;
            font-size: 2rem;
        }

        .play-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .speed-control {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.2);
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .speed-control input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            cursor: pointer;
        }
        
        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .lyrics-container {
            border-radius: 20px;
            padding: 30px;
            max-height: 400px;
            overflow-y: auto;
            touch-action: pan-y; 
            position: relative;
        }

        .lyrics-container::-webkit-scrollbar {
            width: 8px;
        }

        .lyrics-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .lyrics-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .lyrics-container::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .fullscreen-lyrics-btn {
            position: absolute;
            bottom: 25px;
            right: 25px;
            background: rgba(255, 255, 255, 0.25);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            z-index: 10;
            font-weight: 600;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .fullscreen-lyrics-btn:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .lyrics-content {
            line-height: 1.8;
            text-align: center;
        }
        
        .lyric-line {
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.5);
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            cursor: pointer;
            padding: 10px 15px;
            border-radius: 12px;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-weight: 500;
        }
        
        .lyric-line.active {
            color: #fff;
            font-size: 1.2rem;
            background: rgba(255, 255, 255, 0.15);
            font-weight: 700;
            transform: scale(1.02);
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .original-text, .translation-text {
            display: inline-block;
            transition: color 0.3s ease;
        }
        .translation-text {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
            font-weight: 400;
        }
        
        .lyric-line.active .translation-text {
            color: rgba(255, 255, 255, 0.85);
        }

        .word-highlight {
            color: #ffcc00;
            transition: color 0.1s linear;
        }

        .fullscreen-lyrics-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
            display: none;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.65); 
            transition: opacity 0.5s ease;
            opacity: 0;
            touch-action: none; 
        }

        .fullscreen-lyrics-overlay.active {
            display: block;
            opacity: 1;
        }

        .fullscreen-lyrics-content {
            position: relative;
            z-index: 2;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0;
        }

        .close-fullscreen-btn {
            position: fixed;
            top: 50px;
            right: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 10000;
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .fullscreen-lyrics-lines {
            width: 100%;
            flex-grow: 1;
            padding: 0 20px 0 40px;
            margin-top: 20px;
            overflow-y: auto;
            text-align: left;
            scrollbar-width: none;
            touch-action: pan-y; 
            mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
        }
        
        .fullscreen-lyrics-lines::-webkit-scrollbar {
            display: none;
        }

        .fullscreen-lyric-line {
            font-size: clamp(2rem, 5vw, 3rem);
            line-height: 1.35;
            padding: 10px 0;
            margin: 25px 0;
            color: rgba(255, 255, 255, 0.4);
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            font-weight: 700;
            cursor: pointer;
        }
        
        .fullscreen-line-wrapper {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .fullscreen-lyric-line.active {
            color: #fff;
            font-size: clamp(2.5rem, 6vw, 3.5rem);
            font-weight: 800;
            transform: scale(1.01);
            text-shadow: 0 4px 30px rgba(0,0,0,0.4);
        }
        
        .fullscreen-translation-text {
            font-size: 0.6em;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        }
        
        .fullscreen-lyric-line.active .fullscreen-translation-text {
             color: rgba(255, 255, 255, 0.85);
        }

        .fullscreen-controls-panel {
            flex-shrink: 0;
            width: 90%;
            max-width: 600px;
            margin-bottom: 50px;
            padding: 15px 25px;
            border-radius: 40px;
        }

        .fullscreen-song-info {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .fullscreen-album-art {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            object-fit: cover;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .fullscreen-track-details {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            white-space: nowrap;
        }

        .fullscreen-song-title {
            font-size: 1.2rem;
            font-weight: 700;
            text-overflow: ellipsis;
        }

        .fullscreen-song-artist {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .fullscreen-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .fullscreen-progress {
            height: 100%;
            background: white;
            border-radius: 2px;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .fullscreen-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
        }

        .fullscreen-control-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            font-size: 2.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .fullscreen-control-btn.play {
            width: 65px;
            height: 65px;
            background: white;
            color: black;
            font-size: 2.5rem;
            padding-left: 5px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .fullscreen-control-btn:hover {
            transform: scale(1.1);
        }
        
        .fullscreen-control-btn.play:hover {
            transform: scale(1.05);
        }
        
        @media (max-width: 900px) {
            .fullscreen-lyrics-content {
                justify-content: flex-end;
                align-items: flex-start;
            }
            .fullscreen-lyrics-lines {
                margin-top: auto;
                height: 60vh;
                padding-bottom: 20px;
                padding-left: 20px;
                text-align: left;
            }
            .fullscreen-lyric-line {
                font-size: clamp(1.8rem, 5vw, 2.5rem);
            }
            .fullscreen-lyric-line.active {
                font-size: clamp(2.3rem, 6vw, 3rem);
            }
            .fullscreen-controls-panel {
                width: 95%;
                margin-bottom: 30px;
            }
            .close-fullscreen-btn {
                top: 20px;
                right: 20px;
            }
        }
        
        .search-results {
            border-radius: 20px;
            padding: 20px;
        }
        
        .results-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 15px;
            padding: 0 10px;
        }

        #resultsContainer {
            overflow: hidden;
        }
        
        .result-item {
            display: flex;
            align-items: center;
            padding: 12px 10px;
            gap: 15px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            position: relative;
            background: rgba(255, 255, 255, 0.05); 
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #resultsContainer .result-item:first-child {
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
        }
        #resultsContainer .result-item:last-child {
            border-bottom-left-radius: 15px;
            border-bottom-right-radius: 15px;
            border-bottom: none;
        }
        
        .result-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.005);
        }
        
        .result-item.active {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.005);
        }

        .result-album {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            object-fit: cover;
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .result-info {
            flex-grow: 1;
            min-width: 0;
            overflow: hidden;
        }

        .result-title {
            font-size: 1.1rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .result-artist {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .result-album-name {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 2px;
        }
        
        .result-platform-info {
            display: flex;
            gap: 8px;
            margin-top: 2px;
        }
        
        .search-results .loading {
            padding: 20px 10px;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
        }

        /* ========== 调试控制台样式 ========== */
        .debug-console {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            width: 400px;
            max-height: 500px;
            background: rgba(20, 20, 20, 0.95);
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            transition: all 0.3s ease;
        }
        
        .debug-console.collapsed {
            height: auto;
        }
        
        .debug-console.expanded {
            height: 500px;
        }
        
        .debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: rgba(40, 40, 40, 0.9);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: move;
            user-select: none;
        }
        
        .debug-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .debug-controls {
            display: flex;
            gap: 5px;
        }
        
        .debug-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .debug-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .debug-btn.clear {
            color: #ff6b6b;
        }
        
        .debug-btn.clear:hover {
            background: rgba(255, 107, 107, 0.2);
        }
        
        .debug-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Courier New', Monaco, monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .debug-log {
            margin-bottom: 8px;
            padding: 8px 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.03);
            border-left: 3px solid #4dabf7;
            word-break: break-all;
            white-space: pre-wrap;
            color: #e9ecef;
        }
        
        .debug-log.error {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.08);
            color: #ffc9c9;
        }
        
        .debug-log.warning {
            border-left-color: #ffd43b;
            background: rgba(255, 212, 59, 0.08);
            color: #ffec99;
        }
        
        .debug-log.info {
            border-left-color: #4dabf7;
            background: rgba(77, 171, 247, 0.08);
            color: #c5f6fa;
        }
        
        .debug-log.success {
            border-left-color: #51cf66;
            background: rgba(81, 207, 102, 0.08);
            color: #b2f2bb;
        }
        
        .debug-log.api {
            border-left-color: #9775fa;
            background: rgba(151, 117, 250, 0.08);
            color: #d0bfff;
        }
        
        .debug-timestamp {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 2px;
        }
        
        .debug-message {
            margin-top: 2px;
        }
        
        .debug-toggle-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            width: 50px;
            height: 50px;
            border-radius: 25px;
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        .debug-toggle-btn:hover {
            background: rgba(60, 60, 60, 0.9);
            transform: scale(1.05);
        }
        
        .debug-toggle-btn.hidden {
            display: none;
        }
        
        .debug-console.hidden {
            display: none;
        }
        
        /* 滚动条样式 */
        .debug-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .debug-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        .debug-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }
        
        .debug-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        @media (max-width: 600px) {
            .debug-console {
                width: 95%;
                right: 2.5%;
                bottom: 80px;
                max-height: 300px;
            }
            
            .debug-console.expanded {
                height: 300px;
            }
            
            .result-item {
                padding: 10px;
            }
        }

        @media (max-width: 600px) {
            .result-item {
                padding: 10px;
            }
        }
    </style>

<style>

    /* =========================================================
       多背景系统（集成版）
       方案A：折叠式控制面板（不占用原控制区空间）
       ========================================================= */

    /* 背景宿主层：用于挂载 Pixi / Mesh 的画布 */
    #bgHost {
        position: fixed;
        inset: 0;
        z-index: -1;
        pointer-events: none; /* 关键：确保取色/点击/滚动等交互不被背景拦截 */
        overflow: hidden;
        /* Pixi背景原版用于避免加载前黑屏的径向渐变，这里作为统一兜底 */
        background: radial-gradient(circle at center, rgba(255,107,107,0.55) 0%, rgba(78,205,196,0.45) 30%, rgba(69,183,209,0.35) 60%, rgba(150,206,180,0.30) 100%);
        /* Fix: 默认隐藏 bgHost，只在切换到 pixi/mesh 背景时显示，避免覆盖 gradientCanvas */
        display: none;
    }
    #bgHost .bg-layer {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
    }
    #bgHost canvas {
        width: 100%;
        height: 100%;
        display: block;
        pointer-events: none;
    }

    /* 确保默认渐变背景画布不拦截交互 */
    #gradientCanvas { pointer-events: none; }

    /* 背景控制面板：浮动按钮（左下角） */
    #bgToggleBtn {
        position: fixed;
        left: calc(16px + env(safe-area-inset-left));
        bottom: calc(16px + env(safe-area-inset-bottom));
        z-index: 9999;

        width: 44px;
        height: 44px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.25);

        color: #fff;
        background: rgba(255,255,255,0.12);
        box-shadow: 0 10px 30px rgba(0,0,0,0.25);
        -webkit-backdrop-filter: blur(18px) saturate(180%);
        backdrop-filter: blur(18px) saturate(180%);
        cursor: pointer;
        user-select: none;
        transition: transform 0.15s ease, background 0.15s ease;
    }
    #bgToggleBtn:hover { transform: translateY(-1px); background: rgba(255,255,255,0.16); }
    #bgToggleBtn:active { transform: translateY(0px) scale(0.99); }

    /* 背景面板主体 */
    #bgPanel {
        position: fixed;
        left: calc(16px + env(safe-area-inset-left));
        bottom: calc(68px + env(safe-area-inset-bottom));
        z-index: 9998;

        width: min(360px, calc(100vw - 32px));
        max-height: min(72vh, 640px);
        overflow: hidden;

        border-radius: 16px;
        border: 1px solid rgba(255,255,255,0.22);
        background: rgba(255,255,255,0.10);
        box-shadow: 0 16px 40px rgba(0,0,0,0.30);
        -webkit-backdrop-filter: blur(18px) saturate(180%);
        backdrop-filter: blur(18px) saturate(180%);

        display: none;
    }
    #bgPanel.show { display: block; }

    .bg-panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;

        padding: 12px 12px 10px 12px;
        border-bottom: 1px solid rgba(255,255,255,0.18);
        cursor: move; /* 支持拖拽 */
        user-select: none;
    }

    .bg-panel-title {
        display: flex;
        align-items: center;
        gap: 8px;
        color: #fff;
        font-weight: 700;
        font-size: 14px;
    }

    .bg-badge {
        display: inline-flex;
        align-items: center;
        padding: 3px 8px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        color: #fff;
        background: rgba(0,0,0,0.25);
        border: 1px solid rgba(255,255,255,0.20);
    }

    .bg-panel-actions { display: flex; gap: 8px; }
    .bg-panel-actions button {
        width: 30px;
        height: 30px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.20);
        background: rgba(0,0,0,0.18);
        color: #fff;
        cursor: pointer;
        transition: background 0.15s ease;
    }
    .bg-panel-actions button:hover { background: rgba(0,0,0,0.28); }

    .bg-panel-body {
        padding: 12px;
        overflow: auto;
        max-height: calc(min(72vh, 640px) - 52px);
    }

    .bg-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
    }

    .bg-main-btn {
        padding: 10px 14px;
        border: none;
        border-radius: 12px;
        background: rgba(255,255,255,0.16);
        color: #fff;
        cursor: pointer;
        font-weight: 700;
        transition: background 0.15s ease, transform 0.15s ease;
    }
    .bg-main-btn:hover { background: rgba(255,255,255,0.22); transform: translateY(-1px); }
    .bg-main-btn:active { transform: translateY(0px) scale(0.99); }

    .bg-checkbox {
        display: flex;
        align-items: center;
        gap: 8px;
        color: rgba(255,255,255,0.95);
        font-size: 13px;
        user-select: none;
        cursor: pointer;
    }
    .bg-checkbox input { width: 18px; height: 18px; cursor: pointer; }

    .bg-sep {
        height: 1px;
        background: rgba(255,255,255,0.16);
        margin: 10px 0 12px 0;
    }

    .bg-hint {
        color: rgba(255,255,255,0.85);
        font-size: 12px;
        line-height: 1.45;
        padding: 10px;
        border-radius: 12px;
        border: 1px dashed rgba(255,255,255,0.18);
        background: rgba(0,0,0,0.10);
    }

    /* 背景专用控制区：复用原控件语义，但统一成“液态玻璃”风格 */
    .bg-controls .control-group-title {
        color: rgba(255,255,255,0.95);
        font-weight: 800;
        font-size: 13px;
        margin: 8px 0 10px 0;
    }
    .bg-controls .bg-ctrl-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
    }
    .bg-controls label {
        color: rgba(255,255,255,0.92);
        font-size: 13px;
        user-select: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .bg-controls input[type="range"] { width: 160px; }
    .bg-controls input[type="text"] {
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.22);
        background: rgba(0,0,0,0.18);
        color: #fff;
        outline: none;
    }
    .bg-controls .bg-file-btn,
    .bg-controls button {
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.22);
        background: rgba(0,0,0,0.18);
        color: #fff;
        cursor: pointer;
        transition: background 0.15s ease;
    }
    .bg-controls .bg-file-btn:hover,
    .bg-controls button:hover { background: rgba(0,0,0,0.28); }
    .bg-controls .bg-file-name {
        color: rgba(255,255,255,0.75);
        font-size: 12px;
        word-break: break-all;
        line-height: 1.35;
    }
    .bg-controls .bg-subtle {
        color: rgba(255,255,255,0.75);
        font-size: 12px;
    }

    /* 小屏适配：面板靠底部、宽度铺满，避免与播放器控件重叠 */
    @media (max-width: 680px) {
        #bgPanel {
            left: calc(12px + env(safe-area-inset-left));
            right: calc(12px + env(safe-area-inset-right));
            width: auto;
            bottom: calc(64px + env(safe-area-inset-bottom));
            max-height: 62vh;
        }
        #bgToggleBtn {
            left: calc(12px + env(safe-area-inset-left));
            bottom: calc(12px + env(safe-area-inset-bottom));
        }
        .bg-controls input[type="range"] { width: 100%; }
    }

</style>

<style id="ios-pwa-fixes">
/* =========================================================
   Fix: iOS / 全平台兼容增强（仅做添加/安全覆盖）
   ========================================================= */

/* Fix: 让滚动容器在 iOS 上具备惯性滚动体验 */
.lyrics-container,
.fullscreen-lyrics-lines,
.bg-panel-body,
.debug-content {
    -webkit-overflow-scrolling: touch;
}

/* Fix: 安全区域（刘海屏/圆角屏）适配 */
body {
    padding-top: calc(20px + env(safe-area-inset-top));
    padding-left: calc(20px + env(safe-area-inset-left));
    padding-right: calc(20px + env(safe-area-inset-right));
    padding-bottom: calc(20px + env(safe-area-inset-bottom));
}

/* Fix: 使用 --vh 替代 100vh（配合 head 内 setVhVar 脚本） */
:root { --vh: 1vh; }
body { min-height: calc(var(--vh, 1vh) * 100); }
.fullscreen-lyrics-overlay { height: calc(var(--vh, 1vh) * 100); }
#gradientCanvas, #bgHost { height: calc(var(--vh, 1vh) * 100); }

/* Fix: 全屏关闭按钮避开顶部安全区 */
.close-fullscreen-btn {
    top: calc(20px + env(safe-area-inset-top));
    right: calc(20px + env(safe-area-inset-right));
}
@media (max-width: 900px) {
    .close-fullscreen-btn {
        top: calc(12px + env(safe-area-inset-top));
        right: calc(12px + env(safe-area-inset-right));
    }
}
</style>


<script>
  // 强制同域 API（防止残留导致直连第三方域名）
  try {
    if (window.API_CONFIG?.gdstudio) window.API_CONFIG.gdstudio.baseUrl = '/api.php';
    if (window.API_CONFIG?.tunehub) window.API_CONFIG.tunehub.baseUrl = '/api/';
  } catch (e) {}
</script>

<script>
  function __wrapKuwoIfNeeded(u){
    try{
      const url = new URL(u, location.origin);
      if (/(\.|^)kuwo\.cn$/i.test(url.hostname || '')) {
        return '/api.php?target=' + encodeURIComponent(url.toString());
      }
      return u;
    } catch(e) { return u; }
  }
</script>
<script>
(function () {
  const HOST_RE = /(^|\.)kuwo\.cn$|(^|\.)kwcdn\.kuwo\.cn$|(^|\.)sycdn\.kuwo\.cn$/i;
  function abs(url){ try{return new URL(url, location.href).toString();}catch(e){return String(url||"");} }
  function shouldProxy(u){ try{const x=new URL(u);return (x.protocol==="http:"||x.protocol==="https:") && HOST_RE.test(x.hostname||"");}catch(e){return false;} }
  function proxify(url){
    const u=abs(url);
    if(!shouldProxy(u)) return url;
    return "/api/?target="+encodeURIComponent(u);
  }

  const imgDesc = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype,"src");
  if(imgDesc && imgDesc.set && imgDesc.get){
    Object.defineProperty(HTMLImageElement.prototype,"src",{get:imgDesc.get,set:function(v){return imgDesc.set.call(this,proxify(v));}});
  }
  const mediaDesc = Object.getOwnPropertyDescriptor(HTMLMediaElement.prototype,"src");
  if(mediaDesc && mediaDesc.set && mediaDesc.get){
    Object.defineProperty(HTMLMediaElement.prototype,"src",{get:mediaDesc.get,set:function(v){return mediaDesc.set.call(this,proxify(v));}});
  }
  const _setAttr = Element.prototype.setAttribute;
  Element.prototype.setAttribute = function(name,value){
    if(String(name).toLowerCase()==="src"){
      if(this instanceof HTMLImageElement || this instanceof HTMLMediaElement){
        return _setAttr.call(this,name,proxify(value));
      }
    }
    return _setAttr.call(this,name,value);
  };
  const _fetch = window.fetch;
  window.fetch = function(input,init){
    try{
      if(typeof input==="string") return _fetch.call(this,proxify(input),init);
      if(input && typeof input.url==="string"){
        const nu=proxify(input.url);
        if(nu!==input.url) return _fetch.call(this,new Request(nu,input),init);
      }
    }catch(e){}
    return _fetch.call(this,input,init);
  };

  // 强制 API2 同域（GDStudio 不代理）
  try{ if(window.API_CONFIG && window.API_CONFIG.tunehub) window.API_CONFIG.tunehub.baseUrl="/api/"; }catch(e){}
})();
</script>
</head>
<body>
    <canvas id="gradientCanvas"></canvas>
    <div id="bgHost" aria-hidden="true"></div>

    <div class="container">
        <div class="header liquid-glass-effect">
            <h1>音乐播放器</h1>
        </div>
        
        <div class="search-section">
            <div class="search-box">
                <input type="text" class="search-input" id="searchInput" placeholder="搜索歌曲、歌手或专辑..." value="周杰伦">
            </div>
            <!-- 新增：API选择器 -->
            <select class="api-select" id="apiSelect" title="选择API接口源">
                <option value="gdstudio" selected>原API (GDStudio)</option>
                <option value="tunehub">备用API (TuneHub)</option>
            </select>
                        <button class="algo-toggle-btn" id="algoToggleBtn" title="切换专辑封面颜色提取算法">算法：原(中位切分)</button>
<select class="source-select" id="sourceSelect">
                <option value="kuwo" selected>酷我音乐</option>
                <option value="joox">JOOX音乐</option>
                <option value="netease">网易云音乐</option>
                <!-- TuneHub API专用选项 -->
                <option value="qq">QQ音乐 (仅TuneHub)</option>
                <option value="aggregate">聚合搜索 (仅TuneHub)</option>
            </select>
            <button class="search-btn" id="searchBtn">搜索</button>
        </div>
        
        <div class="player-container">
            <div class="now-playing liquid-glass-effect">
                
                <div class="speed-control">
                    <span>速度</span>
                    <input type="range" id="speedSlider" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>

                <div class="album-art-placeholder">♪</div>
                <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==" alt="专辑封面" class="album-art" id="albumArt">
                <div class="song-info">
                    <h2 class="song-title" id="songTitle">请选择歌曲</h2>
                    <p class="song-artist" id="songArtist">未知艺术家</p>
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar">
                        <div class="progress" id="progress"></div>
                        <div class="progress-handle" id="progressHandle"></div>
                    </div>
                    <div class="time-info">
                        <span id="currentTime">0:00</span>
                        <span id="duration">0:00</span>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="control-btn" id="prevBtn">⏮</button>
                    <button class="control-btn play-btn" id="playBtn">▶</button>
                    <button class="control-btn" id="nextBtn">⏭</button>
                </div>
                
                <select class="quality-select" id="qualitySelect">
                    <option value="128">标准品质 (128k)</option>
                    <option value="192">良好品质 (192k)</option>
                    <option value="320">高品质 (320k)</option>
                    <option value="740">无损品质 (740k)</option>
                    <option value="999" selected>高解析度 (999k)</option>
                </select>
            </div>
            
            <div class="lyrics-container liquid-glass-effect" id="lyricsContainer">
                <h3 class="lyrics-title">歌词</h3>
                <div class="lyrics-content" id="lyricsContent">
                    <div class="loading">暂无歌词</div>
                </div>
                <button class="fullscreen-lyrics-btn" id="fullscreenLyricsBtn">
                    <span>⛶</span> 全屏沉浸模式
                </button>
            </div>
        </div>
        
        <div class="search-results liquid-glass-effect">
            <h3 class="results-title">搜索结果</h3>
            <div id="resultsContainer">
                <div class="loading">点击搜索按钮开始搜索音乐</div>
            </div>
        </div>
    </div>

    <div class="fullscreen-lyrics-overlay" id="fullscreenLyricsOverlay">
        <button class="close-fullscreen-btn" id="closeFullscreenBtn">✕</button>
        
        <div class="fullscreen-lyrics-content">
            <div class="fullscreen-lyrics-lines" id="fullscreenLyricsLines">
                <div class="loading">暂无歌词</div>
            </div>

            <div class="fullscreen-controls-panel liquid-glass-effect">
                
                <div class="fullscreen-song-info">
                    <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==" alt="专辑封面" class="fullscreen-album-art" id="fullscreenAlbumArt">
                    <div class="fullscreen-track-details">
                        <div class="fullscreen-song-title" id="fullscreenSongTitle">歌曲名称</div>
                        <div class="fullscreen-song-artist" id="fullscreenSongArtist">艺术家</div>
                    </div>
                </div>
                
                <div class="fullscreen-progress-bar" id="fullscreenProgressBar">
                    <div class="fullscreen-progress" id="fullscreenProgress"></div>
                </div>
                
                <div class="fullscreen-controls">
                    <button class="fullscreen-control-btn" id="fullscreenPrevBtn">⏮</button>
                    <button class="fullscreen-control-btn play" id="fullscreenPlayBtn">▶</button>
                    <button class="fullscreen-control-btn" id="fullscreenNextBtn">⏭</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 调试控制台 -->
    <button class="debug-toggle-btn" id="debugToggleBtn">🐛</button>
    
    <div class="debug-console hidden" id="debugConsole">
        <div class="debug-header">
            <div class="debug-title">
                <span>🔧 调试控制台</span>
            </div>
            <div class="debug-controls">
                <button class="debug-btn clear" id="debugClearBtn" title="清空日志">🗑️</button>
                <button class="debug-btn" id="debugMinimizeBtn" title="最小化">−</button>
                <button class="debug-btn" id="debugCloseBtn" title="关闭">✕</button>
            </div>
        </div>
        <div class="debug-content" id="debugContent">
            <div class="debug-log info">
                <div class="debug-timestamp">系统启动</div>
                <div class="debug-message">调试控制台已初始化，等待操作...</div>
            </div>
        </div>
    </div>

    
    <!-- =============================
         多背景系统 - 折叠式控制面板（左下角）
         说明：避免在原搜索/播放控制区堆叠控件
         ============================= -->
    <button id="bgToggleBtn" title="背景控制面板">🎨</button>

    <div id="bgPanel" role="dialog" aria-label="背景控制面板">
        <div class="bg-panel-header" id="bgPanelHeader">
            <div class="bg-panel-title">
                <span>🎨 背景控制</span>
                <span class="bg-badge" id="bgStatusBadge">默认</span>
            </div>
            <div class="bg-panel-actions">
                <button id="bgPanelMinBtn" title="最小化">—</button>
                <button id="bgPanelCloseBtn" title="关闭">✕</button>
            </div>
        </div>

        <div class="bg-panel-body">
            <div class="bg-row">
                <button class="bg-main-btn" id="bgSwitchBtn" title="循环切换背景：默认 → Pixi动态 → Mesh渐变">切换背景</button>
                <label class="bg-checkbox" title="开启后：切歌/换封面时，背景自动更新">
                    <input type="checkbox" id="bgFollowAlbum" checked>
                    跟随专辑封面
                </label>
            </div>

            <div class="bg-sep"></div>

            <div class="bg-controls" id="bgControlsMount">
                <div class="bg-hint">
                    当前背景无额外控制项。<br>
                    提示：切换到 Pixi / Mesh 背景后，这里会出现对应的完整控制面板。
                </div>
            </div>
        </div>
    </div>

    <audio id="audioPlayer" playsinline webkit-playsinline preload="metadata"></audio>

    <script>
        // ========== 调试控制台系统 ==========
        // 保持原有的调试控制台逻辑，但延迟初始化
        let debugConsole = null;
        
        function initDebugConsole() {
            if (document.getElementById('debugConsole') && !debugConsole) {
                class DebugConsole {
                    constructor() {
                        this.consoleElement = document.getElementById('debugConsole');
                        this.contentElement = document.getElementById('debugContent');
                        this.toggleBtn = document.getElementById('debugToggleBtn');
                        this.clearBtn = document.getElementById('debugClearBtn');
                        this.minimizeBtn = document.getElementById('debugMinimizeBtn');
                        this.closeBtn = document.getElementById('debugCloseBtn');
                        this.isExpanded = true;
                        this.isVisible = false;
                        this.logCount = 0;
                        this.maxLogs = 100;
                        
                        this.init();
                    }
                    
                    init() {
                        // 绑定事件
                        this.toggleBtn.addEventListener('click', () => this.toggleVisibility());
                        this.clearBtn.addEventListener('click', () => this.clearLogs());
                        this.minimizeBtn.addEventListener('click', () => this.toggleSize());
                        this.closeBtn.addEventListener('click', () => this.hide());
                        
                        // 初始状态
                        this.consoleElement.classList.add('expanded');
                        
                        this.log('系统', '调试控制台初始化完成', 'info');
                    }
                    
                    toggleVisibility() {
                        this.isVisible = !this.isVisible;
                        if (this.isVisible) {
                            this.show();
                        } else {
                            this.hide();
                        }
                    }
                    
                    show() {
                        this.consoleElement.classList.remove('hidden');
                        this.toggleBtn.classList.add('hidden');
                        this.isVisible = true;
                        this.log('系统', '调试控制台已打开', 'info');
                    }
                    
                    hide() {
                        this.consoleElement.classList.add('hidden');
                        this.toggleBtn.classList.remove('hidden');
                        this.isVisible = false;
                    }
                    
                    toggleSize() {
                        this.isExpanded = !this.isExpanded;
                        if (this.isExpanded) {
                            this.consoleElement.classList.remove('collapsed');
                            this.consoleElement.classList.add('expanded');
                            this.minimizeBtn.textContent = '−';
                            this.minimizeBtn.title = '最小化';
                        } else {
                            this.consoleElement.classList.remove('expanded');
                            this.consoleElement.classList.add('collapsed');
                            this.minimizeBtn.textContent = '□';
                            this.minimizeBtn.title = '最大化';
                        }
                    }
                    
                    clearLogs() {
                        this.contentElement.innerHTML = '';
                        this.logCount = 0;
                        this.log('系统', '日志已清空', 'info');
                    }
                    
                    log(category, message, type = 'info') {
                        this.logCount++;
                        
                        // 限制日志数量
                        if (this.logCount > this.maxLogs) {
                            const logs = this.contentElement.querySelectorAll('.debug-log');
                            if (logs.length > this.maxLogs) {
                                logs[0].remove();
                            }
                        }
                        
                        const timestamp = new Date().toLocaleTimeString('zh-CN', {
                            hour12: false,
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                        
                        const logElement = document.createElement('div');
                        logElement.className = `debug-log ${type}`;
                        
                        logElement.innerHTML = `
                            <div class="debug-timestamp">[${timestamp}] [${category}]</div>
                            <div class="debug-message">${this.escapeHtml(message)}</div>
                        `;
                        
                        this.contentElement.appendChild(logElement);
                        
                        // 性能优化：使用 RAF 延迟滚动，避免读写交错导致的强制回流
                        requestAnimationFrame(() => {
                            this.contentElement.scrollTop = this.contentElement.scrollHeight;
                        });
                    }
                    
                    error(category, message) {
                        this.log(category, message, 'error');
                    }
                    
                    warn(category, message) {
                        this.log(category, message, 'warning');
                    }
                    
                    info(category, message) {
                        this.log(category, message, 'info');
                    }
                    
                    success(category, message) {
                        this.log(category, message, 'success');
                    }
                    
                    api(category, message) {
                        this.log(category, message, 'api');
                    }
                    
                    escapeHtml(text) {
                        const div = document.createElement('div');
                        div.textContent = text;
                        return div.innerHTML;
                    }
                }
                
                debugConsole = new DebugConsole();
            }
        }

        // ========== 动态网格渐变系统 ==========
        const canvas = document.getElementById('gradientCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        
        let gradientPoints = [];
        let animationId = null;
        let lastTime = 0;
        let ANIMATION_SPEED_MULTIPLIER = 1.0; 
        
        // 默认配色方案
        const defaultPalette = [
            { r: 11,  g: 11,  b: 11  },   // #0B0B0B 深基色
            { r: 146, g: 30,  b: 88  },   // #921E58 霓虹玫紫
            { r: 25,  g: 137, b: 250 },   // #1989FA 霓虹蓝
            { r: 156, g: 39,  b: 176 }    // #9C27B0 霓虹紫
        ];

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // 初始化 6x6 网格点
        function initGradientPoints(colors = null) {
            gradientPoints = [];
            const cols = 6;
            const rows = 6;
            const width = canvas.width;
            const height = canvas.height;
            const cellW = width / cols;
            const cellH = height / rows;
            const palette = colors && colors.length > 0 ? colors : defaultPalette;

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const baseX = j * cellW + cellW / 2;
                    const baseY = i * cellH + cellH / 2;
                    
                    const colorIdx = (i * cols + j) % palette.length;
                    const initialColor = palette[colorIdx];

                    gradientPoints.push({
                        x: baseX,
                        y: baseY,
                        baseX: baseX,
                        baseY: baseY,
                        color: { ...initialColor },
                        targetColor: { ...initialColor },

                        rangeX: cellW * 1.5,
                        rangeY: cellH * 1.5,
                        phaseX: Math.random() * Math.PI * 2,
                        phaseY: Math.random() * Math.PI * 2,
                        speedX: (0.0001 + Math.random() * 0.0003) * (Math.random() > 0.5 ? 1 : -1),
                        speedY: (0.0001 + Math.random() * 0.0003) * (Math.random() > 0.5 ? 1 : -1),
                        
                        radiusBase: Math.max(width, height) * 0.35, 
                        radiusPhase: Math.random() * Math.PI * 2,
                        radiusSpeed: 0.0005 + Math.random() * 0.0005,
                        
                        phaseZ: Math.random() * Math.PI * 2,
                        speedZ: 0.001 + Math.random() * 0.0015
                    });
                }
            }
        }

        // 核心渲染循环
        function animate(time) {
            if (!lastTime) lastTime = time;
            const deltaTime = time - lastTime;
            lastTime = time;

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-over';

            gradientPoints.forEach(p => {
                const speed = ANIMATION_SPEED_MULTIPLIER;
                p.phaseX += p.speedX * deltaTime * speed;
                p.phaseY += p.speedY * deltaTime * speed;
                p.radiusPhase += p.radiusSpeed * deltaTime * speed;
                p.phaseZ += p.speedZ * deltaTime * speed;

                p.x = p.baseX + Math.sin(p.phaseX) * p.rangeX / 3 + Math.sin(p.phaseZ) * p.rangeX / 6;
                p.y = p.baseY + Math.cos(p.phaseY) * p.rangeY / 3 + Math.cos(p.phaseZ) * p.rangeY / 6;

                const ease = 0.015;
                p.color.r += (p.targetColor.r - p.color.r) * ease;
                p.color.g += (p.targetColor.g - p.color.g) * ease;
                p.color.b += (p.targetColor.b - p.color.b) * ease;

                const currentRadius = p.radiusBase + Math.sin(p.radiusPhase) * (p.radiusBase * 0.1);
                
                const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, currentRadius);
                
                const r = Math.round(p.color.r);
                const gVal = Math.round(p.color.g);
                const b = Math.round(p.color.b);
                
                g.addColorStop(0, `rgba(${r}, ${gVal}, ${b}, 0.8)`);
                g.addColorStop(0.3, `rgba(${r}, ${gVal}, ${b}, 0.5)`);
                g.addColorStop(1, `rgba(${r}, ${gVal}, ${b}, 0)`);

                ctx.fillStyle = g;
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
            });

            animationId = requestAnimationFrame(animate);
        }

        // ========== 完整版颜色量化算法（中位切分法 / K-means） ==========
        function extractMainColors(img) {
            try {
                if (debugConsole) debugConsole.log('颜色提取', '开始提取专辑封面主要颜色...', 'info');
                
                // 创建Canvas处理图像
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // 设置Canvas尺寸（适当缩小以提高性能）
                const maxSize = 200;
                let width = img.width;
                let height = img.height;
                
                if (width > maxSize || height > maxSize) {
                    const scale = maxSize / Math.max(width, height);
                    width = Math.floor(width * scale);
                    height = Math.floor(height * scale);
                }
                
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);
                
                // 获取图像数据
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                // 收集所有像素颜色
                const pixels = [];
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    // 忽略完全透明或接近透明的像素
                    if (data[i + 3] < 50) continue;
                    
                    pixels.push({ r, g, b });
                }
                
                if (pixels.length === 0) {
                    if (debugConsole) debugConsole.warn('颜色提取', '未提取到有效像素颜色，使用默认配色方案');
                    return defaultPalette;
                }
                
                if (debugConsole) debugConsole.log('颜色提取', `成功采集 ${pixels.length} 个像素点颜色`, 'success');
                

                // 根据选择的算法提取颜色
                const colorCount = 12; // 需要提取的颜色数量
                let colors = [];

                if (COLOR_EXTRACTION_ALGO === 'kmeans') {
                    // K-means聚类提取颜色
                    colors = kMeansQuantize(pixels, colorCount, 10);
                    if (debugConsole) debugConsole.log('颜色提取', `K-means 提取到 ${colors.length} 种主要颜色`, 'success');
                } else {
                    // 原算法：中位切分法提取颜色
                    const buckets = medianCut(pixels, colorCount);

                    // 计算每个bucket的平均颜色
                    colors = buckets.map(bucket => {
                        let r = 0, g = 0, b = 0;
                        const count = bucket.length;

                        for (let i = 0; i < count; i++) {
                            r += bucket[i].r;
                            g += bucket[i].g;
                            b += bucket[i].b;
                        }

                        return {
                            r: Math.round(r / count),
                            g: Math.round(g / count),
                            b: Math.round(b / count)
                        };
                    });

                    if (debugConsole) debugConsole.log('颜色提取', `中位切分法成功提取 ${colors.length} 种主要颜色`, 'success');
                }

                if (debugConsole) debugConsole.log('颜色提取', `提取的颜色: ${JSON.stringify(colors)}`, 'info');

                return colors;
            } catch (error) {
                if (debugConsole) debugConsole.error('颜色提取', `颜色提取过程出现异常: ${error.message}\n堆栈: ${error.stack}`);
                return defaultPalette;
            }
        }



// K-means聚类提取主要颜色
function kMeansQuantize(pixels, k = 12, maxIter = 10) {
    // 为性能控制：最多采样约8000个像素
    const maxSamples = 8000;
    let samples = pixels;
    if (pixels.length > maxSamples) {
        const stride = Math.ceil(pixels.length / maxSamples);
        samples = [];
        for (let i = 0; i < pixels.length; i += stride) {
            samples.push(pixels[i]);
        }
    }

    // 随机初始化聚类中心
    const centroids = [];
    for (let i = 0; i < k; i++) {
        const p = samples[Math.floor(Math.random() * samples.length)];
        centroids.push({ r: p.r, g: p.g, b: p.b });
    }

    const assignments = new Array(samples.length).fill(-1);
    let counts = new Array(k).fill(0);

    for (let iter = 0; iter < maxIter; iter++) {
        const sumR = new Array(k).fill(0);
        const sumG = new Array(k).fill(0);
        const sumB = new Array(k).fill(0);
        counts = new Array(k).fill(0);

        let changed = false;

        for (let i = 0; i < samples.length; i++) {
            const p = samples[i];
            let best = 0;
            let bestDist = Infinity;

            for (let c = 0; c < k; c++) {
                const dr = p.r - centroids[c].r;
                const dg = p.g - centroids[c].g;
                const db = p.b - centroids[c].b;
                const dist = dr * dr + dg * dg + db * db;
                if (dist < bestDist) {
                    bestDist = dist;
                    best = c;
                }
            }

            if (assignments[i] !== best) {
                changed = true;
                assignments[i] = best;
            }

            counts[best]++;
            sumR[best] += p.r;
            sumG[best] += p.g;
            sumB[best] += p.b;
        }

        // 更新聚类中心
        for (let c = 0; c < k; c++) {
            if (counts[c] > 0) {
                centroids[c].r = sumR[c] / counts[c];
                centroids[c].g = sumG[c] / counts[c];
                centroids[c].b = sumB[c] / counts[c];
            } else {
                // 空簇重新随机初始化
                const p = samples[Math.floor(Math.random() * samples.length)];
                centroids[c] = { r: p.r, g: p.g, b: p.b };
            }
        }

        if (!changed) break;
    }

    // 按簇大小排序（更“主色”优先）
    const items = centroids.map((c, idx) => ({
        r: Math.round(c.r),
        g: Math.round(c.g),
        b: Math.round(c.b),
        count: counts[idx] || 0
    })).sort((a, b) => b.count - a.count);

    return items.map(({ r, g, b }) => ({ r, g, b }));
}

        // 中位切分法实现
        function medianCut(pixels, targetColors) {
            // 初始化一个bucket包含所有像素
            let buckets = [pixels];
            
            // 持续切分直到达到目标颜色数量
            while (buckets.length < targetColors) {
                // 找到最大的bucket来切分
                let largestBucketIndex = 0;
                let largestBucketSize = 0;
                
                for (let i = 0; i < buckets.length; i++) {
                    if (buckets[i].length > largestBucketSize) {
                        largestBucketSize = buckets[i].length;
                        largestBucketIndex = i;
                    }
                }
                
                const bucketToSplit = buckets[largestBucketIndex];
                
                // 如果bucket太小，无法继续切分
                if (bucketToSplit.length < 2) {
                    break;
                }
                
                // 找到颜色范围最大的通道
                let rMin = 255, rMax = 0;
                let gMin = 255, gMax = 0;
                let bMin = 255, bMax = 0;
                
                for (let i = 0; i < bucketToSplit.length; i++) {
                    const pixel = bucketToSplit[i];
                    rMin = Math.min(rMin, pixel.r);
                    rMax = Math.max(rMax, pixel.r);
                    gMin = Math.min(gMin, pixel.g);
                    gMax = Math.max(gMax, pixel.g);
                    bMin = Math.min(bMin, pixel.b);
                    bMax = Math.max(bMax, pixel.b);
                }
                
                const rRange = rMax - rMin;
                const gRange = gMax - gMin;
                const bRange = bMax - bMin;
                
                // 确定切分通道
                let splitChannel;
                if (rRange >= gRange && rRange >= bRange) {
                    splitChannel = 'r';
                } else if (gRange >= rRange && gRange >= bRange) {
                    splitChannel = 'g';
                } else {
                    splitChannel = 'b';
                }
                
                // 按选定通道排序
                bucketToSplit.sort((a, b) => a[splitChannel] - b[splitChannel]);
                
                // 找到中位数
                const medianIndex = Math.floor(bucketToSplit.length / 2);
                
                // 切分bucket
                const bucket1 = bucketToSplit.slice(0, medianIndex);
                const bucket2 = bucketToSplit.slice(medianIndex);
                
                // 替换原bucket为两个新bucket
                buckets.splice(largestBucketIndex, 1, bucket1, bucket2);
            }
            
            return buckets;
        }

        // 从专辑封面提取主要颜色
        function updateGradientFromAlbum(imageUrl) {
            if (!imageUrl) {
                if (debugConsole) debugConsole.warn('渐变背景', '无专辑封面URL，使用默认颜色');
                gradientPoints.forEach((p, i) => {
                    const newColor = defaultPalette[i % defaultPalette.length];
                    p.targetColor = { ...newColor };
                });
                return;
            }
            
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                try {
                    if (debugConsole) debugConsole.log('渐变背景', '开始从专辑封面提取颜色...', 'info');
                    const colors = extractMainColors(img);
                    
                    // 确保我们有足够的颜色
                    let extendedColors = [];
                    while (extendedColors.length < 36) {
                        extendedColors = extendedColors.concat(colors);
                    }
                    
                    // 更新渐变点的目标颜色
                    gradientPoints.forEach((p, i) => {
                        const newColor = extendedColors[i];
                        if (newColor) {
                            p.targetColor = { ...newColor };
                        }
                    });
                    
                    if (debugConsole) debugConsole.success('渐变背景', '专辑封面颜色提取完成，渐变背景已更新');
                } catch (error) {
                    if (debugConsole) debugConsole.error('渐变背景', `专辑封面颜色提取失败: ${error.message}`);
                }
            };
            
            img.onerror = (e) => {
                if (debugConsole) debugConsole.error('渐变背景', `专辑封面图片加载失败: ${imageUrl}\n错误信息: ${e.message}`);
                // 加载失败使用默认色
                gradientPoints.forEach((p, i) => {
                    const newColor = defaultPalette[i % defaultPalette.length];
                    p.targetColor = { ...newColor };
                });
            };
            
            img.src = imageUrl;
        }

        function startGradientAnimation() {
            if (animationId) cancelAnimationFrame(animationId);
            resizeCanvas();
            initGradientPoints(); 
            animate(0);
            if (debugConsole) debugConsole.log('渐变背景', '动态渐变背景系统已启动', 'success');
        }

        // Fix: 暴露渐变动画相关函数和变量到全局作用域，供背景系统调用
        window.startGradientAnimation = startGradientAnimation;
        window.updateGradientFromAlbum = updateGradientFromAlbum;
        window.getGradientAnimationId = function() { return animationId; };
        window.setGradientAnimationId = function(val) { animationId = val; };
        window.cancelGradientAnimation = function() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        };

        // ========== 音乐播放器逻辑 ==========
        const searchInput = document.getElementById('searchInput');
        const apiSelect = document.getElementById('apiSelect'); // 新增：API选择器
        const algoToggleBtn = document.getElementById('algoToggleBtn'); // 新增：颜色算法切换按钮
        const sourceSelect = document.getElementById('sourceSelect');
        const searchBtn = document.getElementById('searchBtn');
        const albumArt = document.getElementById('albumArt');
        const albumArtPlaceholder = document.querySelector('.album-art-placeholder');
        const songTitle = document.getElementById('songTitle');
        const songArtist = document.getElementById('songArtist');
        const progressBar = document.getElementById('progressBar');
        const progress = document.getElementById('progress');
        const progressHandle = document.getElementById('progressHandle');
        const currentTime = document.getElementById('currentTime');
        const duration = document.getElementById('duration');
        const playBtn = document.getElementById('playBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const qualitySelect = document.getElementById('qualitySelect');
        const lyricsContainer = document.getElementById('lyricsContainer');
        const lyricsContent = document.getElementById('lyricsContent');
        const resultsContainer = document.getElementById('resultsContainer');
        const audioPlayer = document.getElementById('audioPlayer');

        const fullscreenLyricsBtn = document.getElementById('fullscreenLyricsBtn');
        const fullscreenLyricsOverlay = document.getElementById('fullscreenLyricsOverlay');
        const closeFullscreenBtn = document.getElementById('closeFullscreenBtn');
        const fullscreenAlbumArt = document.getElementById('fullscreenAlbumArt');
        const fullscreenSongTitle = document.getElementById('fullscreenSongTitle');
        const fullscreenSongArtist = document.getElementById('fullscreenSongArtist');
        const fullscreenLyricsLines = document.getElementById('fullscreenLyricsLines');
        const fullscreenProgressBar = document.getElementById('fullscreenProgressBar');
        const fullscreenProgress = document.getElementById('fullscreenProgress');
        const fullscreenPlayBtn = document.getElementById('fullscreenPlayBtn');
        const fullscreenPrevBtn = document.getElementById('fullscreenPrevBtn');
        const fullscreenNextBtn = document.getElementById('fullscreenNextBtn');
        
        const speedSlider = document.getElementById('speedSlider');

        let currentTrack = null;
        let searchResults = [];
        let requestTimestamps = [];
        let mergedLyricsData = null;
        let isDragging = false;
        let userScrolledLyrics = false;
        let currentAlbumUrl = null;

        // =========================================================
        // Fix: iOS / 全平台稳定性增强（触控事件 + 音频解锁 + AudioContext 恢复）
        // =========================================================
        window.__compatFix = window.__compatFix || {};
        window.__compatFix.flags = window.__compatFix.flags || {};
        window.__compatFix.flags.consoleShim = true; // Fix: console 垫片已加载（见 <head>）

        let __lastUserGestureAt = 0;
        let __pendingPlayAfterUnlock = false;
        let __audioCtx = null;
        let __audioCtxSource = null;
        let __audioUnlockAttempts = 0;

        function markUserGesture() {
            __lastUserGestureAt = Date.now();
            try { window.__compatFix.lastUserGestureAt = __lastUserGestureAt; } catch (_) {}
        }

        function getAudioContext() {
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if (!Ctx) return null;
            if (!__audioCtx) {
                try { __audioCtx = new Ctx(); } catch (_) { __audioCtx = null; }
            }
            return __audioCtx;
        }

        function ensureAudioContextRoute() {
            const ctx = getAudioContext();
            if (!ctx) return;
            if (__audioCtxSource) return;
            try {
                __audioCtxSource = ctx.createMediaElementSource(audioPlayer);
                __audioCtxSource.connect(ctx.destination);
            } catch (_) {
                // createMediaElementSource 可能因重复调用/浏览器限制而失败：忽略即可
            }
        }

        async function resumeAudioContext() {
            const ctx = getAudioContext();
            if (!ctx) {
                window.__compatFix.flags.audioContext = { supported: false };
                return false;
            }
            try {
                if (ctx.state === 'suspended') await ctx.resume();
            } catch (_) {}
            window.__compatFix.flags.audioContext = { supported: true, state: ctx.state };
            return ctx.state === 'running';
        }

        // Fix: 生成极小的静音 WAV，用于 iOS 首次手势“解锁”媒体播放
        function createSilentWavBlob(durationSec = 0.06, sampleRate = 44100) {
            const numSamples = Math.max(1, Math.floor(durationSec * sampleRate));
            const bytesPerSample = 2; // 16-bit
            const blockAlign = bytesPerSample * 1;
            const byteRate = sampleRate * blockAlign;
            const dataSize = numSamples * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            function writeString(offset, str) {
                for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
            }

            writeString(0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // PCM
            view.setUint16(22, 1, true); // channels
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, 16, true); // bits
            writeString(36, 'data');
            view.setUint32(40, dataSize, true);

            // samples are zero => silence
            return new Blob([buffer], { type: 'audio/wav' });
        }

        async function unlockIOSAudioOnce(reason = 'first-gesture') {
            // 最多尝试 2 次，避免极端情况下反复触发
            if (window.__compatFix.flags.audioUnlocked === true) return;
            if (__audioUnlockAttempts >= 2) return;
            __audioUnlockAttempts++;

            markUserGesture();
            // Fix: 移除AudioContext路由，因为跨域音频会被静音
            // try { ensureAudioContextRoute(); } catch (_) {}
            try { await resumeAudioContext(); } catch (_) {}

            // iOS 部分版本在异步 play 时会丢失手势上下文：先用“静音播放”解锁一次
            try {
                const unlockEl = new Audio();
                unlockEl.setAttribute('playsinline', '');
                unlockEl.setAttribute('webkit-playsinline', '');
                unlockEl.playsInline = true;
                unlockEl.muted = false;
                unlockEl.volume = 0;

                const url = URL.createObjectURL(createSilentWavBlob());
                unlockEl.src = url;

                const p = unlockEl.play();
                if (p && typeof p.then === 'function') await p;

                unlockEl.pause();
                unlockEl.src = '';
                URL.revokeObjectURL(url);

                window.__compatFix.flags.audioUnlocked = true;
            } catch (e) {
                // 解锁失败也不致命：后续由 safePlayAudio + 重新手势重试兜底
                window.__compatFix.flags.audioUnlocked = false;
            }
        }

        function armPendingPlayRetry() {
            if (armPendingPlayRetry._armed) return;
            armPendingPlayRetry._armed = true;

            const handler = async (e) => {
                armPendingPlayRetry._armed = false;
                markUserGesture();
                try { await unlockIOSAudioOnce('retry'); } catch (_) {}

                if (__pendingPlayAfterUnlock && audioPlayer && audioPlayer.src) {
                    __pendingPlayAfterUnlock = false;
                    await safePlayAudio('retry-after-gesture');
                }
            };

            // Fix: 用户手势触发（touchend 优先），同时兼容 mouse/click
            ['touchend','click','mousedown'].forEach((evt) => {
                document.addEventListener(evt, handler, { once: true, capture: true, passive: false });
            });
        }

        async function safePlayAudio(from = '') {
            // Fix: 移除AudioContext路由，因为跨域音频会被静音
            // try { ensureAudioContextRoute(); } catch (_) {}
            // try { await resumeAudioContext(); } catch (_) {}

            try {
                const p = audioPlayer.play();
                if (p && typeof p.then === 'function') await p;
                window.__compatFix.flags.lastPlayOK = true;
                window.__compatFix.flags.lastPlayError = null;
                return true;
            } catch (e) {
                window.__compatFix.flags.lastPlayOK = false;
                window.__compatFix.flags.lastPlayError = { name: e && e.name, message: e && e.message };

                // Fix: iOS / Safari 自动播放策略拦截时，不抛出未捕获异常，而是挂起等待下一次手势
                __pendingPlayAfterUnlock = true;
                armPendingPlayRetry();

                // 控制台/调试面板输出（不依赖 console.group/error）
                try {
                    if (debugConsole) debugConsole.warn('播放控制', `音频播放被浏览器策略阻止或失败: ${e && e.name ? e.name : 'Error'} - ${e && e.message ? e.message : ''}`);
                } catch (_) {}
                return false;
            }
        }

        // Fix: 首次用户交互时，尽早 resume AudioContext（iOS 必须）
        (function bindFirstUserGestureUnlock() {
            const once = () => { unlockIOSAudioOnce('first-gesture'); };
            document.addEventListener('touchend', once, { once: true, capture: true, passive: true });
            document.addEventListener('mousedown', once, { once: true, capture: true, passive: true });
            document.addEventListener('keydown', once, { once: true, capture: true, passive: true });
        })();

        // Fix: 关键按钮补充 touch/mouse 事件（不破坏原 click/onClick 逻辑）
        function bindUnifiedPress(el, handler, label) {
            if (!el || typeof handler !== 'function') return;
            let lastTouchTime = 0;

            try { el.dataset.compatBound = '1'; if (label) el.dataset.compatLabel = label; } catch (_) {}

            el.addEventListener('touchstart', () => { markUserGesture(); }, { passive: true });
            el.addEventListener('touchend', (e) => {
                lastTouchTime = Date.now();
                markUserGesture();
                try { unlockIOSAudioOnce('touchend'); } catch (_) {}
                try { if (e && e.cancelable) e.preventDefault(); } catch (_) {}
                try { handler(e); } catch (_) {}
            }, { passive: false });

            // mouse: 仅记录手势，保持原 click 行为不变
            el.addEventListener('mousedown', () => { markUserGesture(); }, { passive: true });
            el.addEventListener('mouseup', () => { markUserGesture(); }, { passive: true });

            // click: 若刚刚触发过 touchend，则抑制合成 click，避免双触发（尤其 iOS）
            el.addEventListener('click', (e) => {
                markUserGesture();
                try { unlockIOSAudioOnce('click'); } catch (_) {}

                if (Date.now() - lastTouchTime < 800) {
                    try {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                        e.stopPropagation();
                    } catch (_) {}
                }
            }, true);
        }

        // 暴露给自检
        window.__compatFix.bindUnifiedPress = bindUnifiedPress;

        
        // API配置 - 两套独立系统
        const API_CONFIG = {
            gdstudio: {
                name: '原API (GDStudio)',
                baseUrl: '/api.php',
                // 原API音质选项
                qualities: [
                    { value: '128', label: '标准品质 (128k)' },
                    { value: '192', label: '良好品质 (192k)' },
                    { value: '320', label: '高品质 (320k)' },
                    { value: '740', label: '无损品质 (740k)' },
                    { value: '999', label: '高解析度 (999k)' }
                ]
            },
            tunehub: {
                name: '备用API (TuneHub)',
                baseUrl: '/api/',
                // TuneHub API音质选项 - 与音乐下载.html完全一致
                qualities: [
                    { value: '128k', label: '标准品质 (128k)' },
                    { value: '320k', label: '高品质 (320k)' },
                    { value: 'flac', label: '无损品质 (FLAC)' },
                    { value: 'flac24bit', label: '高解析度 (24bit FLAC)' }
                ]
            }
        };

        // 更新音乐源选择选项
        function updateSourceOptions() {
            const api = apiSelect.value;
            const sourceOptions = sourceSelect.options;
            
            // 重置所有选项
            for (let i = 0; i < sourceOptions.length; i++) {
                sourceOptions[i].disabled = false;
                sourceOptions[i].style.display = '';
            }
            
            if (api === 'tunehub') {
                // TuneHub API支持的平台
                if (debugConsole) debugConsole.info('API切换', '切换到TuneHub API，更新平台选项');
                
                // 启用TuneHub支持的选项，禁用不支持的
                for (let i = 0; i < sourceOptions.length; i++) {
                    const option = sourceOptions[i];
                    const value = option.value;
                    
                    // TuneHub支持的平台：netease, kuwo, qq, aggregate
                    if (value === 'netease' || value === 'kuwo' || value === 'qq' || value === 'aggregate') {
                        option.disabled = false;
                        option.style.display = '';
                    } else {
                        option.disabled = true;
                        option.style.display = 'none';
                    }
                }
                
                // 设置默认值
                if (!['netease', 'kuwo', 'qq', 'aggregate'].includes(sourceSelect.value)) {
                    sourceSelect.value = 'netease';
                }
            } else {
                // 原API支持的平台
                if (debugConsole) debugConsole.info('API切换', '切换到原API，恢复平台选项');
                
                // 恢复所有选项
                for (let i = 0; i < sourceOptions.length; i++) {
                    const option = sourceOptions[i];
                    const value = option.value;
                    
                    // 原API支持的平台：kuwo, joox, netease
                    if (value === 'kuwo' || value === 'joox' || value === 'netease') {
                        option.disabled = false;
                        option.style.display = '';
                    } else {
                        option.disabled = true;
                        option.style.display = 'none';
                    }
                }
                
                // 设置默认值
                if (!['kuwo', 'joox', 'netease'].includes(sourceSelect.value)) {
                    sourceSelect.value = 'kuwo';
                }
            }
        }

        // 更新音质选项
        function updateQualityOptions() {
            const api = apiSelect.value;
            const apiConfig = API_CONFIG[api];
            const qualitySelect = document.getElementById('qualitySelect');
            
            // 清空现有选项
            qualitySelect.innerHTML = '';
            
            // 添加新选项
            apiConfig.qualities.forEach(quality => {
                const option = document.createElement('option');
                option.value = quality.value;
                option.textContent = quality.label;
                qualitySelect.appendChild(option);
            });
            
            if (debugConsole) debugConsole.info('音质选项', `已更新为 ${apiConfig.name} 的音质选项`);
        }

        // API选择器事件
        apiSelect.addEventListener('change', () => {
            if (debugConsole) debugConsole.info('API切换', `切换到: ${apiSelect.value} - ${API_CONFIG[apiSelect.value].name}`);
            updateSourceOptions();
            updateQualityOptions();
        });

        // 初始化时更新选项
        updateSourceOptions();
        updateQualityOptions();


// ========== 颜色提取算法切换（原：中位切分 / 新：K-means） ==========
let COLOR_EXTRACTION_ALGO = localStorage.getItem('colorExtractionAlgo') || 'medianCut'; // 'medianCut' | 'kmeans'

function updateAlgoToggleButton() {
    if (!algoToggleBtn) return;
    algoToggleBtn.textContent = COLOR_EXTRACTION_ALGO === 'kmeans' ? '算法：K-means' : '算法：原(中位切分)';
}

if (algoToggleBtn) {
    updateAlgoToggleButton();
    algoToggleBtn.addEventListener('click', () => {
        COLOR_EXTRACTION_ALGO = (COLOR_EXTRACTION_ALGO === 'kmeans') ? 'medianCut' : 'kmeans';
        localStorage.setItem('colorExtractionAlgo', COLOR_EXTRACTION_ALGO);
        updateAlgoToggleButton();
        if (debugConsole) debugConsole.info('颜色提取', `已切换颜色提取算法为: ${COLOR_EXTRACTION_ALGO === 'kmeans' ? 'K-means' : '原(中位切分)'}`);

        // 如果当前已有专辑封面，立即按新算法刷新背景
        if (currentAlbumUrl) {
            updateGradientFromAlbum(currentAlbumUrl);
        }
    });
}


        function checkRateLimit() {
            const now = Date.now();
            const fiveMinutesAgo = now - 5 * 60 * 1000;
            requestTimestamps = requestTimestamps.filter(timestamp => timestamp > fiveMinutesAgo);
            
            if (requestTimestamps.length >= 60) {
                const message = 'API请求频率过高，已超过限制（5分钟内最多60次请求）。请等待5分钟后再试。当前请求次数：' + requestTimestamps.length;
                if (debugConsole) debugConsole.error('API限制', message);
                return false;
            }
            
            requestTimestamps.push(now);
            if (debugConsole) debugConsole.info('API请求', `当前5分钟内API请求次数: ${requestTimestamps.length}/60`);
            return true;
        }

        // TuneHub API请求函数 - 完全按照音乐下载.html的方式
        async function tunehubRequest(params) {
            try {
                const apiConfig = API_CONFIG.tunehub;
                const url = new URL(apiConfig.baseUrl, location.origin);
                
                // 直接使用参数，不进行映射
                Object.keys(params).forEach(k => {
                    if (params[k] !== undefined && params[k] !== null) {
                        url.searchParams.append(k, params[k]);
                    }
                });
                
                const urlString = url.toString();
                if (debugConsole) debugConsole.api('TuneHub API请求', `发送请求: ${urlString}`);
                
                const response = await fetch(urlString);
                
                if (!response.ok) {
                    const errorMsg = `HTTP请求失败: 状态码 ${response.status} ${response.statusText}`;
                    if (debugConsole) debugConsole.error('TuneHub API请求', errorMsg);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // 音频URL请求返回文本
                if (params.type === 'url') {
                    const audioUrl = await response.text();
                    if (debugConsole) debugConsole.api('TuneHub API请求', `音频URL获取成功: ${audioUrl.substring(0, 100)}...`);
                    return { url: audioUrl };
                }
                
                // 其他请求返回JSON
                const data = await response.json();
                if (debugConsole) debugConsole.api('TuneHub API请求', `请求成功，返回数据`);
                return data;
            } catch (error) {
                const errorMsg = `TuneHub API请求异常: ${error.message}\n错误堆栈: ${error.stack}`;
                if (debugConsole) debugConsole.error('TuneHub API请求', errorMsg);
                return null;
            }
        }

        // 原API请求函数
        async function gdstudioRequest(params) {
            try {
                const apiConfig = API_CONFIG.gdstudio;
                const queryString = new URLSearchParams(params).toString();
                const url = `${apiConfig.baseUrl}?${queryString}`;
                
                if (debugConsole) debugConsole.api('原API请求', `发送请求: ${url}`);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    const errorMsg = `HTTP请求失败: 状态码 ${response.status} ${response.statusText}`;
                    if (debugConsole) debugConsole.error('原API请求', errorMsg);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                if (debugConsole) debugConsole.api('原API请求', `请求成功，返回数据`);
                return data;
            } catch (error) {
                const errorMsg = `原API请求异常: ${error.message}\n错误堆栈: ${error.stack}`;
                if (debugConsole) debugConsole.error('原API请求', errorMsg);
                return null;
            }
        }

        // 统一API请求函数
        async function apiRequest(params, apiType = null) {
            const api = apiType || apiSelect.value;
            
            if (!checkRateLimit()) {
                const errorMsg = 'API请求频率限制：5分钟内最多60次请求，当前已超限。';
                if (debugConsole) debugConsole.error('API限制', errorMsg);
                return null;
            }
            
            if (api === 'gdstudio') {
                return await gdstudioRequest(params);
            } else if (api === 'tunehub') {
                // 将原API参数转换为TuneHub参数
                let tunehubParams = {};
                
                if (params.types === 'search') {
                    // 处理聚合搜索
                    if (params.source === 'aggregate') {
                        tunehubParams = {
                            type: 'aggregateSearch',
                            keyword: params.name,
                            limit: params.count || 20
                        };
                    } else {
                        tunehubParams = {
                            source: params.source,
                            type: 'search',
                            keyword: params.name,
                            limit: params.count || 20,
                            page: params.pages || 1
                        };
                    }
                } else if (params.types === 'url') {
                    // 直接使用音乐下载.html中的方式
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'url',
                        br: params.br // 直接使用音质值，不映射
                    };
                } else if (params.types === 'pic') {
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'pic'
                    };
                } else if (params.types === 'lyric') {
                    tunehubParams = {
                        source: params.source,
                        id: params.id,
                        type: 'lrc'
                    };
                }
                
                return await tunehubRequest(tunehubParams);
            }
        }

        async function searchMusic(keyword, source = null) {
            if (!keyword.trim()) {
                const errorMsg = '搜索失败: 搜索关键词为空，请输入有效的歌曲名、歌手名或专辑名进行搜索。';
                if (debugConsole) debugConsole.error('搜索', errorMsg);
                
                const d = document.createElement('div');
                d.className = 'error';
                d.textContent = '请输入搜索关键词';
                resultsContainer.prepend(d);
                setTimeout(() => d.remove(), 4000);
                return;
            }
            
            const api = apiSelect.value;
            const selectedSource = source || sourceSelect.value;
            
            if (debugConsole) debugConsole.info('搜索', `开始搜索: "${keyword}" (API: ${api}, 源: ${selectedSource})`);
            resultsContainer.innerHTML = '<div class="loading">搜索中...</div>';
            
            let data;
            if (api === 'gdstudio') {
                // 原API搜索
                data = await apiRequest({
                    types: 'search',
                    source: selectedSource,
                    name: keyword,
                    count: 20,
                    pages: 1
                });
            } else if (api === 'tunehub') {
                // TuneHub API搜索
                data = await apiRequest({
                    types: 'search',
                    source: selectedSource,
                    name: keyword,
                    count: 20,
                    pages: 1
                });
            }
            
            if (data) {
                if (api === 'gdstudio' && Array.isArray(data) && data.length > 0) {
                    // 原API搜索结果 - 添加平台信息
                    searchResults = data.map(track => ({
                        ...track,
                        platform: selectedSource,
                        api: 'gdstudio'
                    }));
                    if (debugConsole) debugConsole.success('搜索', `搜索成功，找到 ${data.length} 个结果`);
                    displaySearchResults(searchResults, api);
                } else if (api === 'tunehub' && data.code === 200 && data.data) {
                    // TuneHub返回的数据格式
                    let tracks = [];
                    
                    if (selectedSource === 'aggregate') {
                        // 聚合搜索返回的数据格式
                        if (data.data.results && Array.isArray(data.data.results)) {
                            tracks = data.data.results.map(item => ({
                                id: item.id,
                                name: item.name,
                                artist: item.artist || '未知艺术家',
                                album: item.album || '未知专辑',
                                pic_id: item.id,
                                pic_url: item.pic,
                                lyric_id: item.id,
                                source: item.platform,
                                platform: item.platform,
                                api: 'tunehub'
                            }));
                        }
                    } else {
                        // 普通搜索返回的数据格式
                        if (data.data.results && Array.isArray(data.data.results)) {
                            tracks = data.data.results.map(item => ({
                                id: item.id,
                                name: item.name,
                                artist: item.artist || '未知艺术家',
                                album: item.album || '未知专辑',
                                pic_id: item.id,
                                pic_url: item.pic,
                                lyric_id: item.id,
                                source: selectedSource,
                                platform: selectedSource,
                                api: 'tunehub'
                            }));
                        }
                    }
                    
                    if (tracks.length > 0) {
                        searchResults = tracks;
                        if (debugConsole) debugConsole.success('搜索', `搜索成功，找到 ${tracks.length} 个结果`);
                        displaySearchResults(tracks, api);
                    } else {
                        if (debugConsole) debugConsole.warn('搜索', `未找到相关结果，关键词: "${keyword}"，API: ${api}，源: ${selectedSource}`);
                        resultsContainer.innerHTML = '<div class="loading">未找到结果</div>';
                    }
                } else {
                    if (debugConsole) debugConsole.warn('搜索', `未找到相关结果，关键词: "${keyword}"，API: ${api}，源: ${selectedSource}`);
                    resultsContainer.innerHTML = '<div class="loading">未找到结果</div>';
                }
            } else {
                if (debugConsole) debugConsole.warn('搜索', `API返回空数据，关键词: "${keyword}"，API: ${api}，源: ${selectedSource}`);
                resultsContainer.innerHTML = '<div class="loading">未找到结果</div>';
            }
        }

        // ---------- 搜索结果显示 ----------
        function displaySearchResults(results, api) {
            resultsContainer.innerHTML = '';
            
            if (results.length === 0) {
                resultsContainer.innerHTML = '<div class="loading">未找到结果</div>';
                return;
            }
            
            results.forEach((track) => {
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                if (currentTrack && currentTrack.id === track.id && currentTrack.api === track.api) {
                    resultItem.classList.add('active');
                }
                
                // 根据API构建专辑封面URL
                let albumArtUrl;
                if (api === 'gdstudio') {
                    albumArtUrl = track.pic_id ? 
                        `/api.php?types=pic&source=${track.source}&id=${track.pic_id}&size=150` : 
                        'data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2250%22%20height%3D%2250%22%3E%3Crect%20width%3D%22100%25%22%20height%3D%22100%25%22%20fill%3D%22%23333%22%2F%3E%3Ctext%20x%3D%2250%25%22%20y%3D%2258%25%22%20font-size%3D%2228%22%20text-anchor%3D%22middle%22%20fill%3D%22%23fff%22%20font-family%3D%22Arial%2C%20sans-serif%22%3E%E2%99%AA%3C%2Ftext%3E%3C%2Fsvg%3E';
                } else if (api === 'tunehub') {
                    // TuneHub: 优先使用pic_url，如果没有则用id构建
                    if (track.pic_url) {
                        albumArtUrl = track.pic_url;
                    } else if (track.pic_id) {
                        albumArtUrl = `/api/?type=pic&source=${track.source}&id=${track.pic_id}`;
                    } else {
                        albumArtUrl = 'data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2250%22%20height%3D%2250%22%3E%3Crect%20width%3D%22100%25%22%20height%3D%22100%25%22%20fill%3D%22%23333%22%2F%3E%3Ctext%20x%3D%2250%25%22%20y%3D%2258%25%22%20font-size%3D%2228%22%20text-anchor%3D%22middle%22%20fill%3D%22%23fff%22%20font-family%3D%22Arial%2C%20sans-serif%22%3E%E2%99%AA%3C%2Ftext%3E%3C%2Fsvg%3E';
                    }
                }

                // 获取平台显示名称
                let platformName = '';
                let platformClass = '';
                if (track.platform) {
                    platformName = track.platform.toUpperCase();
                    platformClass = track.platform;
                }

                resultItem.innerHTML = `
                    <img src="${albumArtUrl}" class="result-album" onerror="this.src='data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2250%22%20height%3D%2250%22%3E%3Crect%20width%3D%22100%25%22%20height%3D%22100%25%22%20fill%3D%22%23333%22%2F%3E%3Ctext%20x%3D%2250%25%22%20y%3D%2258%25%22%20font-size%3D%2228%22%20text-anchor%3D%22middle%22%20fill%3D%22%23fff%22%20font-family%3D%22Arial%2C%20sans-serif%22%3E%E2%99%AA%3C%2Ftext%3E%3C%2Fsvg%3E'">
                    <div class="result-info">
                        <div class="result-title">${track.name || '未知歌曲'}</div>
                        <div class="result-artist">${track.artist || '未知艺术家'}</div>
                        <div class="result-album-name">${track.album || '未知专辑'}</div>
                        <div class="result-platform-info">
                            <span class="platform-badge ${platformClass}">${platformName}</span>
                            <span class="api-select-label">${track.api === 'tunehub' ? '备用API' : '原API'}</span>
                        </div>
                    </div>
                `;
                
                resultItem.__trackData = track;

                // Fix: iOS 触控/鼠标事件双绑定（避免 click 延迟/丢失，同时防止 touch 后重复触发 click）
                let __riLastTouch = 0;
                const __onSelect = (evt) => {
                    try { markUserGesture(); } catch (_) {}
                    try { unlockIOSAudioOnce('select-track'); } catch (_) {}

                    if (debugConsole) debugConsole.info('播放控制', `点击播放歌曲: ${track.name} - ${track.artist} (API: ${track.api || api}, 平台: ${track.platform})`);
                    playTrack(track);
                    document.querySelectorAll('.result-item').forEach(item => item.classList.remove('active'));
                    resultItem.classList.add('active');
                };

                resultItem.addEventListener('touchstart', () => { try { markUserGesture(); } catch (_) {} }, { passive: true });
                // Fix: 移除touchend触发播放，避免误触，只保留click
                resultItem.addEventListener('touchend', (e) => {
                    __riLastTouch = Date.now();
                    try { markUserGesture(); } catch (_) {}
                    // 不再在touchend触发播放
                }, { passive: true });

                resultItem.addEventListener('mousedown', () => { try { markUserGesture(); } catch (_) {} }, { passive: true });
                resultItem.addEventListener('mouseup', () => { try { markUserGesture(); } catch (_) {} }, { passive: true });

                resultItem.addEventListener('click', (e) => {
                    // 使用click事件触发播放，更不容易误触
                    __onSelect(e);
                });
                
                resultsContainer.appendChild(resultItem);
            });
            
            if (debugConsole) debugConsole.success('搜索结果', `成功渲染 ${results.length} 个搜索结果`);
        }

        async function playTrack(track) {
            try {
                currentTrack = track;
                
                // Fix: 立即清空旧的封面URL，避免MediaSession显示上一首歌的封面
                currentAlbumUrl = '';
                
                if (debugConsole) debugConsole.info('播放控制', `开始播放歌曲: ${track.name} - ${track.artist} (ID: ${track.id}, API: ${track.api || apiSelect.value}, 平台: ${track.platform})`);
                
                songTitle.textContent = track.name || '未知歌曲';
                songArtist.textContent = `${track.artist || '未知艺术家'}`;
                fullscreenSongTitle.textContent = track.name || '未知歌曲';
                fullscreenSongArtist.textContent = track.artist || '未知艺术家';
                
                albumArt.style.display = 'none';
                albumArtPlaceholder.style.display = 'flex';
                
                // Fix: 立即更新MediaSession标题信息（先不带封面）
                updateMediaSession(track);
                
                // 更新 active 状态
                document.querySelectorAll('.result-item').forEach(item => {
                    if(item.__trackData && item.__trackData.id === track.id && item.__trackData.api === track.api) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
                
                lyricsContent.innerHTML = '<div class="loading">加载中...</div>';
                fullscreenLyricsLines.innerHTML = '<div class="loading">加载中...</div>';
                userScrolledLyrics = false;
                
                // 根据track的API获取音频URL
                const quality = qualitySelect.value;
                const apiToUse = track.api || apiSelect.value;
                
                if (debugConsole) debugConsole.info('播放控制', `请求音频URL，音质: ${quality}, API: ${apiToUse}, 平台: ${track.platform}`);
                
                let urlData;
                if (apiToUse === 'tunehub') {
                    // TuneHub API - 使用音乐下载.html中的方式
                    const apiConfig = API_CONFIG.tunehub;
                    // 直接构建URL，与音乐下载.html相同
                    const url = new URL(apiConfig.baseUrl, location.origin);
                    url.searchParams.append('source', track.platform || track.source || sourceSelect.value);
                    url.searchParams.append('id', track.id);
                    url.searchParams.append('type', 'url');
                    url.searchParams.append('br', quality);
                    
                    const urlString = url.toString();
                    if (debugConsole) debugConsole.success('播放控制', `TuneHub音频URL: ${urlString}`);
                    
                    // 直接设置音频源，不通过API请求
                    urlData = { url: urlString };
                } else {
                    // 原API
                    urlData = await apiRequest({
                        types: 'url',
                        source: track.platform || track.source || sourceSelect.value,
                        id: track.id,
                        br: quality
                    });
                }
                
                if (urlData && urlData.url) {
                    if (debugConsole) debugConsole.success('播放控制', `成功获取音频URL: ${urlData.url.substring(0, 100)}...`);
                    
                    audioPlayer.src = urlData.url;

                    // Fix: iOS/Safari 在异步获取 URL 后可能丢失用户手势上下文，导致 play() 被拦截
                    const __played = await safePlayAudio('playTrack');
                    if (__played) {
                        playBtn.innerHTML = '⏸';
                        fullscreenPlayBtn.innerHTML = '⏸';
                        if (debugConsole) debugConsole.success('播放控制', '音频播放开始');
                    } else {
                        // 保持按钮为“可播放”状态，等待下一次用户手势触发重试
                        playBtn.innerHTML = '▶';
                        fullscreenPlayBtn.innerHTML = '▶';
                        if (debugConsole) debugConsole.warn('播放控制', '音频已就绪，但需要用户再次点击播放以解锁（iOS策略）');
                    }
// 加载专辑封面
                    if (track.pic_url) {
                        // 直接使用搜索时得到的图片URL
                        if (debugConsole) debugConsole.info('专辑封面', `使用搜索结果中的专辑封面URL: ${track.pic_url}`);
                        currentAlbumUrl = track.pic_url;
                        albumArt.src = __wrapKuwoIfNeeded(track.pic_url);
                        albumArt.style.display = 'block';
                        albumArtPlaceholder.style.display = 'none';
                        fullscreenAlbumArt.src = __wrapKuwoIfNeeded(track.pic_url);
                        
                        // 使用颜色量化算法提取主要颜色并更新背景
                        updateGradientFromAlbum(track.pic_url);
                        
                        // Fix: 封面URL已获取，立即更新MediaSession
                        updateMediaSession(track);
                    } else if (track.pic_id) {
                        if (debugConsole) debugConsole.info('专辑封面', `开始加载专辑封面，图片ID: ${track.pic_id}, API: ${apiToUse}`);
                        loadAlbumCover(track, apiToUse);
                    }
                    
                    // 加载歌词
                    if (track.lyric_id || track.id) {
                        const lyricId = track.lyric_id || track.id;
                        if (debugConsole) debugConsole.info('歌词', `开始加载歌词，歌词ID: ${lyricId}, API: ${apiToUse}`);
                        loadLyrics(track, apiToUse);
                    }
                } else {
                    const errorMsg = `无法播放此歌曲，可能没有对应的音质或链接失效。\n歌曲ID: ${track.id}\n音质: ${quality}\nAPI: ${apiToUse}\n平台: ${track.platform}`;
                    if (debugConsole) debugConsole.error('播放控制', errorMsg);
                }
            } catch (error) {
                const errorMsg = `播放歌曲过程中出现异常: ${error.message}\n错误堆栈: ${error.stack}`;
                if (debugConsole) debugConsole.error('播放控制', errorMsg);
            }
        }

        // ---------- 浏览器/iOS锁屏专辑封面部分 ----------
        function updateMediaSession(track) {
            if ('mediaSession' in navigator) {
                try {
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: track.name || '未知歌曲',
                        artist: track.artist || '未知艺术家',
                        album: track.album || '未知专辑',
                        artwork: currentAlbumUrl ? [
                            { src: currentAlbumUrl, sizes: '256x256', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '384x384', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '512x512', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '768x768', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '1024x1024', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '1536x1536', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '2048x2048', type: 'image/jpeg' },
                            { src: currentAlbumUrl, sizes: '3000x3000', type: 'image/jpeg' }
                        ] : []
                    });
                    
                    navigator.mediaSession.setActionHandler('play', async () => {
                        // Fix: iOS/Safari 媒体会话 play 走统一安全播放逻辑
                        const ok = await safePlayAudio('mediaSession-play');
                        if (ok) {
                            playBtn.innerHTML = '⏸';
                            fullscreenPlayBtn.innerHTML = '⏸';
                        } else {
                            playBtn.innerHTML = '▶';
                            fullscreenPlayBtn.innerHTML = '▶';
                        }
                    });
                    
                    navigator.mediaSession.setActionHandler('pause', () => {
                        audioPlayer.pause();
                        playBtn.innerHTML = '▶';
                        fullscreenPlayBtn.innerHTML = '▶';
                    });
                    
                    navigator.mediaSession.setActionHandler('previoustrack', () => {
                        prevBtn.click();
                    });
                    
                    navigator.mediaSession.setActionHandler('nexttrack', () => {
                        nextBtn.click();
                    });
                    
                    if (debugConsole) debugConsole.success('媒体会话', '浏览器/iOS锁屏媒体会话已更新');
                } catch (error) {
                    if (debugConsole) debugConsole.error('媒体会话', `更新媒体会话失败: ${error.message}`);
                }
            }
        }

        async function loadAlbumCover(track, api) {
            if (!track.pic_id) {
                if (debugConsole) debugConsole.warn('专辑封面', '无专辑封面ID，跳过封面加载');
                return;
            }
            
            if (debugConsole) debugConsole.info('专辑封面', `请求专辑封面，图片ID: ${track.pic_id}, API: ${api}`);
            
            let picData;
            if (api === 'tunehub') {
                // TuneHub API - 直接构建URL
                const apiConfig = API_CONFIG.tunehub;
                const url = new URL(apiConfig.baseUrl, location.origin);
                url.searchParams.append('source', track.platform || track.source || sourceSelect.value);
                url.searchParams.append('id', track.pic_id);
                url.searchParams.append('type', 'pic');
                
                picData = { url: url.toString() };
            } else {
                // 原API
                let sizeParam = '3000';
                if (track.platform === 'joox' || track.source === 'joox') {
                    sizeParam = '';
                    if (debugConsole) debugConsole.info('专辑封面', 'JOOX音乐源，使用原始尺寸');
                }
                
                picData = await apiRequest({
                    types: 'pic',
                    source: track.platform || track.source || sourceSelect.value,
                    id: track.pic_id,
                    size: sizeParam
                });
            }
            
            if (picData && picData.url) {
                currentAlbumUrl = picData.url;
                if (debugConsole) debugConsole.success('专辑封面', `成功加载专辑封面: ${picData.url}`);
                
                albumArt.src = __wrapKuwoIfNeeded(picData.url);
                albumArt.style.display = 'block';
                albumArtPlaceholder.style.display = 'none';
                fullscreenAlbumArt.src = __wrapKuwoIfNeeded(picData.url);
                
                // 使用颜色量化算法提取主要颜色并更新背景
                updateGradientFromAlbum(picData.url);
                
                // Fix: 更新mediaSession的artwork，使用currentTrack获取信息
                if ('mediaSession' in navigator && currentTrack) {
                    try {
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: currentTrack.name || '未知歌曲',
                            artist: currentTrack.artist || '未知艺术家',
                            album: currentTrack.album || '未知专辑',
                            artwork: [
                                { src: picData.url, sizes: '256x256', type: 'image/jpeg' },
                                { src: picData.url, sizes: '384x384', type: 'image/jpeg' },
                                { src: picData.url, sizes: '512x512', type: 'image/jpeg' },
                                { src: picData.url, sizes: '768x768', type: 'image/jpeg' },
                                { src: picData.url, sizes: '1024x1024', type: 'image/jpeg' },
                                { src: picData.url, sizes: '1536x1536', type: 'image/jpeg' },
                                { src: picData.url, sizes: '2048x2048', type: 'image/jpeg' },
                                { src: picData.url, sizes: '3000x3000', type: 'image/jpeg' }
                            ]
                        });
                        if (debugConsole) debugConsole.info('媒体会话', '专辑封面已更新到媒体会话');
                    } catch (error) {
                        if (debugConsole) debugConsole.error('媒体会话', `更新专辑封面到媒体会话失败: ${error.message}`);
                    }
                }
                
                albumArt.onerror = () => {
                    const errorMsg = `专辑封面图片加载失败: ${picData.url}`;
                    if (debugConsole) debugConsole.error('专辑封面', errorMsg);
                    albumArt.style.display = 'none';
                    albumArtPlaceholder.style.display = 'flex';
                };
            } else {
                if (debugConsole) debugConsole.error('专辑封面', `无法获取专辑封面数据，图片ID: ${track.pic_id}`);
            }
        }

        // ---------- 歌词解析 ----------
        function parseLRC(lrcText) {
            const lines = [];
            if (!lrcText) return lines;
            
            const lrcLines = lrcText.split('\n');
            
            lrcLines.forEach(line => {
                const timeMatch = line.match(/\[(\d+):(\d+)\.(\d+)\]/);
                if (timeMatch) {
                    const min = parseInt(timeMatch[1]);
                    const sec = parseInt(timeMatch[2]);
                    const ms = parseInt(timeMatch[3]) * 10;
                    let text = line.replace(/\[.*?\]/g, '').trim();

                    let words = [];
                    const wordMatch = text.matchAll(/\(([^)]+?)<(\d+:\d+:\d+)>\)/g);
                    let hasWordTiming = false;

                    for (const match of wordMatch) {
                        const wordText = match[1];
                        const wordTimeStr = match[2].split(':');
                        const wordTime = parseInt(wordTimeStr[0])*60 + parseInt(wordTimeStr[1]) + parseInt(wordTimeStr[2])/1000;
                        words.push({ text: wordText, time: wordTime });
                        hasWordTiming = true;
                    }

                    if (hasWordTiming) {
                         text = words.map(w => w.text).join('');
                    }

                    if (text) {
                        lines.push({
                            time: min * 60 + sec + ms/1000,
                            text: text,
                            words: hasWordTiming ? words : null
                        });
                    }
                }
            });
            return lines;
        }

        async function loadLyrics(track, api) {
            try {
                const lyricId = track.lyric_id || track.id;
                
                if (debugConsole) debugConsole.info('歌词', `开始请求歌词数据，歌词ID: ${lyricId}, API: ${api}`);
                
                let lyricData;
                if (api === 'tunehub') {
                    // TuneHub API - 直接构建URL
                    const apiConfig = API_CONFIG.tunehub;
                    const url = new URL(apiConfig.baseUrl, location.origin);
                    url.searchParams.append('source', track.platform || track.source || sourceSelect.value);
                    url.searchParams.append('id', lyricId);
                    url.searchParams.append('type', 'lrc');
                    
                    const response = await fetch(url.toString());
                    if (response.ok) {
                        const text = await response.text();
                        lyricData = { lyric: text };
                    }
                } else {
                    // 原API
                    lyricData = await apiRequest({
                        types: 'lyric',
                        source: track.platform || track.source || sourceSelect.value,
                        id: lyricId
                    });
                }
                
                mergedLyricsData = null;
                
                if (!lyricData || (!lyricData.lyric && !lyricData.tlyric)) {
                    if (debugConsole) debugConsole.warn('歌词', `未找到歌词数据，歌词ID: ${lyricId}`);
                    const noLyric = '<div class="loading">暂无歌词</div>';
                    lyricsContent.innerHTML = noLyric;
                    fullscreenLyricsLines.innerHTML = noLyric;
                    return;
                }
                
                if (debugConsole) debugConsole.info('歌词', `成功获取歌词数据，原始歌词长度: ${lyricData.lyric ? lyricData.lyric.length : 0}，翻译歌词长度: ${lyricData.tlyric ? lyricData.tlyric.length : 0}`);
                
                const originalLines = parseLRC(lyricData.lyric);
                const translationLines = parseLRC(lyricData.tlyric);
                
                // 合并并排序歌词
                const combinedLines = originalLines.map(o => {
                    const t = translationLines.find(t => t.time === o.time);
                    return {
                        time: o.time,
                        original: o.text,
                        translation: t ? t.text : null,
                        words: o.words
                    };
                }).sort((a, b) => a.time - b.time);

                mergedLyricsData = combinedLines;
                if (debugConsole) debugConsole.success('歌词', `歌词解析完成，共 ${combinedLines.length} 行歌词`);
                displayMergedLyrics(combinedLines);
            } catch (error) {
                const errorMsg = `歌词加载失败: ${error.message}\n歌词ID: ${track.lyric_id || track.id}\n错误堆栈: ${error.stack}`;
                if (debugConsole) debugConsole.error('歌词', errorMsg);
            }
        }

        function displayMergedLyrics(lines) {
            try {
                lyricsContent.innerHTML = '';
                fullscreenLyricsLines.innerHTML = '';
                
                // 性能优化：歌词更新时清除缓存
                if (typeof invalidateLyricsCache === 'function') {
                    invalidateLyricsCache();
                }
                
                if (lines.length === 0) {
                    if (debugConsole) debugConsole.warn('歌词', '歌词数据为空，无歌词可显示');
                    const noLyric = '<div class="loading">暂无歌词</div>';
                    lyricsContent.innerHTML = noLyric;
                    fullscreenLyricsLines.innerHTML = noLyric;
                    return;
                }

                const fragMini = document.createDocumentFragment();
                const fragFull = document.createDocumentFragment();
                
                lines.forEach(l => {
                    const createLineHtml = (text, isOriginal = true, isFullscreen = false) => {
                        if (l.words && isOriginal) {
                            return l.words.map(w => 
                                `<span class="word-highlight" data-word-time="${w.time}">${w.text}</span>`
                            ).join('');
                        }
                        return text;
                    };

                    // Mini Player Rendering
                    const div = document.createElement('div');
                    div.className = 'lyric-line';
                    div.dataset.time = l.time;
                    div.innerHTML = `
                        <span class="original-text">${createLineHtml(l.original, true, false)}</span>
                        ${l.translation ? `<span class="translation-text">${l.translation}</span>` : ''}
                    `;
                    div.onclick = () => {
                        audioPlayer.currentTime = l.time;
                        userScrolledLyrics = false; // 点击歌词后重置滚动状态
                        if (debugConsole) debugConsole.info('歌词', `点击歌词跳转到: ${l.time} 秒`);
                    };
                    fragMini.appendChild(div);
                    
                    // Fullscreen Player Rendering
                    const divFull = document.createElement('div');
                    divFull.className = 'fullscreen-lyric-line';
                    divFull.dataset.time = l.time;
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'fullscreen-line-wrapper';
                    
                    const original = document.createElement('span');
                    original.className = 'fullscreen-original-text';
                    original.innerHTML = createLineHtml(l.original, true, true);
                    wrapper.appendChild(original);

                    if (l.translation) {
                        const translation = document.createElement('span');
                        translation.className = 'fullscreen-translation-text';
                        translation.textContent = l.translation;
                        wrapper.appendChild(translation);
                    }

                    divFull.appendChild(wrapper);
                    divFull.onclick = () => {
                        audioPlayer.currentTime = l.time;
                        userScrolledLyrics = false;
                    };
                    fragFull.appendChild(divFull);
                });
                
                lyricsContent.appendChild(fragMini);
                fullscreenLyricsLines.appendChild(fragFull);
                
                if (debugConsole) debugConsole.success('歌词渲染', `成功渲染 ${lines.length} 行歌词`);
            } catch (error) {
                const errorMsg = `歌词渲染失败: ${error.message}\n错误堆栈: ${error.stack}`;
                if (debugConsole) debugConsole.error('歌词渲染', errorMsg);
            }
        }

        // 性能优化：歌词高亮缓存和节流
        let _cachedMiniLines = null;
        let _cachedFullLines = null;
        let _lastActiveIdx = -1;
        let _scrollThrottleTimer = null;
        const SCROLL_THROTTLE_MS = 150; // 滚动节流间隔
        
        // 缓存歌词行DOM引用（歌词更新时需要调用 invalidateLyricsCache）
        function invalidateLyricsCache() {
            _cachedMiniLines = null;
            _cachedFullLines = null;
            _lastActiveIdx = -1;
        }
        
        function highlightCurrentLyric(time) {
            if (!mergedLyricsData) return;
            
            // 二分查找优化（替代线性遍历）
            let activeIdx = -1;
            let lo = 0, hi = mergedLyricsData.length - 1;
            while (lo <= hi) {
                const mid = (lo + hi) >>> 1;
                if (mergedLyricsData[mid].time <= time + 0.2) {
                    activeIdx = mid;
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
            
            if (activeIdx === -1) return;
            
            // 如果索引没变，跳过DOM操作
            if (activeIdx === _lastActiveIdx) return;
            
            // 缓存DOM查询结果（只在首次或缓存失效时查询）
            if (!_cachedMiniLines) {
                _cachedMiniLines = lyricsContent.querySelectorAll('.lyric-line');
            }
            if (!_cachedFullLines) {
                _cachedFullLines = fullscreenLyricsLines.querySelectorAll('.fullscreen-lyric-line');
            }
            
            // 只移除上一个激活行的类（而非遍历所有）
            if (_lastActiveIdx >= 0) {
                if (_cachedMiniLines[_lastActiveIdx]) {
                    _cachedMiniLines[_lastActiveIdx].classList.remove('active');
                }
                if (_cachedFullLines[_lastActiveIdx]) {
                    _cachedFullLines[_lastActiveIdx].classList.remove('active');
                }
            }
            
            _lastActiveIdx = activeIdx;
            
            // --- Sync Mini Player ---
            if (_cachedMiniLines[activeIdx]) {
                _cachedMiniLines[activeIdx].classList.add('active');
                // 节流 scrollIntoView，避免频繁触发回流
                if (!userScrolledLyrics && !_scrollThrottleTimer) {
                    _scrollThrottleTimer = setTimeout(() => {
                        _scrollThrottleTimer = null;
                        if (_cachedMiniLines[_lastActiveIdx]) {
                            _cachedMiniLines[_lastActiveIdx].scrollIntoView({behavior: 'smooth', block: 'center'});
                        }
                    }, SCROLL_THROTTLE_MS);
                }
            }
            
            // --- Sync Fullscreen Player ---
            if (_cachedFullLines[activeIdx]) {
                _cachedFullLines[activeIdx].classList.add('active');
                // 全屏歌词也节流滚动
                if (!_scrollThrottleTimer) {
                    _scrollThrottleTimer = setTimeout(() => {
                        _scrollThrottleTimer = null;
                        if (_cachedFullLines[_lastActiveIdx]) {
                            _cachedFullLines[_lastActiveIdx].scrollIntoView({behavior: 'smooth', block: 'center'});
                        }
                    }, SCROLL_THROTTLE_MS);
                }
            }
            
            // 逐词高亮逻辑 - 优化：使用 CSS 类而非内联样式
            if (mergedLyricsData[activeIdx] && mergedLyricsData[activeIdx].words) {
                 const targetLine = _cachedMiniLines[activeIdx] || _cachedFullLines[activeIdx];
                 if (targetLine) {
                     const currentLineWords = targetLine.querySelectorAll('.word-highlight');
                     currentLineWords.forEach(wordSpan => {
                         const wordTime = parseFloat(wordSpan.dataset.wordTime || wordSpan.dataset['word-time'] || 0);
                         // 使用 classList 代替直接修改 style
                         if (wordTime <= time) {
                             wordSpan.classList.add('word-active');
                         } else {
                             wordSpan.classList.remove('word-active');
                         }
                     });
                 }
            }
        }

        function formatTime(s) {
            if(isNaN(s) || s < 0) return '0:00';
            const m = Math.floor(s/60);
            const se = Math.floor(s%60);
            return `${m}:${se<10?'0':''}${se}`;
        }

        // --- Event Listeners ---
        
        searchBtn.onclick = () => {
            if (debugConsole) debugConsole.info('搜索', `手动触发搜索: "${searchInput.value}" (API: ${apiSelect.value}, 源: ${sourceSelect.value})`);
            searchMusic(searchInput.value, sourceSelect.value);
        };
        
        searchInput.onkeypress = (e) => {
            if (e.key === 'Enter') {
                if (debugConsole) debugConsole.info('搜索', `回车键触发搜索: "${searchInput.value}"`);
                searchBtn.click();
            }
        };
        
        // 播放控制
        const togglePlay = async () => {
            try { markUserGesture(); } catch (_) {}
            if(audioPlayer.paused) {
                if(audioPlayer.src) {
                    if (debugConsole) debugConsole.info('播放控制', '点击播放按钮，开始播放');
                    // Fix: iOS 需用户手势解锁 + AudioContext resume
                    await safePlayAudio('togglePlay');
                } else {
                    if (debugConsole) debugConsole.warn('播放控制', '点击播放按钮，但无音频源可播放');
                }
            } else {
                if (debugConsole) debugConsole.info('播放控制', '点击暂停按钮，暂停播放');
                audioPlayer.pause();
            }
        };
        
        playBtn.onclick = togglePlay;
        fullscreenPlayBtn.onclick = togglePlay;

        // Fix: iOS 关键播放按钮补充 touch/mouse 事件（不删除原 click/onclick）
        bindUnifiedPress(playBtn, togglePlay, 'playBtn');
        bindUnifiedPress(fullscreenPlayBtn, togglePlay, 'fullscreenPlayBtn');

        
        audioPlayer.onplay = () => {
            playBtn.innerHTML = '⏸';
            fullscreenPlayBtn.innerHTML = '⏸';
            if (debugConsole) debugConsole.info('播放状态', '音频开始播放');
        };
        
        audioPlayer.onpause = () => {
            playBtn.innerHTML = '▶';
            fullscreenPlayBtn.innerHTML = '▶';
            if (debugConsole) debugConsole.info('播放状态', '音频暂停播放');
        };
        
        // Fix: 添加音频错误处理
        audioPlayer.onerror = (e) => {
            const error = audioPlayer.error;
            let errorMsg = '未知错误';
            if (error) {
                switch(error.code) {
                    case 1: errorMsg = 'MEDIA_ERR_ABORTED - 用户中止'; break;
                    case 2: errorMsg = 'MEDIA_ERR_NETWORK - 网络错误'; break;
                    case 3: errorMsg = 'MEDIA_ERR_DECODE - 解码错误'; break;
                    case 4: errorMsg = 'MEDIA_ERR_SRC_NOT_SUPPORTED - 格式不支持'; break;
                }
            }
            if (debugConsole) debugConsole.error('音频错误', `播放出错: ${errorMsg}`);
        };
        
        prevBtn.onclick = fullscreenPrevBtn.onclick = () => {
            if (debugConsole) debugConsole.info('播放控制', '点击上一曲按钮');
            if(currentTrack && searchResults.length) {
                const idx = searchResults.findIndex(t => t.id === currentTrack.id && t.api === currentTrack.api);
                const prevIdx = (idx - 1 + searchResults.length) % searchResults.length;
                const prev = searchResults[prevIdx];
                playTrack(prev);
            } else {
                if (debugConsole) debugConsole.warn('播放控制', '无法切换到上一曲：当前无歌曲或搜索结果');
            }
        };

        // Fix: iOS 上一曲按钮补充 touch/mouse 事件（不删除原 click/onclick）
        bindUnifiedPress(prevBtn, prevBtn.onclick, 'prevBtn');
        bindUnifiedPress(fullscreenPrevBtn, fullscreenPrevBtn.onclick, 'fullscreenPrevBtn');
        
        nextBtn.onclick = fullscreenNextBtn.onclick = () => {
            if (debugConsole) debugConsole.info('播放控制', '点击下一曲按钮');
            if(currentTrack && searchResults.length) {
                const idx = searchResults.findIndex(t => t.id === currentTrack.id && t.api === currentTrack.api);
                const nextIdx = (idx + 1) % searchResults.length;
                const next = searchResults[nextIdx];
                playTrack(next);
            } else {
                if (debugConsole) debugConsole.warn('播放控制', '无法切换到下一曲：当前无歌曲或搜索结果');
            }
        };

        // Fix: iOS 下一曲按钮补充 touch/mouse 事件（不删除原 click/onclick）
        bindUnifiedPress(nextBtn, nextBtn.onclick, 'nextBtn');
        bindUnifiedPress(fullscreenNextBtn, fullscreenNextBtn.onclick, 'fullscreenNextBtn');

        // UI Toggles
        fullscreenLyricsBtn.onclick = () => {
            if (debugConsole) debugConsole.info('界面', '打开全屏歌词模式');
            fullscreenLyricsOverlay.classList.add('active');
        };
        
        closeFullscreenBtn.onclick = () => {
            if (debugConsole) debugConsole.info('界面', '关闭全屏歌词模式');
            fullscreenLyricsOverlay.classList.remove('active');
        };
        
        // Progress Bars - 优化：使用 RAF 节流，避免强制回流
        let _rafPending = false;
        let _lastPct = -1;
        let _lastFormattedTime = '';
        
        audioPlayer.ontimeupdate = () => {
            if (_rafPending) return; // 节流：如果上一帧还没处理完，跳过
            _rafPending = true;
            
            requestAnimationFrame(() => {
                _rafPending = false;
                if (!audioPlayer.duration) return;
                
                const pct = (audioPlayer.currentTime / audioPlayer.duration) * 100;
                const formattedTime = formatTime(audioPlayer.currentTime);
                
                // 只在值变化时更新 DOM，减少不必要的样式写入
                if (Math.abs(pct - _lastPct) > 0.1) {
                    _lastPct = pct;
                    // 批量写入样式，使用 transform 代替 width（不触发回流）
                    progress.style.transform = `scaleX(${pct / 100})`;
                    progress.style.transformOrigin = 'left';
                    // progressHandle 仍使用 left（已有 will-change 优化）
                    progressHandle.style.left = pct + '%';
                    fullscreenProgress.style.transform = `scaleX(${pct / 100})`;
                    fullscreenProgress.style.transformOrigin = 'left';
                }
                
                if (formattedTime !== _lastFormattedTime) {
                    _lastFormattedTime = formattedTime;
                    currentTime.textContent = formattedTime;
                }
                
                highlightCurrentLyric(audioPlayer.currentTime);
            });
        };
        
        audioPlayer.onloadedmetadata = () => {
            if (debugConsole) debugConsole.info('音频信息', `音频元数据加载完成，时长: ${formatTime(audioPlayer.duration)}`);
            duration.textContent = formatTime(audioPlayer.duration);
        };
        
        audioPlayer.onended = () => {
            if (debugConsole) debugConsole.info('播放状态', '音频播放结束，自动播放下一曲');
            nextBtn.click();
        };

        // Seek - 性能优化：缓存进度条位置信息
        let _progressBarRect = null;
        let _fullscreenProgressBarRect = null;
        
        const seek = (e, bar) => {
            if(!audioPlayer.duration) return;
            
            // 缓存getBoundingClientRect结果，拖动开始时获取一次即可
            let rect;
            if (bar === progressBar) {
                if (!_progressBarRect) _progressBarRect = bar.getBoundingClientRect();
                rect = _progressBarRect;
            } else {
                if (!_fullscreenProgressBarRect) _fullscreenProgressBarRect = bar.getBoundingClientRect();
                rect = _fullscreenProgressBarRect;
            }
            
            const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : undefined);
            if (clientX === undefined) return;

            const p = Math.max(0, Math.min(1, (clientX - rect.left)/rect.width));
            const newTime = p * audioPlayer.duration;
            audioPlayer.currentTime = newTime;
            if (debugConsole) debugConsole.info('播放控制', `跳转到: ${formatTime(newTime)} (${(p * 100).toFixed(0)}%)`);
        };
        
        // 拖动结束时清除缓存
        const clearSeekCache = () => {
            _progressBarRect = null;
            _fullscreenProgressBarRect = null;
        };

        // Mini player seek
        progressBar.onmousedown = (e) => { 
            isDragging = true;
            clearSeekCache(); // 开始拖动时刷新缓存
            if (debugConsole) debugConsole.info('播放控制', '开始拖动进度条');
            seek(e, progressBar); 
        };
        
        progressBar.ontouchstart = (e) => { 
            isDragging = true;
            clearSeekCache();
            if (debugConsole) debugConsole.info('播放控制', '触摸开始拖动进度条');
            seek(e, progressBar); 
        };

        document.addEventListener('mousemove', (e) => { 
            if (isDragging) {
                seek(e, progressBar);
            }
        });
        
        document.addEventListener('touchmove', (e) => { 
            if (isDragging) {
                seek(e, progressBar);
            }
        });
        
        document.addEventListener('mouseup', () => { 
            if (isDragging) {
                if (debugConsole) debugConsole.info('播放控制', '结束拖动进度条');
                isDragging = false; 
            }
        });
        
        document.addEventListener('touchend', () => { 
            if (isDragging) {
                if (debugConsole) debugConsole.info('播放控制', '触摸结束拖动进度条');
                isDragging = false; 
            }
        });
        
        // Fullscreen seek
        fullscreenProgressBar.onclick = (e) => {
            if (debugConsole) debugConsole.info('播放控制', '点击全屏进度条');
            seek(e, fullscreenProgressBar);
        };
        
        fullscreenProgressBar.ontouchstart = (e) => {
            if (debugConsole) debugConsole.info('播放控制', '触摸全屏进度条');
            seek(e, fullscreenProgressBar);
        };

        // Mesh Gradient Speed Control
        speedSlider.oninput = (e) => {
            ANIMATION_SPEED_MULTIPLIER = parseFloat(e.target.value);
            if (debugConsole) debugConsole.info('渐变背景', `渐变动画速度调整为: ${ANIMATION_SPEED_MULTIPLIER.toFixed(2)}x`);
        };

        // 修复歌词滚动 - 移除自动返回逻辑
        lyricsContainer.addEventListener('wheel', (e) => {
            userScrolledLyrics = true;
            if (debugConsole) debugConsole.info('歌词滚动', '用户手动滚动歌词，禁用自动滚动');
        });
        
        lyricsContainer.addEventListener('touchstart', () => {
            userScrolledLyrics = true;
            if (debugConsole) debugConsole.info('歌词滚动', '用户触摸歌词，禁用自动滚动');
        });

        // Resize
        window.onresize = () => {
            if (debugConsole) debugConsole.info('窗口', '窗口大小改变，重新调整Canvas');
            resizeCanvas();
        };
        
        // Init
        audioPlayer.volume = 0.7;
        
        // 页面加载完成后初始化所有组件
        window.onload = () => {
            // 初始化调试控制台
            initDebugConsole();
            
            // 启动渐变动画
            startGradientAnimation();
            
            if (debugConsole) debugConsole.info('系统', '页面加载完成，准备自动搜索演示');
            
            // 延迟执行自动搜索，确保所有组件已初始化
            setTimeout(() => {
                if (debugConsole) debugConsole.info('搜索', '自动搜索演示：周杰伦 (原API - 酷我音乐)');
                searchMusic('周杰伦', 'kuwo');
            }, 800);
        };

        // 错误捕获
        window.onerror = function(message, source, lineno, colno, error) {
            const errorMsg = `全局JavaScript错误: ${message}\n来源: ${source}\n行号: ${lineno}, 列号: ${colno}\n错误堆栈: ${error ? error.stack : '无堆栈信息'}`;
            if (debugConsole) debugConsole.error('JavaScript错误', errorMsg);
            return false;
        };

        // 未处理的Promise错误
        window.addEventListener('unhandledrejection', function(event) {
            const errorMsg = `未处理的Promise拒绝: ${event.reason}\nPromise: ${event.promise}\n错误堆栈: ${event.reason ? event.reason.stack : '无堆栈信息'}`;
            if (debugConsole) debugConsole.error('Promise错误', errorMsg);
        });

    </script>

<script>

/* =========================================================
   多背景系统（集成版）- 关键说明
   1) 本脚本在不改动原播放器核心逻辑的前提下，新增：
      - Pixi 动态背景（纯 WebGL，无外部库）
      - Mesh 渐变背景（纯 WebGL，无外部库）
      - 背景管理器 + 资源释放 + 折叠式控制面板
   2) 背景更新策略：
      - 默认跟随专辑封面（MutationObserver 监听 #albumArt.src 变化）
      - 若用户在背景控制面板中手动选择文件/URL，将自动关闭“跟随专辑封面”
   ========================================================= */

(() => {
    // 1. 初始化日志（按需求必须包含）
    console.log("=== 音乐播放器背景系统启动 ===");
    console.log("时间:", new Date().toISOString());
    console.log("可用功能:", ["取色器", "播放控制", "KMeans", "API联动"]);

    // 3. 错误监控（按需求必须包含）
    window.addEventListener('error', (e) => {
        // Fix: 兼容 iOS / PWA 场景 console.error 缺失导致的崩溃
        try { console.error("[全局错误]", {
            消息: e.message,
            文件: e.filename,
            行号: e.lineno,
            列号: e.colno,
            时间: new Date().toLocaleTimeString()
        }); } catch (e) { try { console.log("[全局错误]", {
            消息: e.message,
            文件: e.filename,
            行号: e.lineno,
            列号: e.colno,
            时间: new Date().toLocaleTimeString()
        }); } catch (_) {} }
    });

    window.addEventListener('unhandledrejection', (event) => {
        // Fix: 兼容 iOS / PWA 场景 console.error 缺失导致的崩溃
        try { console.error("[未处理Promise拒绝]", {
            原因: event.reason,
            时间: new Date().toLocaleTimeString()
        }); } catch (e) { try { console.log("[未处理Promise拒绝]", {
            原因: event.reason,
            时间: new Date().toLocaleTimeString()
        }); } catch (_) {} }
    });

    // 4. 状态报告函数（按需求必须提供）
    window.reportPlayerStatus = function() {
        const bgType = window.__bgManager ? window.__bgManager.getCurrentType() : '未知';
        const hasAlbumArt = !!document.getElementById('albumArt')?.src;
        const audio = document.getElementById('audioPlayer');
        const audioReady = !!audio;
        const hasKMeans = typeof window.kMeansQuantize === 'function' || typeof kMeansQuantize === 'function';
        const hasApi = typeof window.apiRequest === 'function' || typeof apiRequest === 'function';

        console.table({
            "功能模块": ["背景系统", "取色器", "音频播放", "API连接", "KMeans算法"],
            "运行状态": [
                bgType ? `✓正常（${bgType}）` : "✗异常",
                hasAlbumArt ? "✓正常" : "⚠未加载封面",
                audioReady ? "✓正常" : "✗缺少audio元素",
                hasApi ? "✓正常" : "⚠未检测到apiRequest（可能在闭包内）",
                hasKMeans ? "✓正常" : "⚠未检测到kMeansQuantize（可能在闭包内）"
            ],
            "最后检测": [new Date().toLocaleTimeString()]
        });
    };

    // =========================================================
    // 小工具：安全日志（同时输出到控制台与原调试控制台）
    // =========================================================
    function dcInfo(tag, msg) {
        try {
            // 注意：原文件中 debugConsole 是 global lexical（let），这里直接访问
            if (typeof debugConsole !== 'undefined' && debugConsole && typeof debugConsole.info === 'function') {
                debugConsole.info(tag, msg);
            }
        } catch (_) {}
    }
    function dcWarn(tag, msg) {
        try {
            if (typeof debugConsole !== 'undefined' && debugConsole && typeof debugConsole.warn === 'function') {
                debugConsole.warn(tag, msg);
            }
        } catch (_) {}
    }
    function dcError(tag, msg) {
        try {
            if (typeof debugConsole !== 'undefined' && debugConsole && typeof debugConsole.error === 'function') {
                debugConsole.error(tag, msg);
            }
        } catch (_) {}
    }

    // =========================================================
    // 默认背景封装（复用原播放器渐变背景）
    // =========================================================
    class DefaultBackgroundSystem {
        constructor() {
            this.type = 'default';
            this.canvas = null;
        }

        init() {
            console.log("[默认背景] 初始化/恢复...");
            dcInfo('背景系统', '默认背景：初始化/恢复');
            this.canvas = document.getElementById('gradientCanvas');
            if (this.canvas) this.canvas.style.display = 'block';
            const host = document.getElementById('bgHost');
            if (host) host.style.display = 'none';

            // Fix: 使用 window 暴露的函数来启动渐变动画
            try {
                if (typeof window.startGradientAnimation === 'function') {
                    window.startGradientAnimation();
                    console.log("[默认背景] 通过 window.startGradientAnimation 启动成功");
                } else {
                    console.warn("[默认背景] window.startGradientAnimation 不可用");
                }
            } catch (e) {
                console.warn("[默认背景] 启动失败:", e);
            }
            return '';
        }

        destroy() {
            console.log("[默认背景] 停止动画...");
            dcInfo('背景系统', '默认背景：停止动画');
            // Fix: 使用 window 暴露的函数来取消动画
            try {
                if (typeof window.cancelGradientAnimation === 'function') {
                    window.cancelGradientAnimation();
                    console.log("[默认背景] 通过 window.cancelGradientAnimation 停止成功");
                }
            } catch (e) {
                console.warn("[默认背景] 停止失败:", e);
            }
            if (this.canvas) this.canvas.style.display = 'none';
        }

        async updateFromAlbum(url) {
            // Fix: 使用 window 暴露的函数来更新专辑封面颜色
            try {
                if (typeof window.updateGradientFromAlbum === 'function' && url) {
                    window.updateGradientFromAlbum(url);
                }
            } catch (e) {
                console.warn("[默认背景] updateFromAlbum 异常:", e);
            }
        }

        getControlsHTML() {
            return '';
        }

        bindControls() {}
    }

    // =========================================================
    // === Pixi背景完整封装 ===
    // （以下核心渲染逻辑完整复制自 pixi-dynamic-background 2.html，
    //  仅对 resize/RAF 增加可释放能力，并加入 destroy() 做资源清理）
    // =========================================================
    class PixiBackgroundSystem {
        constructor() {
            // 包含pixi-dynamic-background 2.html的所有变量和函数（完整复制）
            // ============================================
            // 配置 - 修改这里可以更换默认图片
            // ============================================
            this.DEFAULT_IMAGE_URL = 'https://imge.kugou.com/stdmusic/orig/20150718/20150718214459760936.jpg';
            // ============================================

            // =============== WebGL 动态背景渲染器 ===============
            // 完全不依赖外部库，纯WebGL实现 - 直接从html-music-main项目抄过来的逻辑

            const vertexShaderSource = `
                attribute vec2 a_position;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                    v_texCoord = a_texCoord;
                }
            `;

            // Kawase模糊 - 从pixi-filters的KawaseBlurFilter抄过来
            const kawaseBlurFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                uniform vec2 u_resolution;
                uniform float u_offset;

                void main() {
                    vec2 texelSize = 1.0 / u_resolution;
                    vec2 uv = v_texCoord;

                    vec4 color = texture2D(u_texture, uv) * 0.2;
                    color += texture2D(u_texture, uv + vec2(-u_offset - 0.5, -u_offset - 0.5) * texelSize) * 0.2;
                    color += texture2D(u_texture, uv + vec2( u_offset + 0.5, -u_offset - 0.5) * texelSize) * 0.2;
                    color += texture2D(u_texture, uv + vec2(-u_offset - 0.5,  u_offset + 0.5) * texelSize) * 0.2;
                    color += texture2D(u_texture, uv + vec2( u_offset + 0.5,  u_offset + 0.5) * texelSize) * 0.2;

                    gl_FragColor = color;
                }
            `;

            // 扭曲效果 - 从pixi-filters的TwistFilter抄过来
            const twistFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                uniform vec2 u_center;
                uniform float u_radius;
                uniform float u_angle;
                uniform vec2 u_resolution;

                void main() {
                    vec2 coord = v_texCoord - u_center;

                    float aspect = u_resolution.x / u_resolution.y;
                    coord.x *= aspect;

                    float dist = length(coord);

                    if (dist < u_radius) {
                        float percent = (u_radius - dist) / u_radius;
                        float theta = percent * percent * u_angle;
                        float s = sin(theta);
                        float c = cos(theta);
                        coord = vec2(
                            coord.x * c - coord.y * s,
                            coord.x * s + coord.y * c
                        );
                    }

                    coord.x /= aspect;
                    vec2 uv = coord + u_center;

                    gl_FragColor = texture2D(u_texture, uv);
                }
            `;

            // 饱和度调整 - 从pixi-filters的AdjustmentFilter抄过来
            const saturationFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                uniform float u_saturation;

                void main() {
                    vec4 color = texture2D(u_texture, v_texCoord);
                    float gray = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
                    color.rgb = mix(vec3(gray), color.rgb, u_saturation);
                    gl_FragColor = color;
                }
            `;

            // 合成着色器 - 将多个精灵叠加渲染
            const compositeFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                uniform vec2 u_position;
                uniform float u_rotation;
                uniform float u_scale;
                uniform vec2 u_resolution;

                void main() {
                    vec2 uv = v_texCoord;
                    vec2 center = u_position;
                    vec2 coord = uv - center;

                    float aspect = u_resolution.x / u_resolution.y;
                    coord.x *= aspect;

                    float s = sin(u_rotation);
                    float c = cos(u_rotation);
                    coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);
                    coord /= u_scale;
                    coord.x /= aspect;

                    uv = coord + vec2(0.5);

                    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                        gl_FragColor = vec4(0.0);
                    } else {
                        gl_FragColor = texture2D(u_texture, uv);
                    }
                }
            `;

            const copyFragmentShader = `
                precision highp float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                void main() {
                    gl_FragColor = texture2D(u_texture, v_texCoord);
                }
            `;

            // 从LyricsScene.ts抄过来的精灵配置
            const self = this;
            this.LyricsScene = class LyricsScene {
                constructor(container) {
                    this.container = container;
                    this.paused = false;
                    this._destroyed = false;
                    this._rafId = null;
                    this._onResize = null;

                    // 精灵配置 - 直接从LyricsScene.ts抄过来
                    this.sprites = [
                        { x: 0.5, y: 0.5, rotation: 0, scale: 1.25, rotSpeed: 0.003 },
                        { x: 0.4, y: 0.4, rotation: 0, scale: 0.8, rotSpeed: -0.008 },
                        { x: 0.5, y: 0.5, rotation: 0, scale: 0.5, rotSpeed: -0.006, orbit: true, orbitRadius: 0.25, orbitMult: 0.75 },
                        { x: 0.5, y: 0.5, rotation: 0, scale: 0.25, rotSpeed: 0.004, orbit: true, orbitRadius: 0.25, orbitOffset: 0.05, orbitMult: 0.75 }
                    ];

                    // 滤镜设置 - 直接从LyricsScene.ts抄过来的blur配置
                    this.filters = {
                        twist: true,
                        blur: [false, false, false, false, false],
                        saturation: true
                    };
                    // KawaseBlurFilter的配置：[blur, quality]
                    // new KawaseBlurFilter(5, 1), new KawaseBlurFilter(10, 1), new KawaseBlurFilter(20, 2), new KawaseBlurFilter(40, 2), new KawaseBlurFilter(80, 2)
                    this.blurConfigs = [
                        { blur: 5, quality: 1 },
                        { blur: 10, quality: 1 },
                        { blur: 20, quality: 2 },
                        { blur: 40, quality: 2 },
                        { blur: 80, quality: 2 }
                    ];

                    this.initWebGL();
                    this.createShaders();
                    this.createBuffers();
                    this.createFramebuffers();

                    // ★ 为了可销毁，保存 resize handler（原文件为匿名函数，这里只做等价增强）
                    this._onResize = () => this.resize();
                    window.addEventListener('resize', this._onResize);
                    this.animate();
                }

                initWebGL() {
                    this.canvas = document.createElement('canvas');
                    this.canvas.width = this.container.clientWidth;
                    this.canvas.height = this.container.clientHeight;
                    this.container.appendChild(this.canvas);

                    this.gl = this.canvas.getContext('webgl', { 
                        alpha: false,
                        premultipliedAlpha: false,
                        preserveDrawingBuffer: false,
                        powerPreference: 'low-power'
                    });

                    if (!this.gl) throw new Error('WebGL not supported');

                    this.gl.enable(this.gl.BLEND);
                    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                }

                createShader(type, source) {
                    const gl = this.gl;
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        // Fix: 兼容 iOS / PWA 场景 console.error 缺失导致的崩溃
                        try { console.error('Shader error:', gl.getShaderInfoLog(shader)); } catch (e) { try { console.log('Shader error:', gl.getShaderInfoLog(shader)); } catch (_) {} }
                        return null;
                    }
                    // 记录 shader 便于 destroy
                    if (!this._shaders) this._shaders = [];
                    this._shaders.push(shader);
                    return shader;
                }

                createProgram(vertexSource, fragmentSource) {
                    const gl = this.gl;
                    const program = gl.createProgram();
                    const vs = this.createShader(gl.VERTEX_SHADER, vertexSource);
                    const fs = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);
                    gl.attachShader(program, vs);
                    gl.attachShader(program, fs);
                    gl.linkProgram(program);
                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                        // Fix: 兼容 iOS / PWA 场景 console.error 缺失导致的崩溃
                        try { console.error('Program error:', gl.getProgramInfoLog(program)); } catch (e) { try { console.log('Program error:', gl.getProgramInfoLog(program)); } catch (_) {} }
                        return null;
                    }
                    if (!this._programs) this._programs = [];
                    this._programs.push(program);
                    return program;
                }

                createShaders() {
                    this.copyProgram = this.createProgram(vertexShaderSource, copyFragmentShader);
                    this.compositeProgram = this.createProgram(vertexShaderSource, compositeFragmentShader);
                    this.twistProgram = this.createProgram(vertexShaderSource, twistFragmentShader);
                    this.blurProgram = this.createProgram(vertexShaderSource, kawaseBlurFragmentShader);
                    this.saturationProgram = this.createProgram(vertexShaderSource, saturationFragmentShader);
                }

                createBuffers() {
                    const gl = this.gl;
                    const positions = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
                    const texCoords = new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]);

                    this.positionBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

                    this.texCoordBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
                }

                createFramebuffers() {
                    const gl = this.gl;
                    const w = this.canvas.width;
                    const h = this.canvas.height;

                    if (this.framebuffers) {
                        this.framebuffers.forEach(fb => gl.deleteFramebuffer(fb));
                        this.fbTextures.forEach(tex => gl.deleteTexture(tex));
                    }

                    this.framebuffers = [];
                    this.fbTextures = [];

                    for (let i = 0; i < 3; i++) {
                        const fb = gl.createFramebuffer();
                        const tex = gl.createTexture();

                        gl.bindTexture(gl.TEXTURE_2D, tex);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);

                        this.framebuffers.push(fb);
                        this.fbTextures.push(tex);
                    }
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }

                // 纹理保护：防止 WebGL 读写冲突（Feedback loop）
                // - 若某个纹理既作为 framebuffer 的附着纹理，又仍绑定在任意 texture unit 上，某些驱动会直接报错。
                // - 这里在进入每个 pass 前，主动把“输出纹理”从常用的 texture unit 上解绑，确保读写彻底解耦。
                detachTextureFromUnits(texture) {
                    const gl = this.gl;
                    if (!gl || !texture) return;

                    // WebGL 不提供枚举全部绑定状态的高效 API，这里对前 8 个 unit 做保护即可（足够覆盖本场景）。
                    const maxUnits = Math.min(8, gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS) || 8);
                    for (let u = 0; u < maxUnits; u++) {
                        gl.activeTexture(gl.TEXTURE0 + u);
                        const bound = gl.getParameter(gl.TEXTURE_BINDING_2D);
                        if (bound === texture) gl.bindTexture(gl.TEXTURE_2D, null);
                    }
                    gl.activeTexture(gl.TEXTURE0);
                }

                setupProgram(program) {
                    const gl = this.gl;
                    gl.useProgram(program);

                    const posLoc = gl.getAttribLocation(program, 'a_position');
                    const texLoc = gl.getAttribLocation(program, 'a_texCoord');

                    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                    gl.enableVertexAttribArray(texLoc);
                    gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
                }

                async loadImage(source) {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        img.onload = () => { this.uploadTexture(img); resolve(); };
                        img.onerror = () => { this.createFallbackTexture(); resolve(); };

                        if (source instanceof File) {
                            const reader = new FileReader();
                            reader.onload = (e) => { img.src = e.target.result; };
                            reader.readAsDataURL(source);
                        } else {
                            img.src = source;
                        }
                    });
                }
                createFallbackTexture() {
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = 512;
                    const ctx = canvas.getContext('2d');

                    // Deep Nebula（Apple Music 风格深色流光）：黑底 + 霓虹彩斑 + 轻微星尘
                    ctx.fillStyle = '#0B0B0B';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // 轻微暗角，让画面更“深”
                    const vignette = ctx.createRadialGradient(256, 256, 40, 256, 256, 420);
                    vignette.addColorStop(0, 'rgba(11,11,11,0)');
                    vignette.addColorStop(1, 'rgba(0,0,0,0.85)');
                    ctx.fillStyle = vignette;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    const neon = ['#921E58', '#1989FA', '#9C27B0', '#00E5FF', '#FF2EC4'];
                    const hexToRgb = (hex) => {
                        const h = (hex || '#000000').replace('#', '');
                        const n = parseInt(h.length === 3 ? h.split('').map(ch => ch + ch).join('') : h, 16);
                        return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
                    };
                    const rand = (a, b) => a + Math.random() * (b - a);

                    // 彩斑（带 alpha 与 blur/glow）
                    ctx.globalCompositeOperation = 'lighter';
                    for (let i = 0; i < 18; i++) {
                        const color = neon[i % neon.length];
                        const rgb = hexToRgb(color);
                        const x = rand(-40, 552);
                        const y = rand(-40, 552);
                        const r = rand(70, 220);

                        ctx.globalAlpha = rand(0.08, 0.22);
                        ctx.shadowBlur = r * 0.55;
                        ctx.shadowColor = `rgba(${rgb.r},${rgb.g},${rgb.b},0.9)`;

                        const g = ctx.createRadialGradient(x, y, 0, x, y, r);
                        g.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0.75)`);
                        g.addColorStop(0.45, `rgba(${rgb.r},${rgb.g},${rgb.b},0.22)`);
                        g.addColorStop(1, 'rgba(0,0,0,0)');

                        ctx.fillStyle = g;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // 轻微流光线条（更像“液态玻璃”的动势底纹）
                    ctx.globalAlpha = 0.12;
                    ctx.shadowBlur = 18;
                    ctx.shadowColor = 'rgba(25,137,250,0.8)';
                    for (let i = 0; i < 8; i++) {
                        const y = rand(40, 472);
                        const h = rand(6, 16);
                        const rgb = hexToRgb(neon[(i + 1) % neon.length]);
                        const g = ctx.createLinearGradient(0, y, 512, y + h);
                        g.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
                        g.addColorStop(0.5, `rgba(${rgb.r},${rgb.g},${rgb.b},0.55)`);
                        g.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
                        ctx.fillStyle = g;
                        ctx.fillRect(0, y, 512, h);
                    }

                    // 星尘
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.shadowBlur = 0;
                    for (let i = 0; i < 140; i++) {
                        const x = Math.random() * 512;
                        const y = Math.random() * 512;
                        const s = Math.random() < 0.92 ? 1 : 2;
                        ctx.globalAlpha = rand(0.05, 0.14);
                        ctx.fillStyle = 'rgba(255,255,255,1)';
                        ctx.fillRect(x, y, s, s);
                    }

                    // 收尾复位
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                    ctx.globalCompositeOperation = 'source-over';

                    this.uploadTexture(canvas);
                }

                uploadTexture(source) {
                    const gl = this.gl;
                    if (this.imageTexture) gl.deleteTexture(this.imageTexture);

                    this.imageTexture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, this.imageTexture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                }

                renderSprites() {
                    const gl = this.gl;
                    const w = this.canvas.width, h = this.canvas.height;

                    // 将渲染到 framebuffer，并将清屏颜色设置为完全透明，避免出现黑色背景
                    // 纹理保护：确保输出纹理（fbTextures[0]）未绑定到任何 texture unit
                    this.detachTextureFromUnits(this.fbTextures[0]);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[0]);
                    gl.viewport(0, 0, w, h);
                    // 使用透明的清除色，以便通过混合看到下方背景
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);

                    if (!this.imageTexture) return;

                    this.setupProgram(this.compositeProgram);
                    gl.uniform2f(gl.getUniformLocation(this.compositeProgram, 'u_resolution'), w, h);

                    // 根据画布的宽高比调整精灵的缩放，确保在任何屏幕尺寸下没有黑边
                    const aspectRatio = Math.max(w, h) / Math.min(w, h);
                    const baseScales = [1.25, 0.8, 0.5, 0.25];
                    for (let idx = 0; idx < this.sprites.length; idx++) {
                        const sprite = this.sprites[idx];
                        sprite.scale = baseScales[idx] * aspectRatio;
                        gl.bindTexture(gl.TEXTURE_2D, this.imageTexture);
                        gl.uniform2f(gl.getUniformLocation(this.compositeProgram, 'u_position'), sprite.x, sprite.y);
                        gl.uniform1f(gl.getUniformLocation(this.compositeProgram, 'u_rotation'), sprite.rotation);
                        gl.uniform1f(gl.getUniformLocation(this.compositeProgram, 'u_scale'), sprite.scale);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                    }
                }
                applyTwist(inputIdx, outputFb) {
                    const gl = this.gl;
                    const w = this.canvas.width, h = this.canvas.height;

                    // 纹理保护：避免采样与写入同一纹理（Feedback loop formed between Framebuffer and active Texture）
                    let outputIdx = outputFb === this.framebuffers[1] ? 1 : 2;
                    if (inputIdx === outputIdx) {
                        outputIdx = outputIdx === 1 ? 2 : 1;
                        outputFb = this.framebuffers[outputIdx];
                    }
                    this.detachTextureFromUnits(this.fbTextures[outputIdx]);

                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFb);
                    gl.clearColor(0, 0, 0, 0);
                    gl.viewport(0, 0, w, h);
                    gl.clear(gl.COLOR_BUFFER_BIT);

                    this.setupProgram(this.twistProgram);
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, this.fbTextures[inputIdx]);

                    // TwistFilter配置 - 从LyricsScene.ts抄过来: angle: -3.25, radius: 900
                    gl.uniform2f(gl.getUniformLocation(this.twistProgram, 'u_center'), 0.5, 0.5);
                    gl.uniform1f(gl.getUniformLocation(this.twistProgram, 'u_radius'), 900.0 / Math.min(w, h));
                    gl.uniform1f(gl.getUniformLocation(this.twistProgram, 'u_angle'), -3.25);
                    gl.uniform2f(gl.getUniformLocation(this.twistProgram, 'u_resolution'), w, h);

                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }
                // Kawase模糊需要多次迭代
                applyKawaseBlur(inputIdx, outputFb, blurConfig) {
                    const gl = this.gl;
                    const w = this.canvas.width, h = this.canvas.height;

                    let currentInput = inputIdx;
                    let currentOutputFb = outputFb;
                    let currentOutputIdx = outputFb === this.framebuffers[1] ? 1 : 2;

                    // 纹理保护：初始输出与输入同 index 时，先切到另一块 ping-pong 缓冲
                    if (currentInput === currentOutputIdx) {
                        currentOutputIdx = currentOutputIdx === 1 ? 2 : 1;
                        currentOutputFb = this.framebuffers[currentOutputIdx];
                    }

                    // 根据quality进行多次迭代
                    const kernels = this.getKawaseKernels(blurConfig.blur, blurConfig.quality);

                    for (let i = 0; i < kernels.length; i++) {
                        // 纹理保护：确保“写入目标纹理”不在任何 texture unit 上保持绑定
                        this.detachTextureFromUnits(this.fbTextures[currentOutputIdx]);

                        gl.bindFramebuffer(gl.FRAMEBUFFER, currentOutputFb);
                        gl.clearColor(0, 0, 0, 0);
                        gl.viewport(0, 0, w, h);
                        gl.clear(gl.COLOR_BUFFER_BIT);

                        this.setupProgram(this.blurProgram);
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, this.fbTextures[currentInput]);
                        gl.uniform2f(gl.getUniformLocation(this.blurProgram, 'u_resolution'), w, h);
                        gl.uniform1f(gl.getUniformLocation(this.blurProgram, 'u_offset'), kernels[i]);

                        gl.drawArrays(gl.TRIANGLES, 0, 6);

                        // 交换缓冲区
                        if (i < kernels.length - 1) {
                            currentInput = currentOutputIdx;
                            currentOutputIdx = currentOutputIdx === 1 ? 2 : 1;
                            currentOutputFb = this.framebuffers[currentOutputIdx];
                        }
                    }

                    return currentOutputIdx;
                }

                // 从pixi-filters的KawaseBlurFilter抄过来的kernel计算
                getKawaseKernels(blur, quality) {
                    const kernels = [];
                    if (blur > 0) {
                        let k = blur;
                        const q = quality;
                        for (let i = 0; i < q; i++) {
                            kernels.push(k);
                            k *= 0.5;
                        }
                    }
                    return kernels.length > 0 ? kernels : [0];
                }
                applySaturation(inputIdx, outputFb) {
                    const gl = this.gl;
                    const w = this.canvas.width, h = this.canvas.height;

                    // 纹理保护：避免采样与写入同一纹理
                    let outputIdx = outputFb === this.framebuffers[1] ? 1 : 2;
                    if (inputIdx === outputIdx) {
                        outputIdx = outputIdx === 1 ? 2 : 1;
                        outputFb = this.framebuffers[outputIdx];
                    }
                    this.detachTextureFromUnits(this.fbTextures[outputIdx]);

                    gl.bindFramebuffer(gl.FRAMEBUFFER, outputFb);
                    gl.clearColor(0, 0, 0, 0);
                    gl.viewport(0, 0, w, h);
                    gl.clear(gl.COLOR_BUFFER_BIT);

                    this.setupProgram(this.saturationProgram);
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, this.fbTextures[inputIdx]);
                    // AdjustmentFilter配置 - 从LyricsScene.ts抄过来: saturation: 2.75
                    gl.uniform1f(gl.getUniformLocation(this.saturationProgram, 'u_saturation'), 2.75);

                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }

                copyToScreen(inputIdx) {
                    const gl = this.gl;
                    // 清空默认帧缓冲区，使用透明背景，这样如果内容没有完全覆盖则显示后面的渐变背景
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);

                    this.setupProgram(this.copyProgram);
                    gl.bindTexture(gl.TEXTURE_2D, this.fbTextures[inputIdx]);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }
                render() {
                    this.renderSprites();

                    let currentIdx = 0;

                    // 选择一个与当前输入不同的输出缓冲（只在 1/2 之间 ping-pong，避免 0 号被重复绑定造成驱动报错）
                    const pickOutIdx = () => (currentIdx === 1 ? 2 : 1);

                    // 扭曲
                    if (this.filters.twist) {
                        const outIdx = pickOutIdx();
                        this.applyTwist(currentIdx, this.framebuffers[outIdx]);
                        currentIdx = outIdx;
                    }

                    // 模糊层（KawaseBlur 内部会根据迭代次数决定最终输出 idx，因此这里以返回值为准）
                    for (let i = 0; i < 5; i++) {
                        if (this.filters.blur[i]) {
                            const outIdx = pickOutIdx();
                            currentIdx = this.applyKawaseBlur(currentIdx, this.framebuffers[outIdx], this.blurConfigs[i]);
                        }
                    }

                    // 饱和度
                    if (this.filters.saturation) {
                        const outIdx = pickOutIdx();
                        this.applySaturation(currentIdx, this.framebuffers[outIdx]);
                        currentIdx = outIdx;
                    }

                    this.copyToScreen(currentIdx);
                }

                // 精灵动画 - 直接从LyricsScene.ts的ticker抄过来
                updateSprites(deltaMS) {
                    const n = deltaMS / 33.333333;
                    // sprite 0
                    this.sprites[0].rotation += 0.003 * n;

                    // sprite 1
                    this.sprites[1].rotation -= 0.008 * n;

                    // sprite 2 - 圆周运动
                    this.sprites[2].rotation -= 0.006 * n;
                    this.sprites[2].x = 0.5 + 0.25 * Math.cos(this.sprites[2].rotation * 0.75);
                    this.sprites[2].y = 0.5 + 0.25 * Math.sin(this.sprites[2].rotation * 0.75);

                    // sprite 3 - 圆周运动带偏移
                    this.sprites[3].rotation += 0.004 * n;
                    this.sprites[3].x = 0.5 + 0.05 + 0.25 * Math.cos(this.sprites[3].rotation * 0.75);
                    this.sprites[3].y = 0.5 + 0.05 + 0.25 * Math.sin(this.sprites[3].rotation * 0.75);
                }

                animate() {
                    if (this._destroyed) return;

                    if (!this.paused) {
                        const now = performance.now();
                        const delta = this.lastTime ? now - this.lastTime : 16.67;
                        this.lastTime = now;

                        this.updateSprites(delta);
                        this.render();
                    }
                    // ★ 为了可销毁，保存 RAF id
                    this._rafId = requestAnimationFrame(() => this.animate());
                }

                updateFilters(options) {
                    this.filters.twist = options.twist;
                    this.filters.blur = options.blur;
                    this.filters.saturation = options.sat;
                }

                resize() {
                    this.canvas.width = this.container.clientWidth;
                    this.canvas.height = this.container.clientHeight;
                    this.createFramebuffers();
                }

                pause() { this.paused = true; }
                resume() { this.paused = false; this.lastTime = null; }

                // ★ 新增：完整清理所有资源
                destroy() {
                    this._destroyed = true;

                    try {
                        if (this._rafId) cancelAnimationFrame(this._rafId);
                    } catch (_) {}

                    try {
                        if (this._onResize) window.removeEventListener('resize', this._onResize);
                    } catch (_) {}

                    const gl = this.gl;
                    if (!gl) return;

                    try {
                        if (this.imageTexture) gl.deleteTexture(this.imageTexture);
                    } catch (_) {}

                    try {
                        if (this.fbTextures) this.fbTextures.forEach(tex => { try { gl.deleteTexture(tex); } catch(_){} });
                        if (this.framebuffers) this.framebuffers.forEach(fb => { try { gl.deleteFramebuffer(fb); } catch(_){} });
                    } catch (_) {}

                    try { if (this.positionBuffer) gl.deleteBuffer(this.positionBuffer); } catch (_) {}
                    try { if (this.texCoordBuffer) gl.deleteBuffer(this.texCoordBuffer); } catch (_) {}

                    try {
                        if (this._programs) this._programs.forEach(p => { try { gl.deleteProgram(p); } catch(_){} });
                        if (this._shaders) this._shaders.forEach(s => { try { gl.deleteShader(s); } catch(_){} });
                    } catch (_) {}

                    try {
                        const ext = gl.getExtension('WEBGL_lose_context');
                        if (ext && ext.loseContext) ext.loseContext();
                    } catch (_) {}

                    try {
                        if (this.canvas && this.canvas.parentNode) this.canvas.parentNode.removeChild(this.canvas);
                    } catch (_) {}

                    this.gl = null;
                }
            };

            // 运行态变量
            this.scene = null;
            this.layerEl = null;
            this._controlsAbort = null;
            this._isPlaying = true;
            this._lastImageSource = null;
        }

        async init(container) { 
            console.log("[Pixi背景] 初始化开始...");
            dcInfo('背景系统', 'Pixi背景：初始化开始...');
            const host = document.getElementById('bgHost');
            if (host) host.style.display = 'block';

            // 创建图层
            this.layerEl = document.createElement('div');
            this.layerEl.className = 'bg-layer';
            this.layerEl.style.position = 'absolute';
            this.layerEl.style.inset = '0';
            container.appendChild(this.layerEl);

            // 初始化场景
            this.scene = new this.LyricsScene(this.layerEl);

            // 初次加载：若已有专辑封面则用之，否则用默认
            const firstUrl = window.__bgManager?.lastAlbumUrl || this.DEFAULT_IMAGE_URL;
            this._lastImageSource = firstUrl;
            await this.scene.loadImage(firstUrl);

            return this.getControlsHTML();
        }

        destroy() { 
            console.log("[Pixi背景] 清理资源...");
            dcInfo('背景系统', 'Pixi背景：清理资源...');
            try { if (this._controlsAbort) this._controlsAbort.abort(); } catch (_) {}

            try { if (this.scene && typeof this.scene.destroy === 'function') this.scene.destroy(); } catch (e) {
                console.warn("[Pixi背景] scene.destroy 失败:", e);
            }
            this.scene = null;

            try {
                if (this.layerEl && this.layerEl.parentNode) this.layerEl.parentNode.removeChild(this.layerEl);
            } catch (_) {}
            this.layerEl = null;

            this._isPlaying = true;
        }

        getControlsHTML() {
            // 生成这个背景专用的控制面板HTML（包含原始文件中的所有控制选项）
            return `
                <div class="control-group-title">Pixi 动态背景</div>

                <div class="bg-ctrl-row">
                    <label class="bg-file-btn" title="选择本地图片文件">
                        选择文件
                        <input type="file" id="fileInput" accept="image/*" style="display:none">
                    </label>
                    <button id="stopBtn" title="暂停/播放背景动画">暂停</button>
                </div>

                <div class="bg-file-name" id="fileName">默认图片</div>

                <div class="bg-ctrl-row" style="width:100%">
                    <input type="text" id="urlInput" placeholder="输入图片URL..." />
                    <button id="loadUrlBtn" title="加载URL图片">加载URL图片</button>
                </div>

                <div class="bg-sep"></div>

                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="twistEffect" checked> 扭曲效果</label>
                </div>

                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blurEffect"> 模糊</label>
                </div>

                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur1"> 模糊层1（5像素）</label>
                </div>
                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur2"> 模糊层2（10像素）</label>
                </div>
                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur3"> 模糊层3（20像素）</label>
                </div>
                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur4"> 模糊层4（40像素）</label>
                </div>
                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="blur5"> 模糊层5（80像素）</label>
                </div>

                <div class="bg-ctrl-row">
                    <label><input type="checkbox" id="saturation" checked> 饱和度</label>
                </div>

                <div class="bg-hint" style="margin-top:10px;">
                    提示：手动选择文件/URL 后，将自动关闭“跟随专辑封面”，以保留你的自定义图片。
                </div>
            `;
        }

        bindControls(rootEl, { onUserOverride } = {}) {
            if (!rootEl) return;
            if (!this.scene) return;

            // 使用 AbortController 便于 destroy 时一键卸载事件
            this._controlsAbort = new AbortController();
            const sig = { signal: this._controlsAbort.signal };

            const $ = (id) => rootEl.querySelector(`#${id}`);

            const fileInput = $('fileInput');
            const fileName = $('fileName');
            const urlInput = $('urlInput');
            const loadUrlBtn = $('loadUrlBtn');
            const stopBtn = $('stopBtn');

            const twistEffect = $('twistEffect');
            const blurEffect = $('blurEffect');
            const blurIds = ['blur1','blur2','blur3','blur4','blur5'];
            const saturation = $('saturation');

            const updateFilters = () => {
                try {
                    this.scene.updateFilters({
                        twist: !!twistEffect?.checked,
                        blur: blurIds.map(id => !!$(id)?.checked),
                        sat: !!saturation?.checked,
                    });
                } catch (e) {
                    console.warn("[Pixi背景] updateFilters 异常:", e);
                }
            };

            if (fileInput) fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    if (fileName) fileName.textContent = file.name;
                    this._lastImageSource = file;
                    try { await this.scene.loadImage(file); } catch (err) {}
                    if (typeof onUserOverride === 'function') onUserOverride();
                }
            }, sig);

            if (loadUrlBtn) loadUrlBtn.addEventListener('click', async () => {
                const url = (urlInput?.value || '').trim();
                if (url) {
                    if (fileName) fileName.textContent = url.split('/').pop();
                    this._lastImageSource = url;
                    try { await this.scene.loadImage(url); } catch (err) {}
                    if (typeof onUserOverride === 'function') onUserOverride();
                }
            }, sig);

            // 暂停/播放
            if (stopBtn) stopBtn.addEventListener('click', () => {
                this._isPlaying = !this._isPlaying;
                try {
                    if (this._isPlaying) {
                        this.scene.resume();
                        stopBtn.textContent = '暂停';
                    } else {
                        this.scene.pause();
                        stopBtn.textContent = '播放';
                    }
                } catch (e) {}
            }, sig);

            // 滤镜监听
            if (twistEffect) twistEffect.addEventListener('change', updateFilters, sig);
            if (blurEffect) blurEffect.addEventListener('change', (e) => {
                blurIds.forEach(id => { const el = $(id); if (el) el.checked = e.target.checked; });
                updateFilters();
            }, sig);
            blurIds.concat(['saturation']).forEach(id => {
                const el = $(id);
                if (el) el.addEventListener('change', updateFilters, sig);
            });

            updateFilters();
        }

        async updateFromAlbum(url) {
            if (!this.scene || !url) return;
            this._lastImageSource = url;
            try { await this.scene.loadImage(url); } catch (e) {}
            // 尽量同步显示
            const fileNameEl = document.getElementById('fileName');
            if (fileNameEl) fileNameEl.textContent = `[专辑封面] ${url.split('/').pop()}`;
        }
    }

    // =========================================================
    // === Mesh背景完整封装 ===
    // （以下核心渲染逻辑完整复制自 mesh-gradient-background-fixed.html，
    //  仅对 resize/RAF 增加可释放能力，并加入 destroy() 做资源清理）
    // =========================================================
    
    // =========================================================
    // === Mesh背景完整封装 ===
    // （以下核心渲染逻辑完整复制自 mesh-gradient-background-fixed.html，
    //  仅对 resize/RAF 增加可释放能力，并加入 destroy() 做资源清理）
    // =========================================================
    class MeshBackgroundSystem {
        constructor() {
            // 包含mesh-gradient-background-fixed.html的所有代码（完整复制）
                        // ============================================
                // 配置
                // ============================================
                const DEFAULT_IMAGE_URL = 'https://imge.kugou.com/stdmusic/orig/20150718/20150718214459760936.jpg';

                // ============================================
                // 数学库 - 向量和矩阵 (从 gl-matrix 简化移植)
                // ============================================
                class Vec2 {
                    constructor(x = 0, y = 0) { this.x = x; this.y = y; }
                    static create() { return new Vec2(); }
                    static fromValues(x, y) { return new Vec2(x, y); }
                    copy(v) { this.x = v.x; this.y = v.y; return this; }
                    set(x, y) { this.x = x; this.y = y; return this; }
                    get 0() { return this.x; }
                    set 0(v) { this.x = v; }
                    get 1() { return this.y; }
                    set 1(v) { this.y = v; }
                }

                class Vec3 {
                    constructor(r = 0, g = 0, b = 0) { this.r = r; this.g = g; this.b = b; }
                    static create() { return new Vec3(); }
                    static fromValues(r, g, b) { return new Vec3(r, g, b); }
                    get x() { return this.r; }
                    set x(v) { this.r = v; }
                    get y() { return this.g; }
                    set y(v) { this.g = v; }
                    get z() { return this.b; }
                    set z(v) { this.b = v; }
                }

                class Vec4 {
                    constructor() { this.data = new Float32Array(4); }
                    static create() { return new Vec4(); }
                    get 0() { return this.data[0]; }
                    set 0(v) { this.data[0] = v; }
                    get 1() { return this.data[1]; }
                    set 1(v) { this.data[1] = v; }
                    get 2() { return this.data[2]; }
                    set 2(v) { this.data[2] = v; }
                    get 3() { return this.data[3]; }
                    set 3(v) { this.data[3] = v; }
                    copy(v) { for(let i=0;i<4;i++) this.data[i] = v.data[i]; return this; }
                    dot(v) { return this.data[0]*v.data[0] + this.data[1]*v.data[1] + this.data[2]*v.data[2] + this.data[3]*v.data[3]; }
                    static transformMat4(out, a, m) {
                        const x=a.data[0], y=a.data[1], z=a.data[2], w=a.data[3];
                        out.data[0] = m.data[0]*x + m.data[4]*y + m.data[8]*z + m.data[12]*w;
                        out.data[1] = m.data[1]*x + m.data[5]*y + m.data[9]*z + m.data[13]*w;
                        out.data[2] = m.data[2]*x + m.data[6]*y + m.data[10]*z + m.data[14]*w;
                        out.data[3] = m.data[3]*x + m.data[7]*y + m.data[11]*z + m.data[15]*w;
                        return out;
                    }
                }

                class Mat4 {
                    constructor() { this.data = new Float32Array(16); }
                    static create() { return new Mat4(); }
                    static fromValues(...args) { const m = new Mat4(); for(let i=0;i<16;i++) m.data[i] = args[i] || 0; return m; }
                    static clone(m) { const n = new Mat4(); for(let i=0;i<16;i++) n.data[i] = m.data[i]; return n; }
                    copy(m) { for(let i=0;i<16;i++) this.data[i] = m.data[i]; return this; }
                    fill(v) { for(let i=0;i<16;i++) this.data[i] = v; return this; }
                    transpose() {
                        const d = this.data;
                        const t = (i,j) => { const tmp = d[i*4+j]; d[i*4+j] = d[j*4+i]; d[j*4+i] = tmp; };
                        t(0,1); t(0,2); t(0,3); t(1,2); t(1,3); t(2,3);
                        return this;
                    }
                    static mul(out, a, b) {
                        // 按 gl-matrix(mat4.multiply) 的列主序规则实现
                        const outd = out.data, ad = a.data, bd = b.data;

                        const a00 = ad[0],  a01 = ad[1],  a02 = ad[2],  a03 = ad[3];
                        const a10 = ad[4],  a11 = ad[5],  a12 = ad[6],  a13 = ad[7];
                        const a20 = ad[8],  a21 = ad[9],  a22 = ad[10], a23 = ad[11];
                        const a30 = ad[12], a31 = ad[13], a32 = ad[14], a33 = ad[15];

                        const b00 = bd[0],  b01 = bd[1],  b02 = bd[2],  b03 = bd[3];
                        const b10 = bd[4],  b11 = bd[5],  b12 = bd[6],  b13 = bd[7];
                        const b20 = bd[8],  b21 = bd[9],  b22 = bd[10], b23 = bd[11];
                        const b30 = bd[12], b31 = bd[13], b32 = bd[14], b33 = bd[15];

                        outd[0]  = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
                        outd[1]  = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
                        outd[2]  = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
                        outd[3]  = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;

                        outd[4]  = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
                        outd[5]  = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
                        outd[6]  = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
                        outd[7]  = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;

                        outd[8]  = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
                        outd[9]  = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
                        outd[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
                        outd[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;

                        outd[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
                        outd[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
                        outd[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
                        outd[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;

                        return out;
                    }
                }

                // ============================================
                // 图像处理函数 (从 applemusic-like-lyrics 完整复制)
                // ============================================
                function blurImage(imageData, radius, quality) {
                    const pixels = imageData.data;
                    const width = imageData.width;
                    const height = imageData.height;
                    let rsum, gsum, bsum, asum, x, y, i, p, p1, p2, yp, yi, yw;
                    const wm = width - 1, hm = height - 1;
                    const rad1x = radius + 1, divx = radius + rad1x;
                    const rad1y = radius + 1, divy = radius + rad1y;
                    const div2 = 1 / (divx * divy);
                    const r = [], g = [], b = [], a = [], vmin = [], vmax = [];

                    while (quality-- > 0) {
                        yw = yi = 0;
                        for (y = 0; y < height; y++) {
                            rsum = pixels[yw] * rad1x; gsum = pixels[yw + 1] * rad1x;
                            bsum = pixels[yw + 2] * rad1x; asum = pixels[yw + 3] * rad1x;
                            for (i = 1; i <= radius; i++) {
                                p = yw + ((i > wm ? wm : i) << 2);
                                rsum += pixels[p++]; gsum += pixels[p++]; bsum += pixels[p++]; asum += pixels[p];
                            }
                            for (x = 0; x < width; x++) {
                                r[yi] = rsum; g[yi] = gsum; b[yi] = bsum; a[yi] = asum;
                                if (y === 0) { vmin[x] = Math.min(x + rad1x, wm) << 2; vmax[x] = Math.max(x - radius, 0) << 2; }
                                p1 = yw + vmin[x]; p2 = yw + vmax[x];
                                rsum += pixels[p1++] - pixels[p2++]; gsum += pixels[p1++] - pixels[p2++];
                                bsum += pixels[p1++] - pixels[p2++]; asum += pixels[p1] - pixels[p2];
                                yi++;
                            }
                            yw += width << 2;
                        }
                        for (x = 0; x < width; x++) {
                            yp = x;
                            rsum = r[yp] * rad1y; gsum = g[yp] * rad1y; bsum = b[yp] * rad1y; asum = a[yp] * rad1y;
                            for (i = 1; i <= radius; i++) { yp += i > hm ? 0 : width; rsum += r[yp]; gsum += g[yp]; bsum += b[yp]; asum += a[yp]; }
                            yi = x << 2;
                            for (y = 0; y < height; y++) {
                                pixels[yi] = (rsum * div2 + 0.5) | 0; pixels[yi + 1] = (gsum * div2 + 0.5) | 0;
                                pixels[yi + 2] = (bsum * div2 + 0.5) | 0; pixels[yi + 3] = (asum * div2 + 0.5) | 0;
                                if (x === 0) { vmin[y] = Math.min(y + rad1y, hm) * width; vmax[y] = Math.max(y - radius, 0) * width; }
                                p1 = x + vmin[y]; p2 = x + vmax[y];
                                rsum += r[p1] - r[p2]; gsum += g[p1] - g[p2]; bsum += b[p1] - b[p2]; asum += a[p1] - a[p2];
                                yi += width << 2;
                            }
                        }
                    }
                }

                function saturateImage(imageData, saturation) {
                    const pixels = imageData.data;
                    for (let i = 0; i < pixels.length; i += 4) {
                        const r = pixels[i], g = pixels[i + 1], b = pixels[i + 2];
                        const gray = r * 0.3 + g * 0.59 + b * 0.11;
                        pixels[i] = gray * (1 - saturation) + r * saturation;
                        pixels[i + 1] = gray * (1 - saturation) + g * saturation;
                        pixels[i + 2] = gray * (1 - saturation) + b * saturation;
                    }
                }

                function brightnessImage(imageData, brightness) {
                    const pixels = imageData.data;
                    for (let i = 0; i < pixels.length; i += 4) {
                        pixels[i] *= brightness; pixels[i + 1] *= brightness; pixels[i + 2] *= brightness;
                    }
                }

                function contrastImage(imageData, contrast) {
                    const pixels = imageData.data;
                    for (let i = 0; i < pixels.length; i += 4) {
                        pixels[i] = (pixels[i] - 128) * contrast + 128;
                        pixels[i + 1] = (pixels[i + 1] - 128) * contrast + 128;
                        pixels[i + 2] = (pixels[i + 2] - 128) * contrast + 128;
                    }
                }

                // ============================================
                // Bicubic Hermite Patch 贝塞尔曲面核心实现
                // (从 applemusic-like-lyrics 完整移植)
                // ============================================
    
                // Hermite 基函数矩阵
                const H = Mat4.fromValues(2, -2, 1, 1, -3, 3, -2, -1, 0, 0, 1, 0, 1, 0, 0, 0);
                const H_T = Mat4.clone(H); H_T.transpose();

                // 控制点类
                class ControlPoint {
                    constructor() {
                        this.color = Vec3.fromValues(1, 1, 1);
                        this.location = Vec2.fromValues(0, 0);
                        this.uTangent = Vec2.fromValues(0, 0);
                        this.vTangent = Vec2.fromValues(0, 0);
                        this._uRot = 0; this._vRot = 0;
                        this._uScale = 1; this._vScale = 1;
                    }
                    get uRot() { return this._uRot; }
                    set uRot(value) { this._uRot = value; this.updateUTangent(); }
                    get vRot() { return this._vRot; }
                    set vRot(value) { this._vRot = value; this.updateVTangent(); }
                    get uScale() { return this._uScale; }
                    set uScale(value) { this._uScale = value; this.updateUTangent(); }
                    get vScale() { return this._vScale; }
                    set vScale(value) { this._vScale = value; this.updateVTangent(); }
                    updateUTangent() { this.uTangent.x = Math.cos(this._uRot) * this._uScale; this.uTangent.y = Math.sin(this._uRot) * this._uScale; }
                    updateVTangent() { this.vTangent.x = -Math.sin(this._vRot) * this._vScale; this.vTangent.y = Math.cos(this._vRot) * this._vScale; }
                }

                // 曲面点计算 - 核心贝塞尔算法
                const spUx = Vec4.create(), spUy = Vec4.create(), spV = Vec4.create();
                const spxAcc = Mat4.create(), spyAcc = Mat4.create();
    
                function surfacePoint(u, v, X, Y, output = Vec2.create()) {
                    spUx[0] = u ** 3; spUx[1] = u ** 2; spUx[2] = u; spUx[3] = 1;
                    spUy.copy(spUx);
                    spV[0] = v ** 3; spV[1] = v ** 2; spV[2] = v; spV[3] = 1;

                    spxAcc.copy(X).transpose();
                    Mat4.mul(spxAcc, spxAcc, H);
                    Mat4.mul(spxAcc, H_T, spxAcc);
                    Vec4.transformMat4(spUx, spUx, spxAcc);
                    const x = spV.dot(spUx);

                    spyAcc.copy(Y).transpose();
                    Mat4.mul(spyAcc, spyAcc, H);
                    Mat4.mul(spyAcc, H_T, spyAcc);
                    Vec4.transformMat4(spUy, spUy, spyAcc);
                    const y = spV.dot(spUy);

                    output.x = x; output.y = y;
                    return output;
                }

                // 网格系数矩阵
                function meshCoefficients(p00, p01, p10, p11, axis, output = Mat4.create()) {
                    const l = p => p.location[axis];
                    const u = p => p.uTangent[axis];
                    const v = p => p.vTangent[axis];

                    output.data[0] = l(p00); output.data[1] = l(p01); output.data[2] = v(p00); output.data[3] = v(p01);
                    output.data[4] = l(p10); output.data[5] = l(p11); output.data[6] = v(p10); output.data[7] = v(p11);
                    output.data[8] = u(p00); output.data[9] = u(p01); output.data[10] = 0; output.data[11] = 0;
                    output.data[12] = u(p10); output.data[13] = u(p11); output.data[14] = 0; output.data[15] = 0;
                    return output;
                }

                // 颜色系数矩阵
                function colorCoefficients(p00, p01, p10, p11, axis, output = Mat4.create()) {
                    const c = p => p.color[axis];
                    output.fill(0);
                    output.data[0] = c(p00); output.data[1] = c(p01);
                    output.data[4] = c(p10); output.data[5] = c(p11);
                    return output;
                }

                const cpUx = Vec4.create(), cpUy = Vec4.create(), cpUz = Vec4.create(), cpV = Vec4.create();
                const cprAcc = Mat4.create(), cpgAcc = Mat4.create(), cpbAcc = Mat4.create();
                const cpResult = Vec3.create();
    
                function colorPoint(u, v, R, G, B) {
                    cpUx[0] = u ** 3; cpUx[1] = u ** 2; cpUx[2] = u; cpUx[3] = 1;
                    cpUy.copy(cpUx); cpUz.copy(cpUx);
                    cpV[0] = v ** 3; cpV[1] = v ** 2; cpV[2] = v; cpV[3] = 1;

                    cprAcc.copy(R).transpose(); Mat4.mul(cprAcc, cprAcc, H); Mat4.mul(cprAcc, H_T, cprAcc);
                    Vec4.transformMat4(cpUx, cpUx, cprAcc); cpResult.r = cpV.dot(cpUx);

                    cpgAcc.copy(G).transpose(); Mat4.mul(cpgAcc, cpgAcc, H); Mat4.mul(cpgAcc, H_T, cpgAcc);
                    Vec4.transformMat4(cpUy, cpUy, cpgAcc); cpResult.g = cpV.dot(cpUy);

                    cpbAcc.copy(B).transpose(); Mat4.mul(cpbAcc, cpbAcc, H); Mat4.mul(cpbAcc, H_T, cpbAcc);
                    Vec4.transformMat4(cpUz, cpUz, cpbAcc); cpResult.b = cpV.dot(cpUz);

                    return cpResult;
                }

                // 2D Map 数据结构
                class Map2D {
                    constructor(width, height) { this._width = width; this._height = height; this._data = new Array(width * height).fill(null); }
                    resize(width, height) { this._width = width; this._height = height; this._data = new Array(width * height).fill(null); }
                    set(x, y, value) { this._data[x + y * this._width] = value; }
                    get(x, y) { return this._data[x + y * this._width]; }
                    get width() { return this._width; }
                    get height() { return this._height; }
                }

                // ============================================
                // Bicubic Hermite Patch Mesh 类
                // ============================================
                class BHPMesh {
                    constructor() {
                        this._subDivisions = 15;
                        this._controlPoints = new Map2D(3, 3);
                        this.vertexData = null;
                        this.indexData = null;
                        this.vertexWidth = 0;
                        this.vertexHeight = 0;
                        this.tempX = Mat4.create(); this.tempY = Mat4.create();
                        this.tempR = Mat4.create(); this.tempG = Mat4.create(); this.tempB = Mat4.create();
                        this.tmpV2 = Vec2.create();
                        this.resizeControlPoints(3, 3);
                    }

                    resetSubdivision(subDivisions) {
                        this._subDivisions = subDivisions;
                        this.vertexWidth = (this._controlPoints.width - 1) * subDivisions;
                        this.vertexHeight = (this._controlPoints.height - 1) * subDivisions;
                        const vertexCount = this.vertexWidth * this.vertexHeight;
                        this.vertexData = new Float32Array(vertexCount * 7); // pos(2) + color(3) + uv(2)
                        this.indexData = new Uint16Array((this.vertexWidth - 1) * (this.vertexHeight - 1) * 6);
            
                        // 生成索引
                        let idx = 0;
                        for (let y = 0; y < this.vertexHeight - 1; y++) {
                            for (let x = 0; x < this.vertexWidth - 1; x++) {
                                const i = y * this.vertexWidth + x;
                                this.indexData[idx++] = i;
                                this.indexData[idx++] = i + 1;
                                this.indexData[idx++] = i + this.vertexWidth;
                                this.indexData[idx++] = i + 1;
                                this.indexData[idx++] = i + this.vertexWidth + 1;
                                this.indexData[idx++] = i + this.vertexWidth;
                            }
                        }
                    }

                    resizeControlPoints(width, height) {
                        if (width < 2 || height < 2) throw new Error("Control points must be at least 2x2");
                        this._controlPoints.resize(width, height);
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                const point = new ControlPoint();
                                point.location.x = (x / (width - 1)) * 2 - 1;
                                point.location.y = (y / (height - 1)) * 2 - 1;
                                point.uTangent.x = 2 / (width - 1);
                                point.vTangent.y = 2 / (height - 1);
                                this._controlPoints.set(x, y, point);
                            }
                        }
                        this.resetSubdivision(this._subDivisions);
                    }

                    getControlPoint(x, y) { return this._controlPoints.get(x, y); }

                    setVertexData(vx, vy, px, py, pr, pg, pb, uvX, uvY) {
                        const idx = (vx + vy * this.vertexWidth) * 7;
                        this.vertexData[idx] = px; this.vertexData[idx + 1] = py;
                        this.vertexData[idx + 2] = pr; this.vertexData[idx + 3] = pg; this.vertexData[idx + 4] = pb;
                        this.vertexData[idx + 5] = uvX; this.vertexData[idx + 6] = uvY;
                    }

                    // 核心：更新网格顶点数据
                    updateMesh() {
                        const subDivM1 = this._subDivisions - 1;
                        const tW = subDivM1 * (this._controlPoints.height - 1);
                        const tH = subDivM1 * (this._controlPoints.width - 1);
                        const cpW = this._controlPoints.width;
                        const cpH = this._controlPoints.height;
                        const subDiv = this._subDivisions;
                        const invSubDivM1 = 1 / subDivM1;
                        const invTH = 1 / tH;
                        const invTW = 1 / tW;

                        for (let x = 0; x < cpW - 1; x++) {
                            for (let y = 0; y < cpH - 1; y++) {
                                const p00 = this._controlPoints.get(x, y);
                                const p01 = this._controlPoints.get(x, y + 1);
                                const p10 = this._controlPoints.get(x + 1, y);
                                const p11 = this._controlPoints.get(x + 1, y + 1);

                                meshCoefficients(p00, p01, p10, p11, 'x', this.tempX);
                                meshCoefficients(p00, p01, p10, p11, 'y', this.tempY);
                                colorCoefficients(p00, p01, p10, p11, 'r', this.tempR);
                                colorCoefficients(p00, p01, p10, p11, 'g', this.tempG);
                                colorCoefficients(p00, p01, p10, p11, 'b', this.tempB);

                                const sX = x / (cpW - 1);
                                const sY = y / (cpH - 1);
                                const baseVx = y * subDiv;
                                const baseVy = x * subDiv;

                                for (let u = 0; u < subDiv; u++) {
                                    const uNorm = u * invSubDivM1;
                                    const vxOffset = baseVx + u;

                                    for (let v = 0; v < subDiv; v++) {
                                        const vNorm = v * invSubDivM1;
                                        const vy = baseVy + v;

                                        const pos = surfacePoint(uNorm, vNorm, this.tempX, this.tempY, this.tmpV2);
                                        const col = colorPoint(uNorm, vNorm, this.tempR, this.tempG, this.tempB);
                                        const uvX = sX + v * invTH;
                                        const uvY = 1 - sY - u * invTW;

                                        this.setVertexData(vxOffset, vy, pos.x, pos.y, col.r, col.g, col.b, uvX, uvY);
                                    }
                                }
                            }
                        }
                    }
                }

                // ============================================
                // 网格预设 (从项目完整复制)
                // ============================================
                const CONTROL_POINT_PRESETS = [
                    { width: 4, height: 4, conf: [
                        {cx:0,cy:0,x:-1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:0,x:-0.33,y:-1,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:0,x:0.33,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:0,x:1,y:-1,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:1,x:-1,y:-0.04,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:1,x:-0.24,y:-0.22,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:1,x:0.33,y:-0.005,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:1,x:0.99,y:-0.34,ur:8,vr:0,up:0.566,vp:1.792},
                        {cx:0,cy:2,x:-1,y:0.33,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:2,x:-0.34,y:0,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:2,x:0.33,y:0.2,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:2,x:1,y:0.08,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:3,x:-1,y:1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:3,x:-0.33,y:1,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:3,x:0.33,y:1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:3,x:1,y:1,ur:0,vr:0,up:1,vp:1},
                    ]},
                    { width: 5, height: 5, conf: [
                        {cx:0,cy:0,x:-1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:0,x:-0.5,y:-1,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:0,x:0,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:0,x:0.5,y:-1,ur:0,vr:0,up:1,vp:1},
                        {cx:4,cy:0,x:1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:0,cy:1,x:-1,y:-0.5,ur:0,vr:0,up:1,vp:1},
                        {cx:1,cy:1,x:-0.5,y:-0.5,ur:0,vr:0,up:1,vp:1}, {cx:2,cy:1,x:-0.005,y:-0.61,ur:0,vr:0,up:1,vp:1},
                        {cx:3,cy:1,x:0.59,y:-0.4,ur:0,vr:0,up:1,vp:1}, {cx:4,cy:1,x:1,y:-0.5,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:2,x:-1,y:0,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:2,x:-0.42,y:-0.12,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:2,x:-0.1,y:-0.02,ur:0,vr:-47,up:0.629,vp:0.849}, {cx:3,cy:2,x:0.4,y:-0.06,ur:0,vr:0,up:1,vp:1},
                        {cx:4,cy:2,x:1,y:0,ur:0,vr:0,up:1,vp:1}, {cx:0,cy:3,x:-1,y:0.5,ur:0,vr:0,up:1,vp:1},
                        {cx:1,cy:3,x:0.07,y:0.52,ur:-31,vr:-45,up:1,vp:1}, {cx:2,cy:3,x:0.21,y:0.29,ur:6,vr:-56,up:0.566,vp:1.321},
                        {cx:3,cy:3,x:0.5,y:0.5,ur:0,vr:0,up:1,vp:1}, {cx:4,cy:3,x:1,y:0.5,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:4,x:-1,y:1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:4,x:-0.31,y:1,ur:0,vr:0,up:1,vp:1},
                        {cx:2,cy:4,x:0.26,y:1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:4,x:0.5,y:1,ur:0,vr:0,up:1,vp:1},
                        {cx:4,cy:4,x:1,y:1,ur:0,vr:0,up:1,vp:1},
                    ]},
                    { width: 5, height: 5, conf: [
                        {cx:0,cy:0,x:-1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:0,x:-0.45,y:-1,ur:0,vr:55,up:1,vp:2.075},
                        {cx:2,cy:0,x:0.2,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:3,cy:0,x:0.46,y:-1,ur:0,vr:-25,up:1,vp:1},
                        {cx:4,cy:0,x:1,y:-1,ur:0,vr:0,up:1,vp:1}, {cx:0,cy:1,x:-1,y:-0.25,ur:-16,vr:0,up:2.327,vp:0.943},
                        {cx:1,cy:1,x:-0.56,y:-0.66,ur:47,vr:0,up:2.358,vp:0.377}, {cx:2,cy:1,x:0.23,y:-0.52,ur:-66,vr:-25,up:1.855,vp:1.164},
                        {cx:3,cy:1,x:0.69,y:-0.38,ur:0,vr:0,up:1,vp:1}, {cx:4,cy:1,x:1,y:-0.67,ur:0,vr:0,up:1,vp:1},
                        {cx:0,cy:2,x:-1,y:0.04,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:2,x:-0.49,y:0.01,ur:90,vr:23,up:1,vp:1.981},
                        {cx:2,cy:2,x:0.02,y:-0.14,ur:0,vr:42,up:1,vp:1}, {cx:3,cy:2,x:0.48,y:0.06,ur:-30,vr:0,up:1.95,vp:0.44},
                        {cx:4,cy:2,x:1,y:0.25,ur:0,vr:0,up:1,vp:1}, {cx:0,cy:3,x:-1,y:0.7,ur:-68,vr:0,up:1,vp:0.786},
                        {cx:1,cy:3,x:-0.69,y:0.59,ur:-68,vr:0,up:1,vp:1}, {cx:2,cy:3,x:0.18,y:0.39,ur:61,vr:0,up:1,vp:1},
                        {cx:3,cy:3,x:0.61,y:0.46,ur:-47,vr:-59,up:0.849,vp:1.73}, {cx:4,cy:3,x:1,y:0.62,ur:-33,vr:0,up:0.377,vp:1.604},
                        {cx:0,cy:4,x:-1,y:1,ur:0,vr:0,up:1,vp:1}, {cx:1,cy:4,x:-0.5,y:1,ur:0,vr:-73,up:1,vp:1},
                        {cx:2,cy:4,x:-0.33,y:1,ur:0,vr:-24,up:0.314,vp:2.704}, {cx:3,cy:4,x:0.5,y:1,ur:0,vr:0,up:1,vp:1},
                        {cx:4,cy:4,x:1,y:1,ur:0,vr:0,up:1,vp:1},
                    ]}
                ];

                function generateRandomPreset(w, h) {
                    const conf = [];
                    for (let y = 0; y < h; y++) {
                        for (let x = 0; x < w; x++) {
                            const baseX = (x / (w - 1)) * 2 - 1;
                            const baseY = (y / (h - 1)) * 2 - 1;
                            const isEdge = x === 0 || x === w - 1 || y === 0 || y === h - 1;
                            conf.push({
                                cx: x, cy: y,
                                x: isEdge ? baseX : baseX + (Math.random() - 0.5) * 0.6,
                                y: isEdge ? baseY : baseY + (Math.random() - 0.5) * 0.6,
                                ur: isEdge ? 0 : (Math.random() - 0.5) * 120,
                                vr: isEdge ? 0 : (Math.random() - 0.5) * 120,
                                up: 0.3 + Math.random() * 1.7,
                                vp: 0.3 + Math.random() * 1.7
                            });
                        }
                    }
                    return { width: w, height: h, conf };
                }

                // ============================================
                // WebGL 渲染器
                // ============================================
                const vertexShaderSource = `
                    precision highp float;

                    attribute vec2 a_pos;
                    attribute vec3 a_color;
                    attribute vec2 a_uv;

                    varying vec3 v_color;
                    varying vec2 v_uv;

                    uniform float u_aspect;

                    void main() {
                        v_color = a_color;
                        v_uv = a_uv;

                        vec2 pos = a_pos;
                        if (u_aspect > 1.0) {
                            pos.y *= u_aspect;
                        } else {
                            pos.x /= u_aspect;
                        }

                        gl_Position = vec4(pos, 0.0, 1.0);
                    }
                `;


                const fragmentShaderSource = `
                    precision highp float;

                    varying vec3 v_color;
                    varying vec2 v_uv;

                    uniform sampler2D u_texture;
                    uniform float u_time;
                    uniform float u_alpha;
                    uniform float u_volume;

                    const float INV_255 = 1.0 / 255.0;
                    const float GRADIENT_NOISE_A = 52.9829189;
                    const vec2 GRADIENT_NOISE_B = vec2(0.06711056, 0.00583715);

                    float gradientNoise(vec2 uv) {
                        return fract(GRADIENT_NOISE_A * fract(dot(uv, GRADIENT_NOISE_B)));
                    }

                    vec2 rot(vec2 v, float angle) {
                        float s = sin(angle);
                        float c = cos(angle);
                        return vec2(c * v.x - s * v.y, s * v.x + c * v.y);
                    }

                    void main() {
                        // Dithering. NOTE: This may look weird in some videos, so comment it out in your projects if you don't like it.
                        float dither = INV_255 * gradientNoise(gl_FragCoord.xy) - 0.5 * INV_255;

                        float timeVolume = u_time + u_volume;

                        vec2 centeredUV = v_uv - vec2(0.2);
                        vec2 rotatedUV = rot(centeredUV, timeVolume * 2.0);
                        vec2 finalUV = rotatedUV + vec2(0.5);

                        vec4 result = texture2D(u_texture, finalUV);
                        result.rgb *= v_color * u_alpha;
                        result.a *= u_alpha;
                        result.rgb += vec3(dither);

                        float dist = distance(v_uv, vec2(0.5));
                        float vignette = smoothstep(0.8, 0.3, dist);
                        result.rgb *= 0.6 + vignette * 0.4;

                        gl_FragColor = result;
                    }
                `;


                class MeshGradientRenderer {
                    constructor(canvas) {
                        this.canvas = canvas;
                        this.gl = canvas.getContext('webgl');
                        if (!this.gl) throw new Error('WebGL not supported');
            
                        this.paused = false;
                        this.time = 0;
                        this.speed = 1;
                        this.subdivisions = 15;
                        this.imageSettings = { contrast: 0.4, saturation: 3.0, brightness: 0.75, blur: 2 };
                        this.mesh = new BHPMesh();
                        this.preset = CONTROL_POINT_PRESETS[0];
            
                        // ★ 集成增强：可销毁标记/RAF/resize-handler
                        this._destroyed = false;
                        this._rafId = null;
                        this._onResize = null;

                        this.init();
                        this.resize();
                        this.animate();
            
                        this._onResize = () => this.resize();
                        window.addEventListener('resize', this._onResize);
                    }
        
                    init() {
                        const gl = this.gl;
            
                        const vs = gl.createShader(gl.VERTEX_SHADER);
                        gl.shaderSource(vs, vertexShaderSource);
                        gl.compileShader(vs);
            
                        const fs = gl.createShader(gl.FRAGMENT_SHADER);
                        gl.shaderSource(fs, fragmentShaderSource);
                        gl.compileShader(fs);

                        // ★ 集成增强：保存 shader 引用，便于 destroy 时释放
                        this._vs = vs;
                        this._fs = fs;
            
                        this.program = gl.createProgram();
                        gl.attachShader(this.program, vs);
                        gl.attachShader(this.program, fs);
                        gl.linkProgram(this.program);
            
                        this.posAttr = gl.getAttribLocation(this.program, 'a_pos');
                        this.colorAttr = gl.getAttribLocation(this.program, 'a_color');
                        this.uvAttr = gl.getAttribLocation(this.program, 'a_uv');
                        this.timeUniform = gl.getUniformLocation(this.program, 'u_time');
                        this.alphaUniform = gl.getUniformLocation(this.program, 'u_alpha');
                        this.textureUniform = gl.getUniformLocation(this.program, 'u_texture');
            
            
                        this.aspectUniform = gl.getUniformLocation(this.program, 'u_aspect');
                        this.volumeUniform = gl.getUniformLocation(this.program, 'u_volume');
            this.vertexBuffer = gl.createBuffer();
                        this.indexBuffer = gl.createBuffer();
            
                        gl.enable(gl.BLEND);
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                        gl.enable(gl.DEPTH_TEST);
                        gl.depthFunc(gl.ALWAYS);
            
                        this.applyPreset(this.preset);
                    }
        
                    applyPreset(preset) {
                        this.preset = preset;
                        this.mesh.resizeControlPoints(preset.width, preset.height);
                        const uPower = 2 / (preset.width - 1);
                        const vPower = 2 / (preset.height - 1);
            
                        for (const cp of preset.conf) {
                            const p = this.mesh.getControlPoint(cp.cx, cp.cy);
                            p.location.x = cp.x;
                            p.location.y = cp.y;
                            p.uRot = (cp.ur * Math.PI) / 180;
                            p.vRot = (cp.vr * Math.PI) / 180;
                            p.uScale = uPower * cp.up;
                            p.vScale = vPower * cp.vp;
                        }
            
                        this.mesh.resetSubdivision(this.subdivisions);
                        this.mesh.updateMesh();
                        this.uploadMesh();
                    }
        
                    uploadMesh() {
                        const gl = this.gl;
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, this.mesh.vertexData, gl.DYNAMIC_DRAW);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.mesh.indexData, gl.STATIC_DRAW);
                    }
        
                    async loadImage(source) {
                        return new Promise((resolve) => {
                            const img = new Image();
                            img.crossOrigin = 'anonymous';
                            img.onload = () => { this.processImage(img); resolve(); };
                            img.onerror = () => { this.createFallbackTexture(); resolve(); };
                
                            if (source instanceof File) {
                                const reader = new FileReader();
                                reader.onload = (e) => { img.src = e.target.result; };
                                reader.readAsDataURL(source);
                            } else {
                                img.src = source;
                            }
                        });
                    }
        
                    processImage(img) {
                        const size = 32;
                        const canvas = document.createElement('canvas');
                        canvas.width = size; canvas.height = size;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, size, size);
                        const imageData = ctx.getImageData(0, 0, size, size);
            
                        contrastImage(imageData, this.imageSettings.contrast);
                        saturateImage(imageData, this.imageSettings.saturation);
                        contrastImage(imageData, 1.7);
                        brightnessImage(imageData, this.imageSettings.brightness);
                        if (this.imageSettings.blur > 0) blurImage(imageData, this.imageSettings.blur, 4);
            
                        ctx.putImageData(imageData, 0, 0);
                        this.uploadTexture(canvas);
                    }
                    createFallbackTexture() {
                        const canvas = document.createElement('canvas');
                        canvas.width = 32; canvas.height = 32;
                        const ctx = canvas.getContext('2d');

                        // Deep Nebula（缩略纹理版）：黑底 + 霓虹彩斑 + 轻微星尘
                        ctx.fillStyle = '#0B0B0B';
                        ctx.fillRect(0, 0, 32, 32);

                        const neon = ['#921E58', '#1989FA', '#9C27B0', '#00E5FF', '#FF2EC4'];
                        const hexToRgb = (hex) => {
                            const h = (hex || '#000000').replace('#', '');
                            const n = parseInt(h.length === 3 ? h.split('').map(ch => ch + ch).join('') : h, 16);
                            return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
                        };
                        const rand = (a, b) => a + Math.random() * (b - a);

                        ctx.globalCompositeOperation = 'lighter';
                        for (let i = 0; i < 7; i++) {
                            const color = neon[i % neon.length];
                            const rgb = hexToRgb(color);
                            const x = rand(-6, 38);
                            const y = rand(-6, 38);
                            const r = rand(8, 20);

                            ctx.globalAlpha = rand(0.10, 0.28);
                            ctx.shadowBlur = r * 0.55;
                            ctx.shadowColor = `rgba(${rgb.r},${rgb.g},${rgb.b},0.9)`;

                            const g = ctx.createRadialGradient(x, y, 0, x, y, r);
                            g.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0.75)`);
                            g.addColorStop(0.55, `rgba(${rgb.r},${rgb.g},${rgb.b},0.20)`);
                            g.addColorStop(1, 'rgba(0,0,0,0)');

                            ctx.fillStyle = g;
                            ctx.beginPath();
                            ctx.arc(x, y, r, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // 星尘
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.shadowBlur = 0;
                        for (let i = 0; i < 55; i++) {
                            const x = Math.random() * 32;
                            const y = Math.random() * 32;
                            ctx.globalAlpha = rand(0.05, 0.16);
                            ctx.fillStyle = 'rgba(255,255,255,1)';
                            ctx.fillRect(x, y, 1, 1);
                        }

                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                        ctx.shadowColor = 'transparent';
                        ctx.globalCompositeOperation = 'source-over';

                        this.uploadTexture(canvas);
                    }
        
                    uploadTexture(canvas) {
                        const gl = this.gl;
                        if (this.texture) gl.deleteTexture(this.texture);
                        this.texture = gl.createTexture();
                        gl.bindTexture(gl.TEXTURE_2D, this.texture);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
                    }
        
                    resize() {
                        const dpr = Math.max(1, window.devicePixelRatio || 1);
                        const cssW = Math.max(1, window.innerWidth);
                        const cssH = Math.max(1, window.innerHeight);

                        this.canvas.width = Math.max(1, Math.round(cssW * dpr));
                        this.canvas.height = Math.max(1, Math.round(cssH * dpr));
                        this.canvas.style.width = cssW + 'px';
                        this.canvas.style.height = cssH + 'px';

                        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    }
        
                    render() {
                        const gl = this.gl;
                        gl.clearColor(0, 0, 0, 1);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        if (!this.texture) return;
            
                        gl.useProgram(this.program);
                        gl.uniform1f(this.timeUniform, this.time / 10000);
                        gl.uniform1f(this.alphaUniform, 1.0);
                        gl.uniform1f(this.aspectUniform, this.canvas.width / this.canvas.height);
                        gl.uniform1f(this.volumeUniform, 0.0);
            
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, this.texture);
                        gl.uniform1i(this.textureUniform, 0);
            
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            
                        const stride = 7 * 4;
                        gl.enableVertexAttribArray(this.posAttr);
                        gl.vertexAttribPointer(this.posAttr, 2, gl.FLOAT, false, stride, 0);
                        gl.enableVertexAttribArray(this.colorAttr);
                        gl.vertexAttribPointer(this.colorAttr, 3, gl.FLOAT, false, stride, 8);
                        gl.enableVertexAttribArray(this.uvAttr);
                        gl.vertexAttribPointer(this.uvAttr, 2, gl.FLOAT, false, stride, 20);
            
                        gl.drawElements(gl.TRIANGLES, this.mesh.indexData.length, gl.UNSIGNED_SHORT, 0);
                    }
        
                    animate() {
                        if (this._destroyed) return;
                        if (!this.paused) this.time += 16.67 * this.speed;
                        this.render();
                        this._rafId = requestAnimationFrame(() => this.animate());
                    }
        
                    pause() { this.paused = true; }
                    resume() { this.paused = false; }
        
                    randomizePreset() {
                        const w = 4 + Math.floor(Math.random() * 3);
                        const h = 4 + Math.floor(Math.random() * 3);
                        this.applyPreset(generateRandomPreset(w, h));
                    }
        
                    setSubdivisions(value) {
                        this.subdivisions = value;
                        this.mesh.resetSubdivision(value);
                        this.mesh.updateMesh();
                        this.uploadMesh();
                    }

                    // ★ 集成增强：完整清理资源，防止内存泄漏
                    destroy() {
                        this._destroyed = true;

                        try { if (this._rafId) cancelAnimationFrame(this._rafId); } catch (_) {}
                        try { if (this._onResize) window.removeEventListener('resize', this._onResize); } catch (_) {}

                        const gl = this.gl;
                        if (!gl) return;

                        try { if (this.texture) gl.deleteTexture(this.texture); } catch (_) {}
                        try { if (this.vertexBuffer) gl.deleteBuffer(this.vertexBuffer); } catch (_) {}
                        try { if (this.indexBuffer) gl.deleteBuffer(this.indexBuffer); } catch (_) {}

                        try { if (this.program) gl.deleteProgram(this.program); } catch (_) {}
                        try { if (this._vs) gl.deleteShader(this._vs); } catch (_) {}
                        try { if (this._fs) gl.deleteShader(this._fs); } catch (_) {}

                        try {
                            const ext = gl.getExtension('WEBGL_lose_context');
                            if (ext && ext.loseContext) ext.loseContext();
                        } catch (_) {}

                        this.gl = null;
                    }
                }

                // ============================================
                // 初始化
                // ============================================
                let renderer = null;
                let lastImageSource = null;

                async function init() {
                    const canvas = document.getElementById('canvas');
                    renderer = new MeshGradientRenderer(canvas);
                    renderer.createFallbackTexture();
        
                    try {
                        lastImageSource = DEFAULT_IMAGE_URL;
                        await renderer.loadImage(DEFAULT_IMAGE_URL);
                        document.getElementById('fileName').textContent = DEFAULT_IMAGE_URL.split('/').pop();
                    } catch (e) {
                        console.log('Using fallback');
                    }
        
                    bindControls();
                }

                function bindControls() {
                    document.getElementById('fileInput').addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            document.getElementById('fileName').textContent = file.name;
                            lastImageSource = file;
                            await renderer.loadImage(file);
                        }
                    });
        
                    document.getElementById('loadUrlBtn').addEventListener('click', async () => {
                        const url = document.getElementById('urlInput').value.trim();
                        if (url) {
                            document.getElementById('fileName').textContent = url.split('/').pop();
                            lastImageSource = url;
                            await renderer.loadImage(url);
                        }
                    });
        
                    let isPaused = false;
                    document.getElementById('pauseBtn').addEventListener('click', () => {
                        isPaused = !isPaused;
                        if (isPaused) { renderer.pause(); document.getElementById('pauseBtn').textContent = '播放'; }
                        else { renderer.resume(); document.getElementById('pauseBtn').textContent = '暂停'; }
                    });
        
                    const reloadImage = async () => { if (lastImageSource) await renderer.loadImage(lastImageSource); };
        
                    document.getElementById('contrast').addEventListener('input', async (e) => {
                        renderer.imageSettings.contrast = e.target.value / 100;
                        await reloadImage();
                    });
                    document.getElementById('saturation').addEventListener('input', async (e) => {
                        renderer.imageSettings.saturation = e.target.value / 100;
                        await reloadImage();
                    });
                    document.getElementById('brightness').addEventListener('input', async (e) => {
                        renderer.imageSettings.brightness = e.target.value / 100;
                        await reloadImage();
                    });
                    document.getElementById('blur').addEventListener('input', async (e) => {
                        renderer.imageSettings.blur = parseInt(e.target.value);
                        await reloadImage();
                    });
                    document.getElementById('speed').addEventListener('input', (e) => {
                        renderer.speed = e.target.value / 100;
                    });
                    document.getElementById('subdivisions').addEventListener('input', (e) => {
                        renderer.setSubdivisions(parseInt(e.target.value));
                    });
                    document.getElementById('randomPreset').addEventListener('click', () => {
                        renderer.randomizePreset();
                    });
                }

                // window.addEventListener('DOMContentLoaded', init);  // 已由集成版背景管理器接管初始化

            // 运行态变量（外层封装使用）
            this.renderer = null;
            this.canvas = null;
            this.layerEl = null;
            this.lastImageSource = null;
            this._controlsAbort = null;

            // 从原脚本中抽取的核心类：MeshGradientRenderer
            // （注意：MeshGradientRenderer 在上面的原脚本中以 class 形式定义）
            this._MeshGradientRenderer = (typeof MeshGradientRenderer !== 'undefined') ? MeshGradientRenderer : null;

            // 兜底：如果原脚本 DEFAULT_IMAGE_URL 存在，则同步
            try {
                if (typeof DEFAULT_IMAGE_URL !== 'undefined') this.DEFAULT_IMAGE_URL = DEFAULT_IMAGE_URL;
            } catch (_) {}
        }

        async init(container) {
            console.log("[Mesh背景] 初始化开始...");
            dcInfo('背景系统', 'Mesh背景：初始化开始...');
            const host = document.getElementById('bgHost');
            if (host) host.style.display = 'block';

            // 创建图层与 canvas
            this.layerEl = document.createElement('div');
            this.layerEl.className = 'bg-layer';
            this.layerEl.style.position = 'absolute';
            this.layerEl.style.inset = '0';

            this.canvas = document.createElement('canvas');
            // 为了尽量贴近原文件，这里保留 id="canvas"
            this.canvas.id = 'canvas';
            this.canvas.style.width = '100%';
            this.canvas.style.height = '100%';
            this.layerEl.appendChild(this.canvas);

            container.appendChild(this.layerEl);

            if (!this._MeshGradientRenderer) throw new Error('MeshGradientRenderer 未就绪');

            this.renderer = new this._MeshGradientRenderer(this.canvas);
            // 原文件初始化逻辑
            try { this.renderer.createFallbackTexture(); } catch (_) {}

            const firstUrl = window.__bgManager?.lastAlbumUrl || this.DEFAULT_IMAGE_URL;
            this.lastImageSource = firstUrl;
            try { await this.renderer.loadImage(firstUrl); } catch (e) {}

            return this.getControlsHTML();
        }

        destroy() {
            console.log("[Mesh背景] 清理资源...");
            dcInfo('背景系统', 'Mesh背景：清理资源...');
            try { if (this._controlsAbort) this._controlsAbort.abort(); } catch (_) {}

            try { if (this.renderer && typeof this.renderer.destroy === 'function') this.renderer.destroy(); } catch (e) {
                console.warn("[Mesh背景] renderer.destroy 失败:", e);
            }
            this.renderer = null;

            try {
                if (this.layerEl && this.layerEl.parentNode) this.layerEl.parentNode.removeChild(this.layerEl);
            } catch (_) {}
            this.layerEl = null;
            this.canvas = null;
            this.lastImageSource = null;
        }

        getControlsHTML() {
            // 原始控制项完整保留：文件/URL、暂停、对比度/饱和度/亮度/模糊/速度/细分/随机预设
            return `
                <div class="control-group-title">Mesh 渐变背景</div>

                <div class="bg-ctrl-row">
                    <label class="bg-file-btn">
                        选择文件
                        <input type="file" id="fileInput" accept="image/*" style="display:none">
                    </label>
                    <button id="pauseBtn">暂停</button>
                </div>

                <div class="bg-file-name" id="fileName">点击选择图片或输入URL</div>

                <div class="bg-ctrl-row" style="width:100%">
                    <input type="text" id="urlInput" placeholder="输入图片 URL…">
                    <button id="loadUrlBtn">加载URL图片</button>
                </div>

                <div class="bg-sep"></div>

                <div class="bg-ctrl-row">
                    <label>对比度</label>
                    <input type="range" id="contrast" min="0" max="200" value="40">
                </div>

                <div class="bg-ctrl-row">
                    <label>饱和度</label>
                    <input type="range" id="saturation" min="0" max="500" value="300">
                </div>

                <div class="bg-ctrl-row">
                    <label>亮度</label>
                    <input type="range" id="brightness" min="0" max="200" value="75">
                </div>

                <div class="bg-ctrl-row">
                    <label>模糊</label>
                    <input type="range" id="blur" min="0" max="10" value="2">
                </div>

                <div class="bg-ctrl-row">
                    <label>旋转速度</label>
                    <input type="range" id="speed" min="0" max="200" value="100">
                </div>

                <div class="bg-ctrl-row">
                    <label>细分级别</label>
                    <input type="range" id="subdivisions" min="5" max="30" value="15">
                </div>

                <div class="bg-ctrl-row" style="width:100%">
                    <button id="randomPreset" style="width:100%">随机网格预设</button>
                </div>

                <div class="bg-hint" style="margin-top:10px;">
                    提示：手动选择文件/URL 后，将自动关闭“跟随专辑封面”，以保留你的自定义图片。
                </div>
            `;
        }

        bindControls(rootEl, { onUserOverride } = {}) {
            if (!rootEl || !this.renderer) return;

            this._controlsAbort = new AbortController();
            const sig = { signal: this._controlsAbort.signal };
            const $ = (id) => rootEl.querySelector(`#${id}`);

            const fileInput = $('fileInput');
            const fileName = $('fileName');
            const urlInput = $('urlInput');
            const loadUrlBtn = $('loadUrlBtn');
            const pauseBtn = $('pauseBtn');

            const contrast = $('contrast');
            const saturation = $('saturation');
            const brightness = $('brightness');
            const blur = $('blur');
            const speed = $('speed');
            const subdivisions = $('subdivisions');
            const randomPreset = $('randomPreset');

            // 记录当前图片源，供滤镜调参后重载
            const reloadImage = async () => {
                if (this.lastImageSource) {
                    try { await this.renderer.loadImage(this.lastImageSource); } catch (_) {}
                }
            };

            if (fileInput) fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    if (fileName) fileName.textContent = file.name;
                    this.lastImageSource = file;
                    try { await this.renderer.loadImage(file); } catch (_) {}
                    if (typeof onUserOverride === 'function') onUserOverride();
                }
            }, sig);

            if (loadUrlBtn) loadUrlBtn.addEventListener('click', async () => {
                const url = (urlInput?.value || '').trim();
                if (url) {
                    if (fileName) fileName.textContent = url.split('/').pop();
                    this.lastImageSource = url;
                    try { await this.renderer.loadImage(url); } catch (_) {}
                    if (typeof onUserOverride === 'function') onUserOverride();
                }
            }, sig);

            // 暂停/播放
            let isPaused = false;
            if (pauseBtn) pauseBtn.addEventListener('click', () => {
                isPaused = !isPaused;
                if (isPaused) { this.renderer.pause(); pauseBtn.textContent = '播放'; }
                else { this.renderer.resume(); pauseBtn.textContent = '暂停'; }
            }, sig);

            if (contrast) contrast.addEventListener('input', async (e) => {
                this.renderer.imageSettings.contrast = e.target.value / 100;
                await reloadImage();
            }, sig);

            if (saturation) saturation.addEventListener('input', async (e) => {
                this.renderer.imageSettings.saturation = e.target.value / 100;
                await reloadImage();
            }, sig);

            if (brightness) brightness.addEventListener('input', async (e) => {
                this.renderer.imageSettings.brightness = e.target.value / 100;
                await reloadImage();
            }, sig);

            if (blur) blur.addEventListener('input', async (e) => {
                this.renderer.imageSettings.blur = parseInt(e.target.value);
                await reloadImage();
            }, sig);

            if (speed) speed.addEventListener('input', (e) => {
                this.renderer.speed = e.target.value / 100;
            }, sig);

            if (subdivisions) subdivisions.addEventListener('input', (e) => {
                this.renderer.setSubdivisions(parseInt(e.target.value));
            }, sig);

            if (randomPreset) randomPreset.addEventListener('click', () => {
                this.renderer.randomizePreset();
            }, sig);
        }

        async updateFromAlbum(url) {
            if (!this.renderer || !url) return;
            this.lastImageSource = url;
            try { await this.renderer.loadImage(url); } catch (e) {}

            const fileNameEl = document.getElementById('fileName');
            if (fileNameEl) fileNameEl.textContent = `[专辑封面] ${
                (url.split('/').pop() || url).slice(0, 80)
            }`;
        }
    }


    // =========================================================
    // === 背景管理器 ===
    // =========================================================
    class BackgroundManager {
        constructor({ hostEl, controlsMountEl, badgeEl, followAlbumEl }) {
            console.log("[背景管理器] 初始化...");
            dcInfo('背景系统', '背景管理器初始化...');
            this.currentBg = null;
            this.bgTypes = ['default', 'pixi', 'mesh'];
            this.currentIndex = 0;

            this.hostEl = hostEl;
            this.controlsMountEl = controlsMountEl;
            this.badgeEl = badgeEl;
            this.followAlbumEl = followAlbumEl;

            this.lastAlbumUrl = null;

            // 默认背景系统
            this.defaultSystem = new DefaultBackgroundSystem();
        }

        getCurrentType() {
            return this.bgTypes[this.currentIndex] || 'default';
        }

        _setBadge(type) {
            if (!this.badgeEl) return;
            const map = { default: '默认', pixi: 'Pixi', mesh: 'Mesh' };
            this.badgeEl.textContent = map[type] || type;
        }

        _clearControlsUI() {
            if (!this.controlsMountEl) return;
            this.controlsMountEl.innerHTML = `
                <div class="bg-hint">
                    当前背景无额外控制项。<br>
                    提示：切换到 Pixi / Mesh 背景后，这里会出现对应的完整控制面板。
                </div>
            `;
        }

        _mountControls(bg) {
            if (!this.controlsMountEl) return;

            if (!bg || typeof bg.getControlsHTML !== 'function') {
                this._clearControlsUI();
                return;
            }

            const html = bg.getControlsHTML();
            if (!html) {
                this._clearControlsUI();
                return;
            }

            this.controlsMountEl.innerHTML = html;

            // 绑定事件 & 手动覆盖逻辑
            const onUserOverride = () => {
                // 用户手动选择文件/URL，则关闭跟随封面
                const followEl = this.followAlbumEl;
                if (followEl && followEl.checked) {
                    followEl.checked = false;
                    console.log("[背景系统] 检测到用户手动选择图片，已自动关闭：跟随专辑封面");
                    dcInfo('背景系统', '用户手动选择图片：自动关闭“跟随专辑封面”');
                }
            };

            if (typeof bg.bindControls === 'function') {
                bg.bindControls(this.controlsMountEl, { onUserOverride });
            }
        }

        async switchBackground(type) {
            // Fix: 兼容 iOS / PWA 场景 console.group 缺失导致的崩溃
            try { console.group(`[背景切换] 切换到 ${type}`); } catch (e) { try { console.log(`[背景切换] 切换到 ${type}`); } catch (_) {} }
            console.log("当前背景:", this.currentBg?.constructor?.name || '无');
            console.log("开始清理旧资源...");

            // 清理旧背景
            try {
                if (this.currentBg && typeof this.currentBg.destroy === 'function') {
                    this.currentBg.destroy();
                }
            } catch (e) {
                console.warn("[背景切换] 清理旧背景异常:", e);
                dcWarn('背景系统', `清理旧背景异常：${e.message || e}`);
            }

            // 清空宿主层
            try {
                if (this.hostEl) this.hostEl.innerHTML = '';
            } catch (_) {}

            console.log("旧资源清理完成，开始初始化新背景...");

            // 根据类型初始化新背景
            let newBg = null;
            try {
                if (type === 'default') {
                    newBg = this.defaultSystem;
                    newBg.init();
                    // 默认背景无专用控制
                    this._clearControlsUI();
                } else if (type === 'pixi') {
                    // 关闭默认背景
                    this.defaultSystem.destroy();
                    document.getElementById('gradientCanvas')?.style && (document.getElementById('gradientCanvas').style.display = 'none');

                    newBg = new PixiBackgroundSystem();
                    await newBg.init(this.hostEl);
                    this._mountControls(newBg);
                } else if (type === 'mesh') {
                    // 关闭默认背景
                    this.defaultSystem.destroy();
                    document.getElementById('gradientCanvas')?.style && (document.getElementById('gradientCanvas').style.display = 'none');

                    newBg = new MeshBackgroundSystem();
                    await newBg.init(this.hostEl);
                    this._mountControls(newBg);
                } else {
                    console.warn("[背景切换] 未知背景类型，回退 default:", type);
                    newBg = this.defaultSystem;
                    newBg.init();
                    this._clearControlsUI();
                }
            } catch (e) {
// Fix: 兼容 iOS / PWA 场景 console.error 缺失导致的崩溃
                try { console.error("[背景切换] 新背景初始化失败，回退默认背景:", e); } catch (e) { try { console.log("[背景切换] 新背景初始化失败，回退默认背景:", e); } catch (_) {} }
                dcError('背景系统', `新背景初始化失败：${e.message || e}，已回退默认背景`);
                newBg = this.defaultSystem;
                try { newBg.init(); } catch (_) {}
                this._clearControlsUI();
                type = 'default';
            }

            this.currentBg = newBg;
            this._setBadge(type);

            // 若开启跟随封面，且有 lastAlbumUrl，则立即刷新背景
            try {
                const follow = !!this.followAlbumEl?.checked;
                if (follow && this.lastAlbumUrl && this.currentBg && typeof this.currentBg.updateFromAlbum === 'function') {
                    await this.currentBg.updateFromAlbum(this.lastAlbumUrl);
                }
            } catch (_) {}

            console.log("新背景初始化完成");
            // Fix: 兼容 iOS / PWA 场景 console.groupEnd 缺失导致的崩溃
            try { console.groupEnd(); } catch (e) { try { console.log('[背景切换] groupEnd'); } catch (_) {} }
        }

        async cycle() {
            this.currentIndex = (this.currentIndex + 1) % this.bgTypes.length;
            const type = this.bgTypes[this.currentIndex];
            await this.switchBackground(type);
        }

        async handleAlbumArtChanged(url) {
            if (!url) return;
            this.lastAlbumUrl = url;

            const follow = !!this.followAlbumEl?.checked;
            if (!follow) return;

            if (this.currentBg && typeof this.currentBg.updateFromAlbum === 'function') {
                try {
                    await this.currentBg.updateFromAlbum(url);
                } catch (e) {
                    console.warn("[背景系统] updateFromAlbum 失败:", e);
                }
            }
        }
    }

    // =========================================================
    // 控制面板智能适配：运行时分析现有布局空间（按需求必须分析）
    // =========================================================
    function analyzeExistingLayout() {
        try {
            const container = document.querySelector('.container');
            const searchSection = document.querySelector('.search-section');
            const controls = document.querySelector('.controls');

            const report = {
                containerWidth: container ? container.clientWidth : null,
                searchSectionWidth: searchSection ? searchSection.clientWidth : null,
                controlsWidth: controls ? controls.clientWidth : null,
                viewport: { w: window.innerWidth, h: window.innerHeight }
            };

            console.log("[布局分析] 现有控制面板空间评估:", report);

            // 方案选择：折叠式控制面板（本实现）
            console.log("[布局方案] 已启用：方案A（折叠式控制面板），避免直接堆叠控件。");
        } catch (e) {
            console.warn("[布局分析] 失败:", e);
        }
    }

    // =========================================================
    // 背景面板：拖拽（可选增强，满足“智能适配/可用空间”需求）
    // =========================================================
    function enablePanelDrag(panelEl, handleEl) {
        if (!panelEl || !handleEl) return;

        let dragging = false;
        let startX = 0, startY = 0;
        let startLeft = 0, startBottom = 0;

        const onDown = (e) => {
            // 仅鼠标/触控主键
            if (e.type === 'mousedown' && e.button !== 0) return;

            dragging = true;
            const rect = panelEl.getBoundingClientRect();
            startLeft = rect.left;
            startBottom = window.innerHeight - rect.bottom;

            const pt = e.touches ? e.touches[0] : e;
            startX = pt.clientX;
            startY = pt.clientY;

            e.preventDefault();
        };

        const onMove = (e) => {
            if (!dragging) return;
            const pt = e.touches ? e.touches[0] : e;
            const dx = pt.clientX - startX;
            const dy = pt.clientY - startY;

            // left 增加 dx，bottom 减少 dy（因为向下 dy>0）
            let newLeft = startLeft + dx;
            let newBottom = startBottom - dy;

            // 边界限制
            const maxLeft = window.innerWidth - panelEl.offsetWidth - 8;
            const maxBottom = window.innerHeight - panelEl.offsetHeight - 8;
            newLeft = Math.max(8, Math.min(maxLeft, newLeft));
            newBottom = Math.max(8, Math.min(maxBottom, newBottom));

            panelEl.style.left = newLeft + 'px';
            panelEl.style.bottom = newBottom + 'px';
        };

        const onUp = () => { dragging = false; };

        handleEl.addEventListener('mousedown', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);

        handleEl.addEventListener('touchstart', onDown, { passive: false });
        window.addEventListener('touchmove', onMove, { passive: false });
        window.addEventListener('touchend', onUp);
        window.addEventListener('touchcancel', onUp);
    }

    // =========================================================
    // 测试清单（控制台输出）
    // =========================================================
    async function runIntegrationTests(bgManager) {
        const results = [];

        const ok = (name, pass, detail='') => {
            results.push({ 测试项: name, 结果: pass ? '✅通过' : '❌失败', 说明: detail });
        };

        // 基础功能测试（尽量不干扰原播放器）
        ok('1. 播放/暂停/音量控制元素存在', !!document.getElementById('audioPlayer') && !!document.getElementById('playBtn') && !!document.getElementById('volumeSlider'));
        ok('2. 取色器/封面元素存在', !!document.getElementById('albumArt'));
        ok('3. KMeans按钮存在', !!document.getElementById('algoToggleBtn') || !!document.querySelector('#algoToggleBtn'));
        ok('4. API选择器存在', !!document.getElementById('apiSelect'));

        // Fix: 禁用自动背景切换测试，避免干扰初始状态和用户体验
        // 改为静态检查，手动测试可调用 window.testBackgroundSwitch()
        ok('5. Pixi背景类已加载', typeof PixiBackgroundSystem === 'function');
        ok('6. Mesh背景类已加载', typeof MeshBackgroundSystem === 'function');
        ok('7. 背景管理器已初始化', !!bgManager && typeof bgManager.switchBackground === 'function');

        // 简易内存释放检测
        ok('8. 背景宿主DOM状态正常', document.getElementById('bgHost')?.style.display === 'none', 'default 模式下 bgHost 应隐藏');

        // Fix: 添加渐变动画运行状态测试
        ok('8.1 渐变动画函数已暴露', typeof window.startGradientAnimation === 'function');
        ok('8.2 渐变动画正在运行', typeof window.getGradientAnimationId === 'function' && window.getGradientAnimationId() !== null, '动画 ID 应不为 null');
        ok('8.3 gradientCanvas可见', document.getElementById('gradientCanvas')?.style.display !== 'none');

        // 控制面板测试
        ok('9. 背景面板按钮存在', !!document.getElementById('bgToggleBtn'));
        ok('10. 背景面板结构存在', !!document.getElementById('bgPanel') && !!document.getElementById('bgSwitchBtn'));
        ok('11. 响应式（无法强测）', true, '请在不同窗口尺寸下观察布局是否重叠');

        // 调试系统测试
        ok('12. 控制台启动日志已输出', true, '请检查控制台顶部是否出现“音乐播放器背景系统启动”');
        ok('13. 全局错误捕获已注册', true, '已通过 window.addEventListener(error/unhandledrejection) 注册');
        ok('14. reportPlayerStatus 可调用', typeof window.reportPlayerStatus === 'function');

        // Fix: 兼容 iOS / PWA 场景 console.group 缺失导致的崩溃
        try { console.group("=== 集成测试报告（多背景系统）==="); } catch (e) { try { console.log("=== 集成测试报告（多背景系统）==="); } catch (_) {} }
        console.table(results);
        // Fix: 兼容 iOS / PWA 场景 console.groupEnd 缺失导致的崩溃
        try { console.groupEnd(); } catch (e) { try { console.log('=== 集成测试报告结束 ==='); } catch (_) {} }

        dcInfo('测试', '已输出多背景系统集成测试报告（控制台）');
        
        // Fix: 暴露手动背景切换测试函数，避免自动测试干扰初始状态
        window.testBackgroundSwitch = async function() {
            console.log("=== 开始背景切换测试 ===");
            try {
                console.log("切换到 Pixi 背景...");
                await bgManager.switchBackground('pixi');
                console.log("✅ Pixi 背景初始化成功");
                await new Promise(r => setTimeout(r, 1500));
                
                console.log("切换到 Mesh 背景...");
                await bgManager.switchBackground('mesh');
                console.log("✅ Mesh 背景初始化成功");
                await new Promise(r => setTimeout(r, 1500));
                
                console.log("切回默认背景...");
                await bgManager.switchBackground('default');
                console.log("✅ 默认背景恢复成功");
                
                console.log("=== 背景切换测试完成 ===");
            } catch (e) {
                console.error("❌ 背景切换测试失败:", e);
            }
        };
        console.log("💡 提示：可在控制台运行 testBackgroundSwitch() 进行背景切换测试");
    }

    // =========================================================
    // 初始化入口
    // =========================================================
    function initBackgroundSystem() {
        analyzeExistingLayout();

        const bgHost = document.getElementById('bgHost');
        const bgPanel = document.getElementById('bgPanel');
        const bgToggleBtn = document.getElementById('bgToggleBtn');
        const bgSwitchBtn = document.getElementById('bgSwitchBtn');
        const bgControlsMount = document.getElementById('bgControlsMount');
        const bgStatusBadge = document.getElementById('bgStatusBadge');
        const bgFollowAlbum = document.getElementById('bgFollowAlbum');
        const bgPanelCloseBtn = document.getElementById('bgPanelCloseBtn');
        const bgPanelMinBtn = document.getElementById('bgPanelMinBtn');
        const bgPanelHeader = document.getElementById('bgPanelHeader');

        if (!bgHost || !bgPanel || !bgToggleBtn || !bgSwitchBtn || !bgControlsMount || !bgStatusBadge || !bgFollowAlbum) {
            console.warn("[背景系统] 必要DOM缺失，初始化中止。");
            return;
        }

        // 创建背景管理器
        const bgManager = new BackgroundManager({
            hostEl: bgHost,
            controlsMountEl: bgControlsMount,
            badgeEl: bgStatusBadge,
            followAlbumEl: bgFollowAlbum
        });
        window.__bgManager = bgManager;
        window.PixiBackgroundSystem = PixiBackgroundSystem;
        window.MeshBackgroundSystem = MeshBackgroundSystem;
        window.BackgroundManager = BackgroundManager;

        // 默认背景作为初始状态
        bgManager.switchBackground('default');

        // 面板开关
        const openPanel = () => { bgPanel.classList.add('show'); };
        const closePanel = () => { bgPanel.classList.remove('show'); };
        const togglePanel = () => { bgPanel.classList.toggle('show'); };

        bgToggleBtn.addEventListener('click', togglePanel);
        if (bgPanelCloseBtn) bgPanelCloseBtn.addEventListener('click', closePanel);
        if (bgPanelMinBtn) bgPanelMinBtn.addEventListener('click', closePanel);

        // Fix: iOS 触控/鼠标事件双绑定（touchstart/touchend + mousedown/mouseup + click）
        const bindBgBtn = (el, handler) => {
            if (!el || typeof handler !== 'function') return;
            let lastTouch = 0;

            el.addEventListener('touchstart', () => {}, { passive: true });
            el.addEventListener('touchend', (e) => {
                lastTouch = Date.now();
                try { if (e && e.cancelable) e.preventDefault(); } catch (_) {}
                try { handler(e); } catch (_) {}
            }, { passive: false });

            el.addEventListener('mousedown', () => {}, { passive: true });
            el.addEventListener('mouseup', () => {}, { passive: true });

            // 抑制 touchend 后的合成 click，避免双触发
            el.addEventListener('click', (e) => {
                if (Date.now() - lastTouch < 800) {
                    try { e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation(); } catch (_) {}
                }
            }, true);

            try { el.dataset.compatBound = '1'; } catch (_) {}
        };

        bindBgBtn(bgToggleBtn, togglePanel);
        if (bgPanelCloseBtn) bindBgBtn(bgPanelCloseBtn, closePanel);
        if (bgPanelMinBtn) bindBgBtn(bgPanelMinBtn, closePanel);

        // 切换背景
        const handleBgSwitch = async () => {
            try { await bgManager.cycle(); } catch (e) { console.warn('[背景系统] cycle 失败:', e); }
        };
        bgSwitchBtn.addEventListener('click', handleBgSwitch);
        bindBgBtn(bgSwitchBtn, () => { handleBgSwitch(); });

        // 拖拽
        enablePanelDrag(bgPanel, bgPanelHeader);

        // 监听专辑封面变化：确保“加载新的专辑封面后，动态背景立即更新”
        const albumArtEl = document.getElementById('albumArt');
        if (albumArtEl) {
            let last = albumArtEl.src || '';
            if (last) bgManager.lastAlbumUrl = last;

            const mo = new MutationObserver(async (mutations) => {
                for (const m of mutations) {
                    if (m.type === 'attributes' && m.attributeName === 'src') {
                        const url = albumArtEl.src || '';
                        if (url && url !== last) {
                            last = url;
                            console.log("[背景系统] 侦测到专辑封面更新，推送到背景:", url);
                            dcInfo('背景系统', `侦测到专辑封面更新：${url}`);
                            await bgManager.handleAlbumArtChanged(url);
                        }
                    }
                }
            });
            mo.observe(albumArtEl, { attributes: true, attributeFilter: ['src'] });
        } else {
            console.warn("[背景系统] 未找到 albumArt 元素，无法自动跟随封面。");
        }

        // 提供快捷接口（便于调试）
        window.switchBackground = async (type) => {
            const allowed = ['default','pixi','mesh'];
            if (!allowed.includes(type)) {
                console.warn("[switchBackground] 不支持的背景类型:", type);
                return;
            }
            bgManager.currentIndex = allowed.indexOf(type);
            await bgManager.switchBackground(type);
            openPanel();
        };

        // 输出测试报告（按需求必须先测试）
        runIntegrationTests(bgManager);
    }

    // 使用 window.load，确保原播放器 window.onload 已执行且不被覆盖
    window.addEventListener('load', () => {
        try {
            initBackgroundSystem();
        } catch (e) {
// Fix: 兼容 iOS / PWA 场景 console.error 缺失导致的崩溃
            try { console.error("[背景系统] 初始化异常:", e); } catch (e) { try { console.log("[背景系统] 初始化异常:", e); } catch (_) {} }
            dcError('背景系统', `初始化异常：${e.message || e}`);
        }
    });
})();

</script>

<script>
// Fix: 自检函数 —— 在控制台调用 checkCompatibility() 输出关键修复项状态
window.checkCompatibility = function() {
    const r = {};

    try {
        r.consoleShim = !!window.console && ['log','error','warn','info','debug','group','groupCollapsed','groupEnd','table']
            .every(m => typeof console[m] === 'function');
    } catch (_) { r.consoleShim = false; }

    r.meta = {
        appleWebAppCapable: !!document.querySelector('meta[name="apple-mobile-web-app-capable"][content="yes"]'),
        appleStatusBarStyle: !!document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]'),
        appleTouchIcon: !!document.querySelector('link[rel="apple-touch-icon"]')
    };

    const audio = document.getElementById('audioPlayer');
    r.audio = {
        exists: !!audio,
        playsinlineAttr: !!audio && audio.hasAttribute('playsinline'),
        webkitPlaysinlineAttr: !!audio && audio.hasAttribute('webkit-playsinline'),
        preload: !!audio && audio.getAttribute('preload'),
        srcSet: !!audio && !!audio.src
    };

    try {
        const vh = getComputedStyle(document.documentElement).getPropertyValue('--vh').trim();
        r.vhFix = { hasVar: !!vh, value: vh };
    } catch (_) { r.vhFix = { hasVar: false }; }

    try {
        r.safeAreaSupported = !!(window.CSS && CSS.supports && (CSS.supports('padding-top: env(safe-area-inset-top)') || CSS.supports('padding-top: constant(safe-area-inset-top)')));
    } catch (_) { r.safeAreaSupported = false; }

    // 关键绑定标记（由 bindUnifiedPress / bindBgBtn 设置）
    const ids = ['playBtn','prevBtn','nextBtn','fullscreenPlayBtn','fullscreenPrevBtn','fullscreenNextBtn','bgSwitchBtn','bgToggleBtn'];
    r.bindings = {};
    ids.forEach(id => {
        const el = document.getElementById(id);
        r.bindings[id] = !!el && !!(el.dataset && el.dataset.compatBound === '1');
    });

    r.fixState = window.__compatFix ? window.__compatFix.flags : undefined;

    // 输出
    try { console.groupCollapsed('checkCompatibility()'); } catch (_) {}
    try {
        // 先输出一份更扁平的摘要，方便快速查看
        console.table({
            consoleShim: r.consoleShim,
            appleWebAppCapable: r.meta.appleWebAppCapable,
            appleStatusBarStyle: r.meta.appleStatusBarStyle,
            appleTouchIcon: r.meta.appleTouchIcon,
            audioPlaysinline: r.audio.playsinlineAttr,
            audioWebkitPlaysinline: r.audio.webkitPlaysinlineAttr,
            vhVar: r.vhFix.hasVar,
            safeAreaSupported: r.safeAreaSupported
        });
    } catch (_) {}

    try { console.log('详细结果:', r); } catch (_) {}
    try { console.log('window.__compatFix:', window.__compatFix); } catch (_) {}
    try { console.groupEnd(); } catch (_) {}

    return r;
};

// =========================================================
// 性能优化总结 (Performance Optimizations Summary)
// =========================================================
// 1. ontimeupdate: 使用 requestAnimationFrame 节流，减少DOM操作频率
// 2. highlightCurrentLyric: 缓存DOM引用，二分查找，节流scrollIntoView
// 3. progress bar: 使用 CSS transform (scaleX) 代替 width 属性
// 4. 调试控制台: RAF 延迟滚动避免读写交错
// 5. seek 函数: 缓存 getBoundingClientRect 结果
// 6. CSS will-change: 为频繁变化的元素启用GPU加速
// =========================================================

// iOS 特定优化：减少 passive event listener 的性能开销
if (typeof window !== 'undefined') {
    // 检测是否支持 passive
    let passiveSupported = false;
    try {
        const options = {
            get passive() {
                passiveSupported = true;
                return false;
            }
        };
        window.addEventListener('test', null, options);
        window.removeEventListener('test', null, options);
    } catch (e) {}
    
    // 暴露给调试
    window.__performanceOptimizations = {
        version: '2.1-perf',
        rafThrottling: true,
        domCaching: true,
        cssTransforms: true,
        scrollThrottling: true,
        passiveEvents: passiveSupported,
        timestamp: new Date().toISOString()
    };
    
    // 性能检测函数
    window.checkPerformance = function() {
        const perf = window.__performanceOptimizations || {};
        console.log('=== 性能优化状态 ===');
        console.table(perf);
        
        // 检测是否有长任务
        if (window.PerformanceObserver) {
            console.log('提示：可以使用 PerformanceObserver 监控长任务');
        }
        return perf;
    };
}
</script>

<!-- 单文件版：已移除 Cloudflare challenge-platform 注入脚本（本地 file:// 会导致 /C:/cdn-cgi... 404） --></body>
</html>